(* Content-type: application/vnd.wolfram.mathematica *)

(*** Wolfram Notebook File ***)
(* http://www.wolfram.com/nb *)

(* CreatedBy='Mathematica 10.0' *)

(*CacheID: 234*)
(* Internal cache information:
NotebookFileLineBreakTest
NotebookFileLineBreakTest
NotebookDataPosition[       158,          7]
NotebookDataLength[    330504,      10946]
NotebookOptionsPosition[    248667,       8846]
NotebookOutlinePosition[    293143,       9778]
CellTagsIndexPosition[    293100,       9775]
WindowFrame->Normal*)

(* Beginning of Notebook Content *)
Notebook[{
Cell[BoxData[
 StyleBox[
  RowBox[{"Working", " ", "with", " ", "Unevaluated", " ", "Expressions"}], 
  "Title"]], "Input"],

Cell["\<\
Robby Villegas
Wolfram Research\
\>", "Author",
 FontSize->14],

Cell[TextData[{
 "Abstract:\n\nMost experienced Mathematica programmers will eventually \
encounter tasks or applications in which they need to manipulate expressions \
without letting them evaluate. For instance, typesetting and interpretation \
rules, debugging programs, code analysis tools, and constructing code on the \
fly at run time are all areas of programming that require careful control of \
evaluation.  Since Mathematica automatically evaluates arguments and return \
values of functions, building up a result without exposing intermediate \
stages of work to the evaluator requires subtle techniques that even seasoned \
",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " programmers sometimes find elusive. In this tutorial, I will demonstrate \
situations in which evaluation control is important, pointing out common \
pitfalls and providing useful tools and techniques along the way."
}], "Abstract",
 FontSize->14],

Cell[BoxData[{
 RowBox[{
  RowBox[{"Off", "[", 
   RowBox[{
    RowBox[{"General", "::", "spell"}], ",", " ", 
    RowBox[{"General", "::", "spell1"}]}], "]"}], 
  "\[IndentingNewLine]"}], "\n", 
 RowBox[{"Get", "[", "\"\<init.m\>\"", "]"}]}], "Input",
 InitializationCell->True],

Cell[CellGroupData[{

Cell["An Introduction to demystify scary things", "Section"],

Cell[CellGroupData[{

Cell["The overarching evaluator", "Subsubsection"],

Cell[TextData[{
 "   ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " is an interpreted language.  When ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " sees an input like this:\n\n",
 StyleBox["  f[1 + 2, 3^3, x + x + 0]", "Input",
  FontSize->12],
 "\n\nits standard procedure is to pre-evaluate the head f and the arguments \
ei before actually invoking the function f.  Thus, by the time the code for \
the function f is called, it sees this:\n\n",
 StyleBox["  f[3, 9, 2 x]", "Input",
  FontSize->12],
 "\n\nIt is the overarching ",
 StyleBox["evaluator",
  FontVariations->{"Underline"->True}],
 " that pre-processes the general form of expressions in this way."
}], "Text",
 CellDingbat->"\[EmptySmallCircle]"],

Cell[TextData[{
 "The reason ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " pre-evaluates is that it's usually what you want, in order to make \
interactive use or programming easier.  For instance, if you previously \
assigned a, b, and n values, you definitely want them substituted in before \
this the ",
 StyleBox["Expand", "Input",
  FontSize->12],
 " function is called here:"
}], "Text"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"ClearAll", "[", 
   RowBox[{"\"\<a\>\"", ",", " ", "\"\<b\>\"", ",", " ", "\"\<n\>\""}], "]"}],
   "\[IndentingNewLine]"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"{", 
    RowBox[{"a", ",", " ", "b"}], "}"}], " ", "=", " ", 
   RowBox[{"{", 
    RowBox[{"3", ",", " ", "7"}], "}"}]}], ";"}], "\n", 
 RowBox[{
  RowBox[{"n", " ", "=", " ", "7"}], ";"}]}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Expand", "[", 
  RowBox[{
   RowBox[{"(", 
    RowBox[{
     RowBox[{"a", " ", "x"}], " ", "+", " ", 
     RowBox[{"b", " ", "y"}]}], ")"}], "^", "n"}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{
  RowBox[{"2187", " ", 
   SuperscriptBox["x", "7"]}], "+", 
  RowBox[{"35721", " ", 
   SuperscriptBox["x", "6"], " ", "y"}], "+", 
  RowBox[{"250047", " ", 
   SuperscriptBox["x", "5"], " ", 
   SuperscriptBox["y", "2"]}], "+", 
  RowBox[{"972405", " ", 
   SuperscriptBox["x", "4"], " ", 
   SuperscriptBox["y", "3"]}], "+", 
  RowBox[{"2268945", " ", 
   SuperscriptBox["x", "3"], " ", 
   SuperscriptBox["y", "4"]}], "+", 
  RowBox[{"3176523", " ", 
   SuperscriptBox["x", "2"], " ", 
   SuperscriptBox["y", "5"]}], "+", 
  RowBox[{"2470629", " ", "x", " ", 
   SuperscriptBox["y", "6"]}], "+", 
  RowBox[{"823543", " ", 
   SuperscriptBox["y", "7"]}]}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "And in this example, you want the ",
 StyleBox["D", "Input",
  FontSize->12],
 " to compute the derivative expression before ",
 StyleBox["Simplify", "Input",
  FontSize->12],
 " goes to work, since before ",
 StyleBox["D", "Input",
  FontSize->12],
 " produces an expression, there's really nothing to simplify:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Simplify", "[", " ", 
  RowBox[{"D", "[", 
   RowBox[{
    RowBox[{"ArcSin", "[", "x", "]"}], ",", " ", 
    RowBox[{"{", 
     RowBox[{"x", ",", " ", "8"}], "}"}]}], "]"}], " ", "]"}]], "Input"],

Cell[BoxData[
 FractionBox[
  RowBox[{"315", " ", "x", " ", 
   RowBox[{"(", 
    RowBox[{"35", "+", 
     RowBox[{"210", " ", 
      SuperscriptBox["x", "2"]}], "+", 
     RowBox[{"168", " ", 
      SuperscriptBox["x", "4"]}], "+", 
     RowBox[{"16", " ", 
      SuperscriptBox["x", "6"]}]}], ")"}]}], 
  SuperscriptBox[
   RowBox[{"(", 
    RowBox[{"1", "-", 
     SuperscriptBox["x", "2"]}], ")"}], 
   RowBox[{"15", "/", "2"}]]]], "Output"]
}, Open  ]],

Cell[TextData[{
 "If Simplify acted on its literal argument, ",
 StyleBox["D[ArcSin[x], {x, 8}]", "Input",
  FontSize->12],
 ", what could it try to simplify?  ArcSin[x]?  x?  8??  That would not make \
sense, so the argument evaluates first, then the outer function is called."
}], "Text"],

Cell[TextData[{
 "So, in general, before f is actually called, there are ",
 StyleBox["two stages of your input",
  FontVariations->{"Underline"->True}],
 ".  Here they are using the generic form from earlier:\n\n(Before)",
 StyleBox["  f[1 + 2, 3^3, x + x + 0]\n  ", "Input",
  FontSize->12],
 "\n(After)",
 StyleBox["  f[3, 9, 2 x]", "Input",
  FontSize->12],
 "\n\nThe first stage is your original input before the evaluator gets its \
hands on it.\nThe second stage has the head and arguments evaluated.\n\nIt is \
the second that actually calls f, so f never sees the original arguments like \
1 + 2, only the reduced arguments like 3!"
}], "Text",
 CellDingbat->None],

Cell[TextData[{
 "I usually think of the evaluator's pre-processing as applying the \
\"evaluator function\", call it eval(), to all the parts.  I colored the head \
red and the arguments blue to emphasize them.\n\n",
 StyleBox["  ", "Input",
  FontSize->12],
 StyleBox["f", "Input",
  FontSize->12,
  FontColor->RGBColor[1, 0, 0]],
 StyleBox["[", "Input",
  FontSize->12],
 StyleBox["e1", "Input",
  FontSize->12,
  FontColor->RGBColor[0, 0, 1]],
 StyleBox[", ..., ", "Input",
  FontSize->12],
 StyleBox["en", "Input",
  FontSize->12,
  FontColor->RGBColor[0, 0, 1]],
 StyleBox["]\n  \n     ", "Input",
  FontSize->12],
 Cell[BoxData[
  FormBox[
   StyleBox["\[DoubleLongRightArrow]",
    SpanMinSize->4,
    SpanMaxSize->4], TraditionalForm]]],
 StyleBox["\n     ", "Input",
  FontSize->12],
 "\n",
 StyleBox["  eval(", "Input",
  FontSize->12],
 StyleBox["f", "Input",
  FontSize->12,
  FontColor->RGBColor[1, 0, 0]],
 StyleBox[") [ eval(", "Input",
  FontSize->12],
 StyleBox["e1", "Input",
  FontSize->12,
  FontColor->RGBColor[0, 0, 1]],
 StyleBox["), ..., eval(", "Input",
  FontSize->12],
 StyleBox["en", "Input",
  FontSize->12,
  FontColor->RGBColor[0, 0, 1]],
 StyleBox[") ]\n", "Input",
  FontSize->12],
 "\nFor those of you familiar with the evaluation sequence in Appendix \
\"A.4.1 The Standard Evaluation Sequence\" of the ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " book, I'm talking about steps 2 through 4, usually called \"standard \
argument evaluation\"."
}], "Text",
 CellDingbat->None],

Cell["\<\
   Here's a contrived example to show that simple arithmetic reduces the head \
and argument to sensible values.  Again, I've colored the head and argument, \
and made the function brackets large, to make it clear that this example is \
really of the simple form f[x], with f and x being sort of weird, complex \
things:\
\>", "Text",
 CellDingbat->"\[EmptySmallCircle]"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  StyleBox[
   RowBox[{"(", 
    RowBox[{
     RowBox[{"1", "*", "FactorInteger"}], " ", "+", " ", "0"}], ")"}],
   FontColor->RGBColor[1, 0, 0]], "  ", 
  StyleBox["[",
   SpanMinSize->3,
   SpanMaxSize->3], " ", 
  StyleBox[
   RowBox[{
    RowBox[{"2", "^", "2"}], " ", "*", " ", 
    RowBox[{"3", "^", "3"}]}],
   FontColor->RGBColor[0, 0, 1]], " ", 
  StyleBox["]",
   SpanMinSize->3,
   SpanMaxSize->3]}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"2", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "3"}], "}"}]}], "}"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 StyleBox["Trace", "Input",
  FontSize->12],
 " seems like a scary function, but you can use it in this case to catch the \
evaluation of head and argument, and see that it results in a nice, simple ",
 StyleBox["FactorInteger[108]", "Input",
  FontSize->12],
 ", which is then evaluated.  I've taken the liberty of arranging the ",
 StyleBox["Trace", "Input",
  FontSize->12],
 " result in a column and coloring the head and argument evaluations just as \
above to make it clear what each evaluation chain is."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Trace", "[", " ", 
  RowBox[{
   StyleBox[
    RowBox[{"(", 
     RowBox[{
      RowBox[{"1", "*", "FactorInteger"}], " ", "+", " ", "0"}], ")"}],
    FontColor->RGBColor[1, 0, 0]], "  ", 
   StyleBox["[",
    SpanMinSize->3,
    SpanMaxSize->3], " ", 
   StyleBox[
    RowBox[{
     RowBox[{"2", "^", "2"}], " ", "*", " ", 
     RowBox[{"3", "^", "3"}]}],
    FontColor->RGBColor[0, 0, 1]], " ", 
   StyleBox["]",
    SpanMinSize->3,
    SpanMaxSize->3]}], 
  StyleBox[" ",
   SpanMinSize->3,
   SpanMaxSize->3], "]"}]], "Input"],

Cell[BoxData[
 TagBox[GridBox[{
    {
     StyleBox[
      RowBox[{"{", 
       RowBox[{
        RowBox[{"{", 
         RowBox[{
          TagBox[
           RowBox[{"1", " ", "FactorInteger"}],
           HoldForm], ",", 
          TagBox["FactorInteger",
           HoldForm]}], "}"}], ",", 
        TagBox[
         RowBox[{"FactorInteger", "+", "0"}],
         HoldForm], ",", 
        TagBox["FactorInteger",
         HoldForm]}], "}"}],
      FontWeight->"Bold",
      FontColor->RGBColor[1, 0, 0]]},
    {
     StyleBox[
      RowBox[{"{", 
       RowBox[{
        RowBox[{"{", 
         RowBox[{
          TagBox[
           SuperscriptBox["2", "2"],
           HoldForm], ",", 
          TagBox["4",
           HoldForm]}], "}"}], ",", 
        RowBox[{"{", 
         RowBox[{
          TagBox[
           SuperscriptBox["3", "3"],
           HoldForm], ",", 
          TagBox["27",
           HoldForm]}], "}"}], ",", 
        TagBox[
         RowBox[{"4", " ", "27"}],
         HoldForm], ",", 
        TagBox["108",
         HoldForm]}], "}"}],
      FontWeight->"Bold",
      FontColor->RGBColor[0, 0, 1]]},
    {
     TagBox[
      StyleBox[
       RowBox[{"FactorInteger", "[", "108", "]"}],
       FontWeight->"Bold"],
      HoldForm]},
    {
     TagBox[
      RowBox[{"{", 
       RowBox[{
        RowBox[{"{", 
         RowBox[{"2", ",", "2"}], "}"}], ",", 
        RowBox[{"{", 
         RowBox[{"3", ",", "3"}], "}"}]}], "}"}],
      HoldForm]}
   },
   BaselinePosition->Top,
   GridBoxSpacings->{"Columns" -> {
       Offset[0.27999999999999997`], {
        Offset[0.5599999999999999]}, 
       Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
       Offset[0.2], {
        Offset[1.2]}, 
       Offset[0.2]}, "RowsIndexed" -> {}}],
  Grid]], "Output",
 CellEditDuplicate->False,
 GridBoxOptions->{
 GridBoxAlignment->{
  "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
   "RowsIndexed" -> {}}}]
}, Open  ]],

Cell[TextData[{
 StyleBox["\nThe point of this is to get you thinking of each input, and each \
statement in your programs, as having two stages:  the original stage that \
you typed (or constructed), and the reduced stage where arguments have been \
evaluated.  And to remember that the function isn't called until the second \
stage, so it ",
  FontVariations->{"Underline"->True}],
 StyleBox["doesn't know",
  FontSlant->"Italic",
  FontVariations->{"Underline"->True}],
 StyleBox[" what the original form was.\n",
  FontVariations->{"Underline"->True}]
}], "Text",
 FontSize->16,
 FontWeight->"Bold"],

Cell[TextData[{
 "   There are cases where you really want f to receive the arguments as \
given by the user or the programmer, not the pre-processed, i.e. evaluated, \
form.  Since the default behavior of the ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " language interpreter is to evaluate everything in sight until nothing more \
changes, you need to use non-default techniques to prevent evaluation.\n\n\
Sometimes you want to send an argument into the function unevaluated.  For \
instance, when typesetting, or analyzing some code, you might want to compute \
",
 StyleBox["Length", "Input",
  FontSize->12],
 " of the expression ",
 StyleBox["Print[1, 2, 3]", "Input",
  FontSize->12],
 ", or use ",
 StyleBox["Cases", "Input",
  FontSize->12],
 " to extract the numbers from the mixed sum ",
 StyleBox["1 + 3.5 + Pi + x + (3 - I)^2", "Input",
  FontSize->12],
 ".\n\nSometimes you want the return value of the function to remain \
unevaluated until you can do something else with it.\n\nThat is the subject \
of this talk."
}], "Text",
 CellDingbat->"\[EmptySmallCircle]"],

Cell["\<\


\
\>", "Text",
 CellDingbat->None],

Cell[TextData[{
 "Advanced note:  As you may know, in addition to evaluating head and \
arguments, the evaluator does other pre-processing to the original input, \
such as flatten ",
 StyleBox["Sequence,", "Input",
  FontSize->12],
 " and invoke upvalues on arguments.  These things can all alter the original \
input before the main function ever gets called.  You might want to prevent \
some or all of these alterations."
}], "Text",
 CellDingbat->"\[EmptySmallCircle]"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
An unevaluated expression is just an expression, a tree structure like \
anything else.\
\>", "Subsubsection"],

Cell["\<\
Before we start, I want to mention that an \"unevaluated\" expression is just \
an expression.  It's a tree structure that you can draw and see with your \
eyes:\
\>", "Text"],

Cell[BoxData[
 RowBox[{"Plus", "[", 
  RowBox[{"3", ",", " ", "4", ",", " ", 
   RowBox[{"Times", "[", 
    RowBox[{"5", ",", " ", "6"}], "]"}], ",", " ", 
   RowBox[{"Power", "[", 
    RowBox[{"5", ",", " ", "2"}], "]"}]}], "]"}]], "Input"],

Cell[TextData[{
 "For a moment, let yourself forget that ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " would yank this expression out of your hands and give you back the integer \
62.  Imagine that you can manipulate it as an ",
 StyleBox["abstract structure",
  FontSlant->"Italic"],
 " whose heads and elements are meaningless.  That's what you're going to \
learn to do in this talk.\n\nSince this expression is structurally the same \
as more stable ones like {3, 4, {5, 6}, {5, 2}}, programming commands that \
you are familiar with can operate on it, as long as you can see to it that \
the expression arrives unaltered at the code of the function.\n\nThere's \
nothing scary about operating on these; it's just a little harder to keep the \
evaluator's hands off them for a moment until you're ready for them to \
evaluate."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Simple uses of Unevaluated", "Subsubsection"],

Cell[TextData[{
 "Let's look at some simple uses of ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 "."
}], "Text"],

Cell[TextData[{
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 " is a wrapper on arguments that is simply a signal to the evaluator to \
avoid evaluating the argument."
}], "Text",
 CellDingbat->"\[EmptySmallCircle]"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Head", "[", " ", 
  RowBox[{"Unevaluated", "[", 
   RowBox[{"Plus", "[", 
    RowBox[{"1", ",", " ", "2", ",", " ", "3"}], "]"}], "]"}], " ", 
  "]"}]], "Input"],

Cell[BoxData["Plus"], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Length", "[", " ", 
  RowBox[{"Unevaluated", "[", 
   RowBox[{"Print", "[", 
    RowBox[{"\"\<spam\>\"", ",", " ", "\"\<and\>\"", ",", "\"\<eggs\>\""}], 
    "]"}], "]"}], " ", "]"}]], "Input"],

Cell[BoxData["3"], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"ToString", "[", " ", 
  RowBox[{"Unevaluated", "[", 
   RowBox[{
    RowBox[{"2", "^", "2"}], " ", "*", " ", 
    RowBox[{"3", "^", "3"}], " ", "*", " ", 
    RowBox[{"5", "^", "5"}]}], "]"}], " ", "]"}]], "Input"],

Cell[BoxData["\<\" 2  3  5\\n2  3  5\"\>"], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Cases", "[", 
  RowBox[{
   RowBox[{"Unevaluated", "[", 
    RowBox[{"1", "+", "3.5", "+", "Pi", "+", "x", "+", 
     RowBox[{
      RowBox[{"(", 
       RowBox[{"3", "-", "I"}], ")"}], "^", "2"}]}], "]"}], ",", " ", 
   RowBox[{"_Integer", " ", "|", " ", "_Rational", " ", "|", " ", "_Real"}]}],
   "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"1", ",", "3.5`"}], "}"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "It is ",
 StyleBox["transparent",
  FontSlant->"Italic"],
 " to the function receiving the argument.  You can think of it as a shuttle \
giving the argument safe transport to the function's code, keeping the \
evaluator away.  ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 " vanishes before the argument is fed to the function, since its purpose is \
fulfilled."
}], "Text"],

Cell["Mapping a function across an unevaluated list of elements:", "Text",
 CellDingbat->"\[EmptySmallCircle]"],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"{", 
    RowBox[{"x", ",", " ", "y", ",", " ", "z"}], "}"}], " ", "=", " ", 
   RowBox[{"{", 
    RowBox[{"77", ",", " ", "88", ",", " ", "99"}], "}"}]}], ";"}]], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Map", "[", 
  RowBox[{"Context", ",", " ", 
   RowBox[{"Unevaluated", "[", 
    RowBox[{"{", 
     RowBox[{"x", ",", " ", "y", ",", " ", "z"}], "}"}], "]"}]}], " ", 
  "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"\<\"Global`\"\>", ",", "\<\"Global`\"\>", ",", "\<\"Global`\"\>"}],
   "}"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "Without the ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 ", the x, y, and z would become integers before ",
 StyleBox["Context", "Input",
  FontSize->12],
 " could act on them:"
}], "Text",
 CellDingbat->None],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Map", "[", 
  RowBox[{"Context", ",", " ", 
   RowBox[{"{", 
    RowBox[{"x", ",", " ", "y", ",", " ", "z"}], "}"}]}], " ", "]"}]], "Input"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Context", "::", "\<\"ssle\"\>"}], 
  RowBox[{
  ":", " "}], "\<\"Symbol, string, or HoldPattern[symbol] expected at \
position \\!\\(1\\) in \\!\\(Context[77]\\).\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Context", "::", "\<\"ssle\"\>"}], 
  RowBox[{
  ":", " "}], "\<\"Symbol, string, or HoldPattern[symbol] expected at \
position \\!\\(1\\) in \\!\\(Context[88]\\).\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Context", "::", "\<\"ssle\"\>"}], 
  RowBox[{
  ":", " "}], "\<\"Symbol, string, or HoldPattern[symbol] expected at \
position \\!\\(1\\) in \\!\\(Context[99]\\).\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], 
  RowBox[{
  ":", " "}], "\<\"Further output of \\!\\(Context :: \\\"ssle\\\"\\) will be \
suppressed during this calculation.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"Context", "[", "77", "]"}], ",", 
   RowBox[{"Context", "[", "88", "]"}], ",", 
   RowBox[{"Context", "[", "99", "]"}]}], "}"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Scan", "[", 
  RowBox[{"Information", ",", " ", 
   RowBox[{"Unevaluated", "[", 
    RowBox[{"{", 
     RowBox[{"$Version", ",", " ", "$RecursionLimit"}], "}"}], "]"}]}], 
  "]"}]], "Input"],

Cell[BoxData["\<\"$Version is a string that represents the version of \
Mathematica you are running.\"\>"], "Print"],

Cell[BoxData[
 InterpretationBox[GridBox[{
    {
     RowBox[{
      RowBox[{"Attributes", "[", "$Version", "]"}], "=", 
      RowBox[{"{", 
       RowBox[{"Locked", ",", "Protected"}], "}"}]}]},
    {" "},
    {GridBox[{
       {
        RowBox[{
        "$Version", "=", "\<\"4.0 for Linux (September 21, 1999)\"\>"}]}
      },
      BaselinePosition->{Baseline, {1, 1}},
      GridBoxAlignment->{
       "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
        "RowsIndexed" -> {}},
      GridBoxItemSize->{"Columns" -> {{
           Scaled[0.999]}}, "ColumnsIndexed" -> {}, "Rows" -> {{1.}}, 
        "RowsIndexed" -> {}}]}
   },
   BaselinePosition->{Baseline, {1, 1}},
   GridBoxAlignment->{
    "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
     "RowsIndexed" -> {}}],
  Definition[$Version],
  Editable->False]], "Print"],

Cell[BoxData["\<\"$RecursionLimit gives the current limit on the number of \
levels of recursion that Mathematica can use.\"\>"], "Print"],

Cell[BoxData[
 InterpretationBox[GridBox[{
    {GridBox[{
       {
        RowBox[{"$RecursionLimit", "=", "1024"}]}
      },
      BaselinePosition->{Baseline, {1, 1}},
      GridBoxAlignment->{
       "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
        "RowsIndexed" -> {}},
      GridBoxItemSize->{"Columns" -> {{
           Scaled[0.999]}}, "ColumnsIndexed" -> {}, "Rows" -> {{1.}}, 
        "RowsIndexed" -> {}}]}
   },
   BaselinePosition->{Baseline, {1, 1}},
   GridBoxAlignment->{
    "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
     "RowsIndexed" -> {}}],
  Definition[$RecursionLimit],
  Editable->False]], "Print"]
}, Open  ]],

Cell[TextData[{
 "If you've got a set of things inside ",
 StyleBox["Hold", "Input",
  FontSize->12],
 ", and you want to map a non-holding function such as ",
 StyleBox["Head", "Input",
  FontSize->12],
 " across them, then you can use the idiom:\n\n",
 StyleBox["   f /@ Unevaluated /@ Hold[e1, ..., en]", "Input",
  FontSize->12],
 "\n\nwhich will form this frozen expression, with the calls to f colored in \
blue:\n\n",
 StyleBox["   Hold[ ", "Input",
  FontSize->12],
 StyleBox["f[Unevaluated[e1]]", "Input",
  FontSize->12,
  FontColor->RGBColor[0, 0, 1]],
 StyleBox[", ..., ", "Input",
  FontSize->12],
 StyleBox["f[Unevaluated[en]]", "Input",
  FontSize->12,
  FontColor->RGBColor[0, 0, 1]],
 StyleBox[" ]", "Input",
  FontSize->12],
 "\n\nNow it is safe to let the elements evaluate.  You could do this by \
changing the outer head to List.  Here is a small example:"
}], "Text",
 CellDingbat->"\[EmptySmallCircle]"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"List", " ", "@@", "\[IndentingNewLine]", 
  RowBox[{"Map", "[", 
   RowBox[{"Head", ",", " ", 
    RowBox[{"Map", "[", 
     RowBox[{"Unevaluated", ",", "\[IndentingNewLine]", 
      RowBox[{"Hold", "[", 
       RowBox[{
        RowBox[{"Print", "[", "1", "]"}], ",", " ", 
        RowBox[{"2", " ", "+", " ", "3"}]}], "]"}]}], "\[IndentingNewLine]", 
     "]"}]}], "]"}]}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"Print", ",", "Plus"}], "}"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "You can use the more complex structural and functional programming commands \
that you enjoy, too.  They don't care that the argument arrives unevaluated; \
it's just a structure to them.  Here's an example of ",
 StyleBox["Through", "Input",
  FontSize->12],
 ", to produce a list of all the kinds of assignments made to a symbol:"
}], "Text",
 CellDingbat->"\[EmptySmallCircle]"],

Cell[BoxData[
 RowBox[{
  RowBox[{"$ValueTypes", "=", 
   RowBox[{"{", 
    RowBox[{
    "Attributes", ",", "DefaultValues", ",", "DownValues", ",", 
     "FormatValues", ",", "Messages", ",", "NValues", ",", "OwnValues", ",", 
     "Options", ",", "SubValues", ",", "UpValues"}], "}"}]}], ";"}]], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"??", " ", "$Version"}]], "Input"],

Cell[BoxData["\<\"$Version is a string that represents the version of \
Mathematica you are running.\"\>"], "Print"],

Cell[BoxData[
 InterpretationBox[GridBox[{
    {
     RowBox[{
      RowBox[{"Attributes", "[", "$Version", "]"}], "=", 
      RowBox[{"{", 
       RowBox[{"Locked", ",", "Protected"}], "}"}]}]},
    {" "},
    {GridBox[{
       {
        RowBox[{
        "$Version", "=", "\<\"4.0 for Linux (September 21, 1999)\"\>"}]}
      },
      BaselinePosition->{Baseline, {1, 1}},
      GridBoxAlignment->{
       "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
        "RowsIndexed" -> {}},
      GridBoxItemSize->{"Columns" -> {{
           Scaled[0.999]}}, "ColumnsIndexed" -> {}, "Rows" -> {{1.}}, 
        "RowsIndexed" -> {}}]}
   },
   BaselinePosition->{Baseline, {1, 1}},
   GridBoxAlignment->{
    "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
     "RowsIndexed" -> {}}],
  Definition[$Version],
  Editable->False]], "Print"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Through", "[", " ", 
  RowBox[{"$ValueTypes", "[", 
   RowBox[{"Unevaluated", "[", "$Version", "]"}], "]"}], " ", "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"Locked", ",", "Protected"}], "}"}], ",", 
   RowBox[{"{", "}"}], ",", 
   RowBox[{"{", "}"}], ",", 
   RowBox[{"{", "}"}], ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"HoldPattern", "[", 
      RowBox[{"$Version", "::", "\<\"usage\"\>"}], "]"}], 
     "\[RuleDelayed]", "\<\"$Version is a string that represents the version \
of Mathematica you are running.\"\>"}], "}"}], ",", 
   RowBox[{"{", "}"}], ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"HoldPattern", "[", "$Version", "]"}], 
     "\[RuleDelayed]", "\<\"4.0 for Linux (September 21, 1999)\"\>"}], "}"}], 
   ",", 
   RowBox[{"{", "}"}], ",", 
   RowBox[{"{", "}"}], ",", 
   RowBox[{"{", "}"}]}], "}"}]], "Output"]
}, Open  ]],

Cell["\<\
It's easier to read if we make a match-up and display it as a column:\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"Thread", "[", 
   RowBox[{"$ValueTypes", " ", "\[Rule]", " ", 
    RowBox[{"Through", "[", 
     RowBox[{"$ValueTypes", " ", "@", " ", 
      RowBox[{"Unevaluated", "[", "$Version", "]"}]}], "]"}]}], "]"}], " ", "//",
   "ColumnForm"}]], "Input"],

Cell[BoxData[
 InterpretationBox[GridBox[{
    {
     RowBox[{"Attributes", "\[Rule]", 
      RowBox[{"{", 
       RowBox[{"Locked", ",", "Protected"}], "}"}]}]},
    {
     RowBox[{"DefaultValues", "\[Rule]", 
      RowBox[{"{", "}"}]}]},
    {
     RowBox[{"DownValues", "\[Rule]", 
      RowBox[{"{", "}"}]}]},
    {
     RowBox[{"FormatValues", "\[Rule]", 
      RowBox[{"{", "}"}]}]},
    {
     RowBox[{"Messages", "\[Rule]", 
      RowBox[{"{", 
       RowBox[{
        RowBox[{"HoldPattern", "[", 
         RowBox[{"$Version", "::", "\<\"usage\"\>"}], "]"}], 
        "\[RuleDelayed]", "\<\"$Version is a string that represents the \
version of Mathematica you are running.\"\>"}], "}"}]}]},
    {
     RowBox[{"NValues", "\[Rule]", 
      RowBox[{"{", "}"}]}]},
    {
     RowBox[{"OwnValues", "\[Rule]", 
      RowBox[{"{", 
       RowBox[{
        RowBox[{"HoldPattern", "[", "$Version", "]"}], 
        "\[RuleDelayed]", "\<\"4.0 for Linux (September 21, 1999)\"\>"}], 
       "}"}]}]},
    {
     RowBox[{"Options", "\[Rule]", 
      RowBox[{"{", "}"}]}]},
    {
     RowBox[{"SubValues", "\[Rule]", 
      RowBox[{"{", "}"}]}]},
    {
     RowBox[{"UpValues", "\[Rule]", 
      RowBox[{"{", "}"}]}]}
   },
   BaselinePosition->{Baseline, {1, 1}},
   GridBoxAlignment->{
    "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
     "RowsIndexed" -> {}}],
  ColumnForm[{
   Attributes -> {Locked, Protected}, DefaultValues -> {}, DownValues -> {}, 
    FormatValues -> {}, Messages -> {HoldPattern[
        MessageName[$Version, "usage"]] :> 
      "$Version is a string that represents the version of Mathematica you \
are running."}, NValues -> {}, 
    OwnValues -> {
     HoldPattern[$Version] :> "4.0 for Linux (September 21, 1999)"}, 
    Options -> {}, SubValues -> {}, UpValues -> {}}],
  Editable->False]], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
 "Unevaluated must be wrapper ",
 StyleBox["before argument evaluation",
  FontSlant->"Italic"],
 ", not after, else it isn't stripped"
}], "Subsubsection"],

Cell[TextData[{
 "Recall our discussion of the over-arching evaluator, and the fact that your \
inputs and commands have two stages:  their original form, and the reduced \
form with arguments all evaluated.\n\n",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 " is not meant to be a function or stable data type.  It is to be used as a \
wrapper on an argument ",
 StyleBox["in stage 1",
  FontSlant->"Italic"],
 ", before argument evaluation.  It is a ",
 StyleBox["signal to the evaluator",
  FontSlant->"Italic"],
 " to suppress the usual evaluation of that argument.\n\n",
 StyleBox["   f[1, Unevaluated[2 + 2^2], 3]", "Input",
  FontSize->12],
 "\n\nOnce the evaluator has made a note not to evaluate that argument, ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 "'s purpose is fulfilled, so it vanishes before the argument is actually fed \
to f.  This is in contrast to ",
 StyleBox["Hold", "Input",
  FontSize->12],
 ", which is an actual data type, if you will, and persists as a head until \
you discard it (with ",
 StyleBox["ReleaseHold", "Input",
  FontSize->12],
 " or however you like)."
}], "Text"],

Cell[TextData[{
 "For instance, I can extract the head of a sum and get ",
 StyleBox["Plus", "Input",
  FontSize->12],
 ", as I expect:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Head", "[", " ", 
  RowBox[{"Unevaluated", "[", 
   RowBox[{"1", "+", "3.5", "+", "Pi", "+", "x", "+", 
    RowBox[{
     RowBox[{"(", 
      RowBox[{"3", "-", "I"}], ")"}], "^", "2"}]}], "]"}], " ", 
  "]"}]], "Input"],

Cell[BoxData["Plus"], "Output"]
}, Open  ]],

Cell[TextData[{
 "But if I had used ",
 StyleBox["Hold", "Input",
  FontSize->12],
 " instead of ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 ", it would not have worked right:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Head", "[", " ", 
  RowBox[{"Hold", "[", 
   RowBox[{"1", "+", "3.5", "+", "Pi", "+", "x", "+", 
    RowBox[{
     RowBox[{"(", 
      RowBox[{"3", "-", "I"}], ")"}], "^", "2"}]}], "]"}], " ", 
  "]"}]], "Input"],

Cell[BoxData["Hold"], "Output"]
}, Open  ]],

Cell[TextData[{
 "Those of you who have experimented with ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 " have found that in some situations it doesn't vanish.  This makes it seem \
confusing and inconsistent, like ",
 StyleBox["Sequence", "Input",
  FontSize->12],
 ".\n\nThe least confusing situation where ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 " persists is when it is the outermost head in the output.  This is not too \
surprising, since it's not an argument of anything."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Unevaluated", "[", " ", 
  RowBox[{
   RowBox[{"Print", "[", "1", "]"}], " ", "/", " ", 
   RowBox[{"2", "^", "3"}]}], " ", "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"Unevaluated", "[", 
  FractionBox[
   RowBox[{"Print", "[", "1", "]"}], 
   SuperscriptBox["2", "3"]], "]"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "Another case where ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 " is when it's an argument of a head that does nothing.  List is an example \
of an inert data type that performs no action:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"1", ",", " ", 
   RowBox[{"Unevaluated", "[", 
    RowBox[{"2", "^", "2"}], "]"}]}], "}"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"1", ",", 
   RowBox[{"Unevaluated", "[", 
    SuperscriptBox["2", "2"], "]"}]}], "}"}]], "Output"]
}, Open  ]],

Cell["So is an arbitrary symbol with no definitions:", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"f", "[", 
  RowBox[{
   RowBox[{"Unevaluated", "[", 
    RowBox[{"1", " ", "+", " ", "0"}], "]"}], ",", " ", "2"}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"f", "[", 
  RowBox[{
   RowBox[{"Unevaluated", "[", 
    RowBox[{"1", "+", "0"}], "]"}], ",", "2"}], "]"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "When no code is invoked to \"use it up\", ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 " just sits there unused."
}], "Text"],

Cell[TextData[{
 "\nThe subtle and confusing situation where ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 " persists is when an argument did not originally have a head of ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 ", but became ",
 StyleBox["Unevaluated[whatever]", "Input",
  FontSize->12],
 " after argument evaluation finished.  In terms of the two stages of each \
input:\n\nstage 1 (original input):  ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 " vanishes, nicely.\n\nstage 2 (after arg evaluation):  ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 " persists, annoyingly."
}], "Text"],

Cell[TextData[{
 "In this example, the original argument of ",
 StyleBox["Print", "Input",
  FontSize->12],
 " has head ",
 StyleBox["ToExpression", "Input",
  FontSize->12],
 ".  ",
 StyleBox["ToExpression", "Input",
  FontSize->12],
 " yields ",
 StyleBox["Unevaluated[1 + 2]", "Input",
  FontSize->12],
 " after evaluation, but that's too late:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Print", "[", " ", 
  RowBox[{"ToExpression", "[", "\"\<Unevaluated[1 + 2]\>\"", "]"}], " ", 
  "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"Unevaluated", "[", 
  RowBox[{"1", "+", "2"}], "]"}]], "Print"]
}, Open  ]],

Cell["\<\
In this example, the argument's original head is a complex Function[...] \
expression, not even a symbol.  It yields Unevaluated[77 + 99^2], but again\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Head", "[", " ", 
  StyleBox[
   RowBox[{
    RowBox[{
     RowBox[{"Unevaluated", "[", 
      RowBox[{"#1", " ", "+", " ", 
       RowBox[{"#2", "^", "2"}]}], "]"}], "&"}], " ", "[", 
    RowBox[{"77", ",", " ", "99"}], "]"}], "Input",
   FontSize->12], 
  StyleBox[" ", "Input",
   FontSize->12], 
  StyleBox["]", "Input",
   FontSize->12]}]], "Input"],

Cell[BoxData["Unevaluated"], "Output"]
}, Open  ]],

Cell[TextData[{
 "If I give an argument which, ",
 StyleBox["after evaluation",
  FontSlant->"Italic"],
 ", will become something whose head is ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 " - ",
 StyleBox["Unevaluated[arg]", "Input",
  FontSize->12],
 " - and it won't work.\n\nThis subtle distinction of stages of your input \
has tripped up almost every ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " programmer I know, no matter how advanced."
}], "Text"],

Cell[TextData[{
 "Since in real programs, you often have to construct the arguments from \
pieces, and can't just write them out in final form in the function call, \
we'll have to learn methods of making sure the ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 " is literally present as a wrapper in the function call."
}], "Text"]
}, Closed]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Several specific techniques", "Section"],

Cell[CellGroupData[{

Cell["Manipulations", "Subsection"],

Cell[CellGroupData[{

Cell["\<\
Use Function[] to make a temporary holding version of a function\
\>", "Subsubsection"],

Cell[TextData[{
 "Most built-in and user-defined functions let their arguments evaluate by \
default.  Suppose for a particular line of code, you need a version of ",
 StyleBox["Head", "Input",
  FontSize->12],
 " that doesn't evaluate its arguments.  One way, of course, would be to \
temporarily give ",
 StyleBox["Head", "Input",
  FontSize->12],
 " the ",
 StyleBox["HoldFirst", "Input",
  FontSize->12],
 " attribute, but it's usually unsafe to change the definition of basic \
built-in functions.  Fortunately, the language enables you to give pure \
functions the same attributes you would give to symbols.  Here is the \
template for constructing a temporary holding version:\n\n",
 StyleBox["  ", "Input",
  FontSize->12],
 Cell[BoxData[
  RowBox[{"MyHead", " ", "=", " ", 
   RowBox[{"Function", "[", 
    RowBox[{"e", ",", " ", 
     RowBox[{"Head", "[", " ", 
      RowBox[{"Unevaluated", "[", "e", "]"}], " ", "]"}], ",", " ", 
     "HoldFirst"}], "]"}]}]], "Input",
  FontSize->12],
 "\n\nThis is essentially the same as the more familiar, simpler pure \
function\n\n",
 StyleBox["  MyHead = Head[#]&", "Input",
  FontSize->12],
 "\n\nbut it has to use the 3-argument form of ",
 StyleBox["Function", "Input",
  FontSize->12],
 " with a named variable in order to give it the ",
 StyleBox["HoldFirst", "Input",
  FontSize->12],
 " attribute."
}], "Text"],

Cell[TextData[{
 "Now you can use ",
 StyleBox["MyHead", "Input",
  FontSize->12],
 " just like you would use ",
 StyleBox["Head", "Input",
  FontSize->12],
 ".  If the argument comes in unevaluated, it will remain that way.  For \
instance:"
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"MyHead", " ", "=", " ", 
   RowBox[{"Function", "[", 
    RowBox[{"e", ",", " ", 
     RowBox[{"Head", "[", " ", 
      RowBox[{"Unevaluated", "[", "e", "]"}], " ", "]"}], ",", " ", 
     "HoldFirst"}], "]"}]}], ";"}]], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"MyHead", " ", "/@", " ", 
  RowBox[{"Unevaluated", "[", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"Print", "[", "1", "]"}], ",", " ", 
     RowBox[{"2", " ", "+", " ", 
      RowBox[{"2", "^", "2"}]}], ",", " ", 
     RowBox[{"x", " ", "=", " ", "3"}]}], "}"}], "]"}]}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"Print", ",", "Plus", ",", "Set"}], "}"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "There's no need to give the function a name; I just did that to make the \
example more concise.  Usually you use ",
 StyleBox["Function[]", "Input",
  FontSize->12],
 " because you want to construct one-shot operators on the fly, to use in a \
single line of code."
}], "Text"],

Cell["Here's an example of a held list of elements:", "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"heldElems", " ", "=", " ", 
   RowBox[{"Hold", "[", 
    RowBox[{
     RowBox[{"Print", "[", "1", "]"}], ",", " ", 
     RowBox[{"Print", "[", 
      RowBox[{"2", " ", "+", " ", "3"}], "]"}], ",", " ", 
     RowBox[{"0", " ", "+", " ", "1"}], ",", " ", 
     RowBox[{"1", " ", "+", " ", "2"}], ",", " ", 
     RowBox[{"2", " ", "+", " ", "3"}], ",", " ", 
     RowBox[{"0", "*", "1"}], ",", " ", 
     RowBox[{"1", "*", "2", "*", "3"}], ",", " ", 
     RowBox[{"4", "^", "4"}]}], "]"}]}], ";"}]], "Input"],

Cell[TextData[{
 "We want to group consecutive elements if they have the same head, i.e.\n\n\
",
 StyleBox["  ", "Input",
  FontSize->12],
 StyleBox["Head[#1] === Head[#2] &", "Input",
  FontSize->12],
 "\n\nBut this ordinary form of pure function will evaluate #1 and #2, which \
will destroy the structure in things like ",
 StyleBox["Print[1]", "Input",
  FontSize->12],
 " and ",
 StyleBox["0 + 1", "Input",
  FontSize->12],
 ", so we have to prevent that.  We do it by converting that function to the \
longer form:\n\n",
 StyleBox["  Function[{e1, e2}, Head[Unevaluated[e1]] === \
Head[Unevaluated[e2]], HoldAll]\n", "Input",
  FontSize->12],
 "\nAgain, it's essentially the same as the more familiar form, but it gives \
this construct the ",
 StyleBox["HoldAll", "Input",
  FontSize->12],
 " attribute.  Here is the result in action:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Split", "[", "\[IndentingNewLine]", "\[IndentingNewLine]", 
  RowBox[{
   RowBox[{"Hold", "[", 
    RowBox[{
     RowBox[{"Print", "[", "1", "]"}], ",", " ", 
     RowBox[{"Print", "[", 
      RowBox[{"2", " ", "+", " ", "3"}], "]"}], ",", " ", 
     RowBox[{"0", " ", "+", " ", "1"}], ",", " ", 
     RowBox[{"1", " ", "+", " ", "2"}], ",", " ", 
     RowBox[{"2", " ", "+", " ", "3"}], ",", " ", 
     RowBox[{"0", "*", "1"}], ",", " ", 
     RowBox[{"1", "*", "2", "*", "3"}], ",", " ", 
     RowBox[{"4", "^", "4"}]}], "]"}], ",", "\[IndentingNewLine]", 
   "\[IndentingNewLine]", 
   RowBox[{"Function", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"e1", ",", " ", "e2"}], "}"}], ",", " ", 
     RowBox[{
      RowBox[{"Head", "[", 
       RowBox[{"Unevaluated", "[", "e1", "]"}], "]"}], " ", "===", " ", 
      RowBox[{"Head", "[", 
       RowBox[{"Unevaluated", "[", "e2", "]"}], "]"}]}], ",", " ", 
     "HoldAll"}], "]"}]}], "\[IndentingNewLine]", "\[IndentingNewLine]", 
  "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"Hold", "[", 
  RowBox[{
   RowBox[{"Hold", "[", 
    RowBox[{
     RowBox[{"Print", "[", "1", "]"}], ",", 
     RowBox[{"Print", "[", 
      RowBox[{"2", "+", "3"}], "]"}]}], "]"}], ",", 
   RowBox[{"Hold", "[", 
    RowBox[{
     RowBox[{"0", "+", "1"}], ",", 
     RowBox[{"1", "+", "2"}], ",", 
     RowBox[{"2", "+", "3"}]}], "]"}], ",", 
   RowBox[{"Hold", "[", 
    RowBox[{
     RowBox[{"0", " ", "1"}], ",", 
     RowBox[{"2", " ", "3"}]}], "]"}], ",", 
   RowBox[{"Hold", "[", 
    SuperscriptBox["4", "4"], "]"}]}], "]"}]], "Output"]
}, Open  ]],

Cell["\<\
And here is an example where you want to test unevaluated products to see if \
they contain spurious zeros:\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Map", "[", "\[IndentingNewLine]", 
  RowBox[{
   RowBox[{"Function", "[", 
    RowBox[{"e", ",", " ", 
     RowBox[{"MemberQ", "[", 
      RowBox[{
       RowBox[{"Unevaluated", "[", "e", "]"}], ",", " ", "0"}], "]"}], ",", 
     " ", "HoldFirst"}], "]"}], ",", "\[IndentingNewLine]", 
   RowBox[{"Unevaluated", "[", 
    RowBox[{"{", 
     RowBox[{
      RowBox[{"x", " ", "*", " ", "y"}], ",", " ", 
      RowBox[{"u", " ", "*", " ", "0", " ", "*", " ", "v"}], ",", " ", 
      RowBox[{"1", " ", "*", " ", "2", " ", "*", " ", "0"}]}], "}"}], "]"}]}],
   "\[IndentingNewLine]", "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"False", ",", "True", ",", "True"}], "}"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "If you want to delete the zeros so that the products don't evaluate to \
zero, you can make a holding ",
 StyleBox["DeleteCases", "Input",
  FontSize->12],
 ":"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Map", "[", "\[IndentingNewLine]", 
  RowBox[{
   RowBox[{"Function", "[", 
    RowBox[{"e", ",", " ", 
     RowBox[{"DeleteCases", "[", 
      RowBox[{
       RowBox[{"Unevaluated", "[", "e", "]"}], ",", " ", "0"}], "]"}], ",", 
     " ", "HoldFirst"}], "]"}], ",", "\[IndentingNewLine]", 
   RowBox[{"Unevaluated", "[", 
    RowBox[{"{", 
     RowBox[{
      RowBox[{"x", " ", "*", " ", "y"}], ",", " ", 
      RowBox[{"u", " ", "*", " ", "0", " ", "*", " ", "v"}], ",", " ", 
      RowBox[{"1", " ", "*", " ", "2", " ", "*", " ", "0"}]}], "}"}], "]"}]}],
   "\[IndentingNewLine]", "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"x", " ", "y"}], ",", 
   RowBox[{"u", " ", "v"}], ",", "2"}], "}"}]], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Replace is one of these easiest methods for transforming a structure, and \
it's sort of \"visual programming\", making it very clear to the reader what \
is happening.\
\>", "Subsubsection"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Replace", "[", 
  RowBox[{
   RowBox[{"Hold", "[", 
    RowBox[{
     RowBox[{"1", " ", "+", " ", "2"}], ",", " ", 
     RowBox[{"Print", "[", 
      RowBox[{"3", ",", " ", "4"}], "]"}], ",", " ", 
     RowBox[{"D", "[", 
      RowBox[{
       RowBox[{"x", "^", "2"}], ",", " ", "x"}], "]"}]}], "]"}], ",", 
   "\[IndentingNewLine]", 
   RowBox[{
    RowBox[{"h_", "[", "elems___", "]"}], " ", "\[RuleDelayed]", " ", 
    RowBox[{"{", 
     RowBox[{"h", ",", " ", "elems"}], "}"}]}], ",", "\[IndentingNewLine]", 
   RowBox[{"{", "1", "}"}]}], "\[IndentingNewLine]", "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"Hold", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"Plus", ",", "1", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"Print", ",", "3", ",", "4"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"D", ",", 
     SuperscriptBox["x", "2"], ",", "x"}], "}"}]}], "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"patts", " ", "=", " ", 
  RowBox[{"Replace", "[", 
   RowBox[{
    RowBox[{"Unevaluated", "[", 
     RowBox[{"{", 
      RowBox[{
       RowBox[{"1", " ", "+", " ", "2"}], ",", " ", 
       RowBox[{"Print", "[", 
        RowBox[{"3", ",", " ", "4"}], "]"}], ",", " ", 
       RowBox[{"D", "[", 
        RowBox[{
         RowBox[{"x", "^", "2"}], ",", " ", "x"}], "]"}]}], "}"}], "]"}], ",",
     "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"h_", "[", "___", "]"}], " ", "\[RuleDelayed]", " ", 
     RowBox[{"Blank", "[", "h", "]"}]}], ",", "\[IndentingNewLine]", 
    RowBox[{"{", "1", "}"}]}], "\[IndentingNewLine]", "]"}]}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"_Plus", ",", "_Print", ",", "_D"}], "}"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "Suppose I want to take the factored form of an integer and typeset it \
nicely as a product of prime powers.  Obviously, I can't let things like  ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    SuperscriptBox["3", "3"], " ", 
    SuperscriptBox["5", "5"]}], TraditionalForm]]],
 " evaluate before I feed it to the typesetting function, since then it would \
become some integer and I'd lose the decomposed form."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"n", " ", "=", " ", "79301169838123235887500"}], ";"}]], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"factored", " ", "=", " ", 
  RowBox[{"FactorInteger", "[", "n", "]"}]}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"2", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"3", ",", "3"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"5", ",", "5"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"7", ",", "7"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"11", ",", "11"}], "}"}]}], "}"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "We're going to convert the inner lists to ",
 StyleBox["Power", "Input",
  FontSize->12],
 " and the outer list to ",
 StyleBox["Times", "Input",
  FontSize->12],
 ", so we need to have the ",
 StyleBox["Hold", "Input",
  FontSize->12],
 " wrapper in place before we start:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"held", " ", "=", " ", 
  RowBox[{"Hold", "[", " ", 
   RowBox[{"Evaluate", "[", "factored", "]"}], " ", "]"}]}]], "Input"],

Cell[BoxData[
 RowBox[{"Hold", "[", 
  RowBox[{"{", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"2", ",", "2"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"3", ",", "3"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"5", ",", "5"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"7", ",", "7"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"11", ",", "11"}], "}"}]}], "}"}], "]"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "First, I convert each ordered pair {p, a} to the prime power that it \
represents:  ",
 Cell[BoxData[
  FormBox[
   SuperscriptBox["p", "a"], TraditionalForm]]],
 "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Replace", "[", 
  RowBox[{"held", ",", "\[IndentingNewLine]", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"p_", ",", " ", "a_"}], "}"}], " ", "\[RuleDelayed]", " ", 
    RowBox[{"p", "^", "a"}]}], ",", "\[IndentingNewLine]", 
   RowBox[{"{", "2", "}"}]}], "\[IndentingNewLine]", "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"Hold", "[", 
  RowBox[{"{", 
   RowBox[{
    SuperscriptBox["2", "2"], ",", 
    SuperscriptBox["3", "3"], ",", 
    SuperscriptBox["5", "5"], ",", 
    SuperscriptBox["7", "7"], ",", 
    SuperscriptBox["11", "11"]}], "}"}], "]"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "Now I change the list to a product and wrap a call to ",
 StyleBox["MakeBoxes", "Input",
  FontSize->12],
 " around it:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Replace", "[", 
  RowBox[{"%", ",", "\[IndentingNewLine]", 
   RowBox[{
    RowBox[{"Hold", "[", 
     RowBox[{"{", "elems___", "}"}], "]"}], " ", "\[RuleDelayed]", " ", 
    RowBox[{"MakeBoxes", "[", 
     RowBox[{
      RowBox[{"Times", "[", "elems", "]"}], ",", " ", "TraditionalForm"}], 
     "]"}]}]}], "\[IndentingNewLine]", "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"RowBox", "[", 
  RowBox[{"{", 
   RowBox[{
    RowBox[{"SuperscriptBox", "[", 
     RowBox[{"\<\"2\"\>", ",", "\<\"2\"\>"}], "]"}], ",", "\<\" \"\>", ",", 
    RowBox[{"SuperscriptBox", "[", 
     RowBox[{"\<\"3\"\>", ",", "\<\"3\"\>"}], "]"}], ",", "\<\" \"\>", ",", 
    RowBox[{"SuperscriptBox", "[", 
     RowBox[{"\<\"5\"\>", ",", "\<\"5\"\>"}], "]"}], ",", "\<\" \"\>", ",", 
    RowBox[{"SuperscriptBox", "[", 
     RowBox[{"\<\"7\"\>", ",", "\<\"7\"\>"}], "]"}], ",", "\<\" \"\>", ",", 
    RowBox[{"SuperscriptBox", "[", 
     RowBox[{"\<\"11\"\>", ",", "\<\"11\"\>"}], "]"}]}], "}"}], 
  "]"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "Once you've constructed a typeset box expression, you can use ",
 StyleBox["DisplayForm", "Input",
  FontSize->12],
 " to see how it would display if you sent it to a front end output cell:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"DisplayForm", "[", "%", "]"}]], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{
   SuperscriptBox["2", "2"], " ", 
   SuperscriptBox["3", "3"], " ", 
   SuperscriptBox["5", "5"], " ", 
   SuperscriptBox["7", "7"], " ", 
   SuperscriptBox["11", "11"]}],
  DisplayForm]], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Function and With can stuff values into any expression, including held ones.\
\>", "Subsubsection"],

Cell[TextData[{
 "Both ",
 StyleBox["With", "Input",
  FontSize->12],
 " and ",
 StyleBox["Function", "Input",
  FontSize->12],
 " do direct substitution into the body, and for the most part they're \
equivalent ways of \"filling in a template\", the body being the template:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"With", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{
     RowBox[{"p", " ", "=", " ", "2"}], ",", " ", 
     RowBox[{"a", " ", "=", " ", "2"}], ",", " ", 
     RowBox[{"q", " ", "=", " ", "5"}], ",", " ", 
     RowBox[{"b", " ", "=", " ", "5"}]}], "}"}], ",", "\[IndentingNewLine]", 
   RowBox[{
    RowBox[{"MakeBoxes", "[", 
     RowBox[{
      RowBox[{"p", "^", "a"}], " ", "*", " ", 
      RowBox[{"q", "^", "b"}]}], "]"}], " ", "//", "DisplayForm"}]}], 
  "\[IndentingNewLine]", "]"}]], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{
   SuperscriptBox["2", "2"], " ", 
   SuperscriptBox["5", "5"]}],
  DisplayForm]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"Function", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"p", ",", " ", "a", ",", " ", "q", ",", " ", "b"}], "}"}], ",", 
    " ", 
    RowBox[{
     RowBox[{"MakeBoxes", "[", 
      RowBox[{
       RowBox[{"p", "^", "a"}], " ", "*", " ", 
       RowBox[{"q", "^", "b"}]}], "]"}], " ", "//", "DisplayForm"}]}], "]"}], 
  " ", "[", 
  RowBox[{"2", ",", " ", "2", ",", " ", "5", ",", " ", "5"}], "]"}]], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{
   SuperscriptBox["2", "2"], " ", 
   SuperscriptBox["5", "5"]}],
  DisplayForm]], "Output"]
}, Open  ]],

Cell[TextData[{
 "Why would you use ",
 StyleBox["With", "Input",
  FontSize->12],
 " or ",
 StyleBox["Function", "Input",
  FontSize->12],
 " to substitute in 2 and 5 when you could just type this?\n\n",
 StyleBox["  MakeBoxes[2^2 5^5]", "Input",
  FontSize->12],
 "\n\nAnswer:  p, a, q, and b are probably variables in a program you're \
writing, and you need to put their ",
 StyleBox["values",
  FontSlant->"Italic"],
 ", not their literal names, into the ",
 StyleBox["MakeBoxes", "Input",
  FontSize->12],
 " command.  You can't use ",
 StyleBox["Evaluate", "Input",
  FontSize->12],
 ", like this\n\n",
 StyleBox["  MakeBoxes[ Evaluate[p^a q^b] ]    (* does NOT work *)", "Input",
  FontSize->12],
 "\n\nbecause then the argument would collapse to an integer (besides, ",
 StyleBox["MakeBoxes", "Input",
  FontSize->12],
 " is ",
 StyleBox["HoldAllComplete", "Input",
  FontSize->12],
 " and doesn't respect ",
 StyleBox["Evaluate", "Input",
  FontSize->12],
 ").  You can't use ",
 StyleBox["Evaluate", "Input",
  FontSize->12],
 " in deep subexpressions of a held argument, you can use it only on the \
whole argument\n\n",
 StyleBox["  MakeBoxes[ Evaluate[p]^Evaluate[a] * Evaluate[q]^Evaluate[b] ]  \
(* No *)", "Input",
  FontSize->12],
 "\n\nIn this situation, ",
 StyleBox["With", "Input",
  FontSize->12],
 " and ",
 StyleBox["Function", "Input",
  FontSize->12],
 " can jam those values in for you.  Since the initial values are probably \
those of variables in your program, here's an example of how you'd really use \
them in a program."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{
    RowBox[{"{", 
     RowBox[{"a", ",", " ", "b", ",", " ", "c"}], "}"}], " ", "=", " ", 
    RowBox[{"{", 
     RowBox[{"1", ",", " ", "2", ",", " ", "3"}], "}"}]}], ";"}], 
  "\[IndentingNewLine]"}], "\n", 
 RowBox[{"With", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{
     RowBox[{"a", " ", "=", " ", "a"}], ",", " ", 
     RowBox[{"b", " ", "=", " ", "b"}], ",", " ", 
     RowBox[{"c", " ", "=", " ", "c"}]}], "}"}], ",", "\[IndentingNewLine]", 
   RowBox[{
    RowBox[{"MakeBoxes", "[", 
     RowBox[{
      RowBox[{"a", "^", "b"}], " ", "+", " ", 
      RowBox[{"c", "*", "a"}]}], "]"}], " ", "//", "DisplayForm"}]}], 
  "\[IndentingNewLine]", "]"}]}], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{
   SuperscriptBox["1", "2"], "+", 
   RowBox[{"3", " ", "1"}]}],
  DisplayForm]], "Output"]
}, Open  ]],

Cell[TextData[{
 "Later, I'll show techniques for tagging arbitrary subexpressions for \
evaluation, in a function called ",
 StyleBox["EvaluateAt", "Input",
  FontSize->12],
 " (based on another new one called ",
 StyleBox["ReplaceAt", "Input",
  FontSize->12],
 ")."
}], "Text"],

Cell["\<\

\
\>", "Text"],

Cell[TextData[{
 "Something that you may not know is that ",
 StyleBox["With", "Input",
  FontSize->12],
 " initializations can use ':=' as well as '=', to cause the initialization \
not to evaluate.  For instance:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{
    RowBox[{"{", 
     RowBox[{"a", ",", " ", "b", ",", " ", "c"}], "}"}], " ", "=", " ", 
    RowBox[{"{", 
     RowBox[{"1", ",", " ", "2", ",", " ", "3"}], "}"}]}], ";"}], 
  "\[IndentingNewLine]"}], "\n", 
 RowBox[{"With", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"expr", " ", ":=", " ", 
     RowBox[{"a", " ", "+", " ", "b", " ", "+", " ", "c"}]}], "}"}], ",", 
   "\[IndentingNewLine]", 
   RowBox[{"{", 
    RowBox[{"expr", ",", " ", 
     RowBox[{"Length", "[", 
      RowBox[{"Unevaluated", "[", "expr", "]"}], "]"}]}], "}"}]}], 
  "\[IndentingNewLine]", "]"}]}], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"6", ",", "3"}], "}"}]], "Output"]
}, Open  ]],

Cell["\<\
It's true that if the local value of 'expr' is an unevaluated expression, \
then you could simply use that literal expression everywhere you need it \
instead of a local 'expr', but maybe it makes the code clearer if many places \
in a region of code all use exactly the same expression.  Some of them may \
need it unevaluated, some may be happy to let it evaluate.\
\>", "Text"],

Cell["\<\

\
\>", "Text"],

Cell[TextData[{
 StyleBox["Advanced note\n",
  FontVariations->{"Underline"->True}],
 "The initializations in scoping constructs ",
 StyleBox["Module", "Input",
  FontSize->12],
 " and ",
 StyleBox["With", "Input",
  FontSize->12],
 " are not ",
 StyleBox["evaluated as calls",
  FontSlant->"Italic"],
 " to the ",
 StyleBox["Set", "Input",
  FontSize->12],
 " or ",
 StyleBox["SetDelayed", "Input",
  FontSize->12],
 " functions.  You can see this by either attaching a top-level trap to ",
 StyleBox["Set", "Input",
  FontSize->12],
 ", or by using ",
 StyleBox["Block", "Input",
  FontSize->12],
 " to temporarily disable ",
 StyleBox["Set", "Input",
  FontSize->12],
 ".  Either way, you'll see that ",
 StyleBox["Module", "Input",
  FontSize->12],
 " and ",
 StyleBox["With", "Input",
  FontSize->12],
 " accomplish initializations in a magical internal way, not by calling the \
top-level ",
 StyleBox["Set", "Input",
  FontSize->12],
 " function.\n\nStrangely, if you ask ",
 StyleBox["Trace", "Input",
  FontSize->12],
 " to report ",
 StyleBox["Set", "Input",
  FontSize->12],
 " evaluation chains, it ",
 "will report",
 " local variable initializations!  My best guess is that since we specify \
initializations with something that is ",
 StyleBox["syntactically",
  FontSlant->"Italic"],
 " ",
 StyleBox["Set[var, value]", "Input",
  FontSize->12],
 ", the evaluation chain for initialization is considered to begin with the \
expression ",
 StyleBox["Set[var, value]", "Input",
  FontSize->12],
 ", and this is good enough to convince ",
 StyleBox["Trace", "Input",
  FontSize->12],
 " that it is a call to ",
 StyleBox["Set", "Input",
  FontSize->12],
 ", even though technically some internal magic intervenes and performs \
assignments instead of letting ",
 StyleBox["Set", "Input",
  FontSize->12],
 " do it.\n\nI was tempted to consider this a bug, but one advantage - a \
significant one for kernel hackers - is that you can actually trap ",
 StyleBox["Set", "Input",
  FontSize->12],
 " with the familiar idiom for trapping internal functions, and not get \
yourself into infinite recursion trouble when you do ",
 StyleBox["Block[{$TrapSet = False}, ...]", "Input",
  FontSize->12],
 ".  But it is an odd inconsistency in the language that you use the ",
 StyleBox["syntax",
  FontSlant->"Italic"],
 " ",
 StyleBox["Set[var, value]", "Input",
  FontSize->12],
 " to specify an action that will not be carried out by ",
 StyleBox["Set", "Input",
  FontSize->12],
 ", but by inaccessible internal magic."
}], "Text",
 CellDingbat->"\[EmptySmallCircle]"],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"Unprotect", "[", "Set", "]"}], ";"}], 
  "\[IndentingNewLine]"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"$TrapSet", " ", "=", " ", "True"}], ";"}], 
  "\[IndentingNewLine]"}], "\n", 
 RowBox[{
  RowBox[{"assign_Set", " ", "/;", " ", "$TrapSet"}], " ", ":=", 
  "\[IndentingNewLine]", 
  RowBox[{"Block", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"$TrapSet", " ", "=", " ", "False"}], "}"}], ",", 
    "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"Print", " ", "@", " ", 
      RowBox[{"Unevaluated", "[", "assign", "]"}]}], ";", 
     "\[IndentingNewLine]", "assign"}]}], "\[IndentingNewLine]", 
   "]"}]}]}], "Input"],

Cell[BoxData[
 RowBox[{"$Line", "=", "85"}]], "Print"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Module", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"x", " ", "=", " ", "3"}], "}"}], ",", " ", 
   RowBox[{"x", "^", "2"}]}], "]"}]], "Input"],

Cell[BoxData["9"], "Output"],

Cell[BoxData[
 RowBox[{"$Line", "=", "86"}]], "Print"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Block", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"x", " ", "=", " ", "3"}], "}"}], ",", " ", "x"}], "]"}]], "Input"],

Cell[BoxData["3"], "Output"],

Cell[BoxData[
 RowBox[{"$Line", "=", "87"}]], "Print"]
}, Open  ]],

Cell[BoxData[
 RowBox[{
  RowBox[{"assign_Set", " ", "/;", " ", "$TrapSet"}], " ", "=."}]], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Block", "[", 
  RowBox[{
   RowBox[{"{", "Set", "}"}], ",", "\[IndentingNewLine]", 
   RowBox[{"Module", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"x", " ", "=", " ", "3"}], "}"}], ",", " ", 
     RowBox[{
      RowBox[{"u", " ", "=", " ", "1"}], ";", " ", 
      RowBox[{"x", "^", "2"}]}]}], "]"}]}], "\[IndentingNewLine]", 
  "]"}]], "Input"],

Cell[BoxData["9"], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"?", " ", "u"}]], "Input"],

Cell[BoxData["\<\"Global`u\"\>"], "Print"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Trace", "[", 
  RowBox[{
   RowBox[{"Module", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"x", " ", "=", " ", "3"}], "}"}], ",", 
     RowBox[{"x", "^", "2"}]}], "]"}], ",", "Set", ",", 
   RowBox[{"TraceInternal", "\[Rule]", "True"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"{", 
   RowBox[{
    TagBox[
     RowBox[{"x$33", "=", "3"}],
     HoldForm], ",", 
    TagBox["3",
     HoldForm]}], "}"}], "}"}]], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Build up the arguments inside of Hold, then apply the function at the end\
\>", "Subsubsection"],

Cell[TextData[{
 "Sometimes it takes several steps to go from the original input to the final \
arguments you want to pass to a function.  In this case, it's usually good to \
wrap the inputs in Hold at the beginning and work with them, then replace \
Hold with f at the end.  We saw this in the last section using Replace to \
make the result look more and more like what we want.  The final step is \
often one of these:\n\n",
 StyleBox["   f @@ Hold[e1, ..., en]\n   \n   ReleaseHold @ Hold[f[e1, ..., \
en]]", "Input",
  FontSize->12],
 "\n\nHere's an example where my function is given an integrand and the \
ranges of the variables.  A typical call will look like this:\n\n",
 StyleBox["  f[x + y + z, {x, -1, 1}, {y, -1, 1}, {z, -1, 1}]", "Input",
  FontSize->12],
 "\n\nBut I would like global values of the variables, if they should exist, \
not to interfere with computing this integral.  To prevent outside \
interference, you of course wrap the integral in Block with {x, y, z} local.  \
So I want to take the above and construct this expression:\n\n",
 StyleBox["  Block[{x, y, z},\n    Integrate[x + y + z, {x, -1, 1}, {y, -1, \
1}, {z, -1, 1}]\n  ]", "Input",
  FontSize->12],
 StyleBox["\n",
  FontSize->12],
 "\nThat looks awfully easy since I'm just wrapping a Block around the \
desired Integrate expression.\n\nBut remember that I don't know in advance \
what the variables are or how many there will be!  Here is the template for \
my function:\n\n",
 StyleBox["Attributes[f] = HoldAll;\n\nf[iterand_, iterSpecs:{_Symbol, \
__}...] := ...\n", "Input",
  FontSize->12],
 StyleBox["\n",
  FontSize->12],
 "Let's look at the steps in constructing the Block from the input, and not \
evaluating it until it's all assembled.  We'll give {x, y, z} values at the \
beginning, so that if we make a mistake and expose anything to the evaluator \
too early, we'll know."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"{", 
    RowBox[{"x", ",", " ", "y", ",", " ", "z"}], "}"}], " ", "=", " ", 
   RowBox[{"{", 
    RowBox[{"77", ",", " ", "88", ",", " ", "99"}], "}"}]}], ";"}]], "Input"],

Cell["\<\
First wrap the iterSpecs in Hold so we can safely extract the variable names.\
\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"heldIterSpecs", " ", "=", " ", 
  RowBox[{"Hold", "[", 
   StyleBox[
    RowBox[{
     RowBox[{"{", 
      RowBox[{"x", ",", " ", 
       RowBox[{"-", "1"}], ",", " ", "1"}], "}"}], ",", " ", 
     RowBox[{"{", 
      RowBox[{"y", ",", " ", 
       RowBox[{"-", "1"}], ",", " ", "1"}], "}"}], ",", " ", 
     RowBox[{"{", 
      RowBox[{"z", ",", " ", 
       RowBox[{"-", "1"}], ",", " ", "1"}], "}"}]}], "Input",
    FontSize->12], 
   StyleBox["]", "Input",
    FontSize->12]}]}]], "Input"],

Cell[BoxData[
 RowBox[{"Hold", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"x", ",", 
     RowBox[{"-", "1"}], ",", "1"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"y", ",", 
     RowBox[{"-", "1"}], ",", "1"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"z", ",", 
     RowBox[{"-", "1"}], ",", "1"}], "}"}]}], "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"heldVars", " ", "=", " ", 
  RowBox[{"Replace", "[", 
   RowBox[{"heldIterSpecs", ",", " ", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"s_Symbol", ",", " ", "___"}], "}"}], " ", "\[RuleDelayed]", 
     " ", "s"}], ",", " ", 
    RowBox[{"{", "1", "}"}]}], "]"}]}]], "Input"],

Cell[BoxData[
 RowBox[{"Hold", "[", 
  RowBox[{"x", ",", "y", ",", "z"}], "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"heldVarList", " ", "=", " ", 
  RowBox[{"Replace", "[", 
   RowBox[{"heldVars", ",", " ", 
    RowBox[{
     RowBox[{"Hold", "[", "elems___", "]"}], " ", "\[RuleDelayed]", " ", 
     RowBox[{"Hold", "[", 
      RowBox[{"{", "elems", "}"}], "]"}]}]}], "]"}]}]], "Input"],

Cell[BoxData[
 RowBox[{"Hold", "[", 
  RowBox[{"{", 
   RowBox[{"x", ",", "y", ",", "z"}], "}"}], "]"}]], "Output"]
}, Open  ]],

Cell["\<\
This gives us argument 1 of Block, the local variable declaration.  Now we \
just need to append the body.  The body is simply Integrate[iterand, \
iterSpecs].  Those were the names of the pattern variables in f, so they'll \
get substituted directly in.  I write them out in my next input, since I'm in \
an interactive session, not inside my function body.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Append", "[", 
  RowBox[{"heldVarList", ",", " ", 
   RowBox[{"Unevaluated", "[", "\[IndentingNewLine]", 
    RowBox[{"Integrate", "[", 
     RowBox[{
      RowBox[{"x", " ", "+", " ", "y", " ", "+", " ", "z"}], ",", " ", 
      RowBox[{"{", 
       RowBox[{"x", ",", " ", 
        RowBox[{"-", "1"}], ",", " ", "1"}], "}"}], ",", " ", 
      RowBox[{"{", 
       RowBox[{"y", ",", " ", 
        RowBox[{"-", "1"}], ",", " ", "1"}], "}"}], ",", " ", 
      RowBox[{"{", 
       RowBox[{"z", ",", " ", 
        RowBox[{"-", "1"}], ",", " ", "1"}], "}"}]}], "]"}], 
    "\[IndentingNewLine]", "]"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"Hold", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"x", ",", "y", ",", "z"}], "}"}], ",", 
   RowBox[{
    SubsuperscriptBox["\[Integral]", 
     RowBox[{"-", "1"}], "1"], 
    RowBox[{
     SubsuperscriptBox["\[Integral]", 
      RowBox[{"-", "1"}], "1"], 
     RowBox[{
      SubsuperscriptBox["\[Integral]", 
       RowBox[{"-", "1"}], "1"], 
      RowBox[{
       RowBox[{"(", 
        RowBox[{"x", "+", "y", "+", "z"}], ")"}], 
       RowBox[{"\[DifferentialD]", "z"}], 
       RowBox[{"\[DifferentialD]", "y"}], 
       RowBox[{"\[DifferentialD]", "x"}]}]}]}]}]}], "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Block", " ", "@@", " ", "%"}]], "Input"],

Cell[BoxData["0"], "Output"]
}, Open  ]],

Cell["\<\
Great, it works!  And we can see that it would have failed without our \
careful construction of Block:\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Integrate", "[", 
  RowBox[{
   RowBox[{"x", " ", "+", " ", "y", " ", "+", " ", "z"}], ",", " ", 
   RowBox[{"{", 
    RowBox[{"x", ",", " ", 
     RowBox[{"-", "1"}], ",", " ", "1"}], "}"}], ",", " ", 
   RowBox[{"{", 
    RowBox[{"y", ",", " ", 
     RowBox[{"-", "1"}], ",", " ", "1"}], "}"}], ",", " ", 
   RowBox[{"{", 
    RowBox[{"z", ",", " ", 
     RowBox[{"-", "1"}], ",", " ", "1"}], "}"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Integrate", "::", "\<\"ilim\"\>"}], 
  RowBox[{
  ":", " "}], "\<\"Invalid integration variable or limit(s) in \\!\\({77, \\(\
\\(-1\\)\\), 1}\\) .\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  SubsuperscriptBox["\[Integral]", 
   RowBox[{"-", "1"}], "1"], 
  RowBox[{
   SubsuperscriptBox["\[Integral]", 
    RowBox[{"-", "1"}], "1"], 
   RowBox[{
    SubsuperscriptBox["\[Integral]", 
     RowBox[{"-", "1"}], "1"], 
    RowBox[{"264", 
     RowBox[{"\[DifferentialD]", "99"}], 
     RowBox[{"\[DifferentialD]", "88"}], 
     RowBox[{"\[DifferentialD]", "77"}]}]}]}]}]], "Output"]
}, Open  ]],

Cell["Here it is all put together into a function:", "Text"],

Cell[BoxData[{
 StyleBox[
  RowBox[{
   RowBox[{
    RowBox[{
     RowBox[{"Attributes", "[", "f", "]"}], " ", "=", " ", "HoldAll"}], ";"}],
    "\n"}], "Input",
  FontSize->12], "\n", 
 RowBox[{
  StyleBox[
   RowBox[{"f", "[", 
    RowBox[{"iterand_", ",", " ", 
     RowBox[{"iterSpecs", ":", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"_Symbol", ",", " ", "__"}], "}"}], "..."}]}]}], "]"}], 
   "Input",
   FontSize->12], 
  StyleBox[" ", "Input",
   FontSize->12], 
  StyleBox[":=", "Input",
   FontSize->12], "\[IndentingNewLine]", "\[IndentingNewLine]", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"heldIterSpecs", ",", " ", "heldVars", ",", " ", "heldVarList"}],
      "}"}], ",", "\[IndentingNewLine]", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"heldIterSpecs", " ", "=", " ", 
      RowBox[{"Hold", "[", "iterSpecs", "]"}]}], ";", "\[IndentingNewLine]", 
     "\[IndentingNewLine]", 
     RowBox[{"heldVars", " ", "=", " ", 
      RowBox[{"Replace", "[", 
       RowBox[{"heldIterSpecs", ",", " ", 
        RowBox[{
         RowBox[{"{", 
          RowBox[{"s_Symbol", ",", " ", "___"}], "}"}], " ", "\[RuleDelayed]",
          " ", "s"}], ",", " ", 
        RowBox[{"{", "1", "}"}]}], "]"}]}], ";", "\[IndentingNewLine]", 
     "\[IndentingNewLine]", 
     RowBox[{"heldVarList", " ", "=", " ", 
      RowBox[{"Replace", "[", 
       RowBox[{"heldVars", ",", " ", 
        RowBox[{
         RowBox[{"Hold", "[", "elems___", "]"}], " ", "\[RuleDelayed]", " ", 
         RowBox[{"Hold", "[", 
          RowBox[{"{", "elems", "}"}], "]"}]}]}], "]"}]}], ";", 
     "\[IndentingNewLine]", "\[IndentingNewLine]", 
     RowBox[{"Block", " ", "@@", " ", 
      RowBox[{"Append", "[", 
       RowBox[{"heldVarList", ",", " ", 
        RowBox[{"Unevaluated", "[", "\[IndentingNewLine]", 
         RowBox[{"Integrate", "[", 
          RowBox[{"iterand", ",", " ", "iterSpecs"}], "]"}], 
         "\[IndentingNewLine]", "]"}]}], "]"}]}]}]}], "\[IndentingNewLine]", 
   "]"}]}]}], "Input"],

Cell["\<\
Here are some annoying assignments that will surely tell us if we evaluate \
anything:\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"{", 
   RowBox[{"x", ",", " ", "y", ",", " ", "z"}], "}"}], " ", ":=", " ", 
  RowBox[{"{", 
   RowBox[{
    RowBox[{"Print", "[", "1", "]"}], ",", " ", 
    RowBox[{"Print", "[", "2", "]"}], ",", " ", 
    RowBox[{"Print", "[", "3", "]"}]}], "}"}]}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"Null", ",", "Null", ",", "Null"}], "}"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  StyleBox["f", "Input",
   FontSize->12], 
  StyleBox["[", "Input",
   FontSize->12], 
  RowBox[{
   RowBox[{
    RowBox[{"x", "^", "2"}], " ", "+", " ", 
    RowBox[{"y", "^", "2"}], " ", "+", " ", 
    RowBox[{"y", "^", "2"}]}], 
   StyleBox[",", "Input",
    FontSize->12], 
   StyleBox[" ", "Input",
    FontSize->12], 
   StyleBox[
    RowBox[{"{", 
     RowBox[{"x", ",", " ", 
      RowBox[{"-", "1"}], ",", " ", "1"}], "}"}], "Input",
    FontSize->12], 
   StyleBox[",", "Input",
    FontSize->12], 
   StyleBox[" ", "Input",
    FontSize->12], 
   StyleBox[
    RowBox[{"{", 
     RowBox[{"y", ",", " ", 
      RowBox[{"-", "1"}], ",", " ", "1"}], "}"}], "Input",
    FontSize->12], 
   StyleBox[",", "Input",
    FontSize->12], 
   StyleBox[" ", "Input",
    FontSize->12], 
   StyleBox[
    RowBox[{"{", 
     RowBox[{"z", ",", " ", 
      RowBox[{"-", "1"}], ",", " ", "1"}], "}"}], "Input",
    FontSize->12]}], 
  StyleBox["]", "Input",
   FontSize->12]}]], "Input"],

Cell[BoxData["8"], "Output"]
}, Open  ]],

Cell[BoxData[
 RowBox[{"ClearAll", "[", 
  RowBox[{"\"\<x\>\"", ",", " ", "\"\<y\>\"", ",", " ", "\"\<z\>\""}], 
  "]"}]], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Construct a held result from parts", "Subsubsection"],

Cell["\<\
Sometimes it's fine for the inputs to evaluate, but the expression you \
construct from them must not evaluate.  When it's okay to evaluate the parts \
but not the whole, plain old pure functions are often quick and easy:\
\>", "Text"],

Cell[TextData[{
 "An assignment, on standby, waiting for ",
 StyleBox["ReleaseHold", "Input",
  FontSize->12],
 ", or to be typeset and used as the limit of a ",
 StyleBox["Sum", "Input",
  FontSize->12],
 ", or whatever:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"Hold", "[", 
    RowBox[{"Set", "[", 
     RowBox[{"x", ",", " ", "#"}], "]"}], "]"}], "&"}], " ", "[", "77", 
  "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"Hold", "[", 
  RowBox[{"x", "=", "77"}], "]"}]], "Output"]
}, Open  ]],

Cell["A sum of numbers:", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"Hold", "[", 
    RowBox[{"Plus", "[", "##", "]"}], "]"}], "&"}], " ", "@@", " ", 
  RowBox[{"{", 
   RowBox[{"6", ",", " ", "7.5", ",", " ", 
    RowBox[{"8", " ", "-", " ", 
     RowBox[{"3", " ", "I"}]}], ",", " ", 
    RowBox[{"4", "/", "5"}]}], "}"}]}]], "Input"],

Cell[BoxData[
 RowBox[{"Hold", "[", 
  RowBox[{"6", "+", 
   RowBox[{"7.5`", "\[InvisibleSpace]"}], "+", 
   RowBox[{"(", 
    RowBox[{"8", "-", 
     RowBox[{"3", " ", "\[ImaginaryI]"}]}], ")"}], "+", 
   FractionBox["4", "5"]}], "]"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 StyleBox["Composition", "Input",
  FontSize->12],
 " is another form of anonymous function, too, but without #n and ##n \
variables:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"Composition", "[", 
   RowBox[{"HoldForm", ",", " ", "Plus"}], "]"}], " ", "@@", " ", 
  RowBox[{"{", 
   RowBox[{"6", ",", " ", "7.5", ",", " ", 
    RowBox[{"8", " ", "-", " ", 
     RowBox[{"3", " ", "I"}]}], ",", " ", 
    RowBox[{"4", "/", "5"}]}], "}"}]}]], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{"6", "+", 
   RowBox[{"7.5`", "\[InvisibleSpace]"}], "+", 
   RowBox[{"(", 
    RowBox[{"8", "-", 
     RowBox[{"3", " ", "\[ImaginaryI]"}]}], ")"}], "+", 
   FractionBox["4", "5"]}],
  HoldForm]], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Wrap everything in a holding wrapper, do your manipulations, then finish with \
ReleaseHold.\
\>", "Subsubsection"],

Cell["\<\
Here I'll introduce HoldForm, which is cute because it holds just as Hold \
does, but it doesn't display itself.  Thus, you can see the essentials, \
instead of having the display crowded with Hold.  Of course, since you can't \
see HoldForm, you have to remember where you put it, so it can be deceptive.  \
You can use InputForm to reveal the HoldForm's, reminding yourself where they \
are.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"atomsHeld", " ", "=", " ", 
  RowBox[{"Map", "[", 
   RowBox[{"HoldForm", ",", " ", 
    RowBox[{"Unevaluated", "[", 
     RowBox[{
      RowBox[{"2", "^", "1"}], " ", "*", " ", 
      RowBox[{"3", "^", "2"}], " ", "*", " ", 
      RowBox[{"5", "^", "3"}]}], "]"}], ",", " ", 
    RowBox[{"{", 
     RowBox[{"-", "1"}], "}"}], ",", " ", 
    RowBox[{"Heads", "\[Rule]", "True"}]}], "]"}]}]], "Input"],

Cell[BoxData[
 RowBox[{
  TagBox["Times",
   HoldForm], "[", 
  RowBox[{
   RowBox[{
    TagBox["Power",
     HoldForm], "[", 
    RowBox[{
     TagBox["2",
      HoldForm], ",", 
     TagBox["1",
      HoldForm]}], "]"}], ",", 
   RowBox[{
    TagBox["Power",
     HoldForm], "[", 
    RowBox[{
     TagBox["3",
      HoldForm], ",", 
     TagBox["2",
      HoldForm]}], "]"}], ",", 
   RowBox[{
    TagBox["Power",
     HoldForm], "[", 
    RowBox[{
     TagBox["5",
      HoldForm], ",", 
     TagBox["3",
      HoldForm]}], "]"}]}], "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Thread", "[", 
  RowBox[{"atomsHeld", ",", " ", 
   RowBox[{"HoldForm", "[", "Power", "]"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{
  TagBox["Power",
   HoldForm], "[", 
  RowBox[{
   RowBox[{
    TagBox["Times",
     HoldForm], "[", 
    RowBox[{
     TagBox["2",
      HoldForm], ",", 
     TagBox["3",
      HoldForm], ",", 
     TagBox["5",
      HoldForm]}], "]"}], ",", 
   RowBox[{
    TagBox["Times",
     HoldForm], "[", 
    RowBox[{
     TagBox["1",
      HoldForm], ",", 
     TagBox["2",
      HoldForm], ",", 
     TagBox["3",
      HoldForm]}], "]"}]}], "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"%", " ", "/.", " ", 
  RowBox[{
   RowBox[{"HoldForm", "[", "Power", "]"}], " ", "\[Rule]", " ", 
   RowBox[{"HoldForm", "[", "Plus", "]"}]}]}]], "Input"],

Cell[BoxData[
 RowBox[{
  TagBox["Plus",
   HoldForm], "[", 
  RowBox[{
   RowBox[{
    TagBox["Times",
     HoldForm], "[", 
    RowBox[{
     TagBox["2",
      HoldForm], ",", 
     TagBox["3",
      HoldForm], ",", 
     TagBox["5",
      HoldForm]}], "]"}], ",", 
   RowBox[{
    TagBox["Times",
     HoldForm], "[", 
    RowBox[{
     TagBox["1",
      HoldForm], ",", 
     TagBox["2",
      HoldForm], ",", 
     TagBox["3",
      HoldForm]}], "]"}]}], "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"ReleaseHold", "[", "%", "]"}]], "Input"],

Cell[BoxData["36"], "Output"]
}, Open  ]],

Cell["\<\
A nice alternative in a typesetting front end is to define yourself a wrapper \
that holds, just like Hold and HoldForm do, but which prints as a framebox or \
a colored background around its argument.  That way, it's not obtrusive, and \
yet it's visible so you don't forget it's there.  The typesetting rule is \
just two lines:\
\>", "Text"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"ClearAll", "[", "\"\<HoldFormFrame\>\"", "]"}], 
  "\[IndentingNewLine]"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{
    RowBox[{"Attributes", "[", "HoldFormFrame", "]"}], " ", "=", " ", 
    "HoldAll"}], ";"}], "\[IndentingNewLine]"}], "\n", 
 RowBox[{
  RowBox[{"HoldFormFrame", " ", "/:", " ", 
   RowBox[{"MakeBoxes", "[", 
    RowBox[{
     RowBox[{"HoldFormFrame", "[", "expr_", "]"}], ",", " ", "fmt_"}], "]"}], 
   " ", ":=", "\[IndentingNewLine]", 
   RowBox[{"TagBox", "[", 
    RowBox[{
     RowBox[{"FrameBox", " ", "@", " ", 
      RowBox[{"MakeBoxes", "[", 
       RowBox[{"expr", ",", " ", "fmt"}], "]"}]}], ",", " ", 
     "HoldFormFrame"}], "]"}]}], "\[IndentingNewLine]"}], "\n", 
 RowBox[{"HoldFormFrame", " ", "/:", " ", 
  RowBox[{"MakeBoxes", "[", 
   RowBox[{
    RowBox[{"HoldFormFrame", "[", "expr_", "]"}], ",", " ", "fmt_"}], "]"}], 
  " ", ":=", "\[IndentingNewLine]", 
  RowBox[{"TagBox", "[", 
   RowBox[{
    RowBox[{"FrameBox", " ", "@", " ", 
     RowBox[{"MakeBoxes", "[", 
      RowBox[{"expr", ",", " ", "fmt"}], "]"}]}], ",", " ", "HoldFormFrame"}],
    "]"}]}]}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"atomsHeld", " ", "=", " ", 
  RowBox[{"Map", "[", 
   RowBox[{"HoldFormFrame", ",", " ", 
    RowBox[{"Unevaluated", "[", 
     RowBox[{
      RowBox[{"2", "^", "1"}], " ", "*", " ", 
      RowBox[{"3", "^", "2"}], " ", "*", " ", 
      RowBox[{"5", "^", "3"}]}], "]"}], ",", " ", 
    RowBox[{"{", 
     RowBox[{"-", "1"}], "}"}], ",", " ", 
    RowBox[{"Heads", "\[Rule]", "True"}]}], "]"}]}]], "Input"],

Cell[BoxData[
 RowBox[{
  TagBox[
   FrameBox["Times"],
   HoldFormFrame], "[", 
  RowBox[{
   RowBox[{
    TagBox[
     FrameBox["Power"],
     HoldFormFrame], "[", 
    RowBox[{
     TagBox[
      FrameBox["2"],
      HoldFormFrame], ",", 
     TagBox[
      FrameBox["1"],
      HoldFormFrame]}], "]"}], ",", 
   RowBox[{
    TagBox[
     FrameBox["Power"],
     HoldFormFrame], "[", 
    RowBox[{
     TagBox[
      FrameBox["3"],
      HoldFormFrame], ",", 
     TagBox[
      FrameBox["2"],
      HoldFormFrame]}], "]"}], ",", 
   RowBox[{
    TagBox[
     FrameBox["Power"],
     HoldFormFrame], "[", 
    RowBox[{
     TagBox[
      FrameBox["5"],
      HoldFormFrame], ",", 
     TagBox[
      FrameBox["3"],
      HoldFormFrame]}], "]"}]}], "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Thread", "[", 
  RowBox[{"atomsHeld", ",", " ", 
   RowBox[{"HoldFormFrame", "[", "Power", "]"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{
  TagBox[
   FrameBox["Power"],
   HoldFormFrame], "[", 
  RowBox[{
   RowBox[{
    TagBox[
     FrameBox["Times"],
     HoldFormFrame], "[", 
    RowBox[{
     TagBox[
      FrameBox["2"],
      HoldFormFrame], ",", 
     TagBox[
      FrameBox["3"],
      HoldFormFrame], ",", 
     TagBox[
      FrameBox["5"],
      HoldFormFrame]}], "]"}], ",", 
   RowBox[{
    TagBox[
     FrameBox["Times"],
     HoldFormFrame], "[", 
    RowBox[{
     TagBox[
      FrameBox["1"],
      HoldFormFrame], ",", 
     TagBox[
      FrameBox["2"],
      HoldFormFrame], ",", 
     TagBox[
      FrameBox["3"],
      HoldFormFrame]}], "]"}]}], "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"%", " ", "/.", " ", 
  RowBox[{
   RowBox[{"HoldFormFrame", "[", "Power", "]"}], " ", "\[Rule]", " ", 
   RowBox[{"HoldFormFrame", "[", "Plus", "]"}]}]}]], "Input"],

Cell[BoxData[
 RowBox[{
  TagBox[
   FrameBox["Plus"],
   HoldFormFrame], "[", 
  RowBox[{
   RowBox[{
    TagBox[
     FrameBox["Times"],
     HoldFormFrame], "[", 
    RowBox[{
     TagBox[
      FrameBox["2"],
      HoldFormFrame], ",", 
     TagBox[
      FrameBox["3"],
      HoldFormFrame], ",", 
     TagBox[
      FrameBox["5"],
      HoldFormFrame]}], "]"}], ",", 
   RowBox[{
    TagBox[
     FrameBox["Times"],
     HoldFormFrame], "[", 
    RowBox[{
     TagBox[
      FrameBox["1"],
      HoldFormFrame], ",", 
     TagBox[
      FrameBox["2"],
      HoldFormFrame], ",", 
     TagBox[
      FrameBox["3"],
      HoldFormFrame]}], "]"}]}], "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"DeleteCases", "[", 
  RowBox[{"%", ",", " ", "HoldFormFrame", ",", " ", 
   RowBox[{"{", 
    RowBox[{"-", "1"}], "}"}], ",", " ", 
   RowBox[{"Heads", "\[Rule]", "True"}]}], "]"}]], "Input"],

Cell[BoxData["36"], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["Replace function names with temporary dummy symbols", "Subsubsection"],

Cell["\<\
In this technique, you replace \"active\" built-in functions with inert \
symbols of your own choosing.  This gives you a meaningless data structure \
that you can perform structural transformations on.  When you achieve the \
structure you want, you restore the original built-in functions.\
\>", "Text",
 CellDingbat->"\[EmptySmallCircle]"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"atomsHeld", " ", "=", " ", 
  RowBox[{
   RowBox[{"Unevaluated", "[", 
    RowBox[{
     RowBox[{"2", "^", "1"}], " ", "*", " ", 
     RowBox[{"3", "^", "2"}], " ", "*", " ", 
     RowBox[{"5", "^", "3"}]}], "]"}], " ", "/.", " ", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"Times", " ", "\[Rule]", " ", "MyTimes"}], ",", " ", 
     RowBox[{"Power", " ", "\[Rule]", " ", "MyPower"}]}], "}"}]}]}]], "Input"],

Cell[BoxData[
 RowBox[{"MyTimes", "[", 
  RowBox[{
   RowBox[{"MyPower", "[", 
    RowBox[{"2", ",", "1"}], "]"}], ",", 
   RowBox[{"MyPower", "[", 
    RowBox[{"3", ",", "2"}], "]"}], ",", 
   RowBox[{"MyPower", "[", 
    RowBox[{"5", ",", "3"}], "]"}]}], "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Thread", "[", 
  RowBox[{"atomsHeld", ",", " ", "MyPower"}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"MyPower", "[", 
  RowBox[{
   RowBox[{"MyTimes", "[", 
    RowBox[{"2", ",", "3", ",", "5"}], "]"}], ",", 
   RowBox[{"MyTimes", "[", 
    RowBox[{"1", ",", "2", ",", "3"}], "]"}]}], "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"%", " ", "/.", " ", 
  RowBox[{"MyPower", " ", "\[Rule]", " ", "MyPlus"}]}]], "Input"],

Cell[BoxData[
 RowBox[{"MyPlus", "[", 
  RowBox[{
   RowBox[{"MyTimes", "[", 
    RowBox[{"2", ",", "3", ",", "5"}], "]"}], ",", 
   RowBox[{"MyTimes", "[", 
    RowBox[{"1", ",", "2", ",", "3"}], "]"}]}], "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"%", " ", "/.", " ", 
  RowBox[{"{", 
   RowBox[{
    RowBox[{"MyPlus", " ", "\[Rule]", " ", "Plus"}], ",", " ", 
    RowBox[{"MyTimes", " ", "\[Rule]", " ", "Times"}]}], "}"}]}]], "Input"],

Cell[BoxData["36"], "Output"]
}, Open  ]],

Cell["\<\
This is very similar to the previous technique of turning every atom into \
Hold[a], in that you preserve the original structure but replace \"active\" \
parts with inactive things, and then undo it at the end.  This one replaces \
only the vital heads, though, not all the atoms.\
\>", "Text"],

Cell[TextData[{
 "A more subtle way to do the same thing is to make ",
 StyleBox["Module", "Input",
  FontSize->12],
 " do the work for you.  You have to undo the change at the end, e.g. ",
 StyleBox["Plus$n -> Plus", "Input",
  FontSize->12],
 ", but that's easily done with this type of rule:\n\n",
 StyleBox["  Plus -> Symbol[\"Plus\"]", "Input",
  FontSize->12],
 StyleBox["\n",
  FontSize->12]
}], "Text",
 CellDingbat->"\[EmptySmallCircle]"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"atomsHeld", " ", "=", "\[IndentingNewLine]", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"Times", ",", " ", "Power", ",", " ", "Plus", ",", " ", "expr"}],
      "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"expr", " ", "=", " ", 
      RowBox[{
       RowBox[{"2", "^", "1"}], " ", "*", " ", 
       RowBox[{"3", "^", "2"}], " ", "*", " ", 
       RowBox[{"5", "^", "3"}]}]}], ";", "\[IndentingNewLine]", 
     RowBox[{"thread", " ", "=", " ", 
      RowBox[{"Thread", "[", 
       RowBox[{"expr", ",", " ", "Power"}], "]"}]}], ";", 
     "\[IndentingNewLine]", 
     RowBox[{"plus", " ", "=", " ", 
      RowBox[{"thread", " ", "/.", " ", 
       RowBox[{"Power", " ", "\[Rule]", " ", "Plus"}]}]}], ";", 
     "\[IndentingNewLine]", 
     RowBox[{"plus", " ", "/.", " ", 
      RowBox[{"{", 
       RowBox[{
        RowBox[{"Plus", " ", "\[Rule]", " ", 
         RowBox[{"Symbol", "[", "\"\<Plus\>\"", "]"}]}], ",", " ", 
        RowBox[{"Times", " ", "\[Rule]", " ", 
         RowBox[{"Symbol", "[", "\"\<Times\>\"", "]"}]}]}], "}"}]}]}]}], 
   "\[IndentingNewLine]", "]"}]}]], "Input"],

Cell[BoxData["36"], "Output"]
}, Open  ]],

Cell["\<\

\
\>", "Text"],

Cell[TextData[{
 StyleBox["Advanced note",
  FontVariations->{"Underline"->True}],
 ":\nIf you like the ",
 StyleBox["Module", "Input",
  FontSize->12],
 " technique and are too lazy to write out the ",
 StyleBox["s -> Symbol[\"s\"]", "Input",
  FontSize->12],
 " rules, or if you're using generated code and must compute those rules \
rather than type them in, here is a way to automate the ",
 StyleBox["x$n -> x", "Input",
  FontSize->12],
 " rules.  It uses a slight hack:  you declare an extra local variable in the \
",
 StyleBox["Module", "Input"],
 ", which remains unused except for being passed to the function that creates \
the ",
 StyleBox["x$n -> x", "Input"],
 " rules.  The reason it is so passed is to provide the value of n.  You \
can't use assume that ",
 StyleBox["$ModuleNumber", "Input"],
 " will have the value you want at the end of the main ",
 StyleBox["Module", "Input"],
 ", since functions called during execution of the ",
 StyleBox["Module", "Input"],
 "'s body may have had module's themselves, hence increasing ",
 StyleBox["$ModuleNumber", "Input"],
 " beyond its original value."
}], "Text",
 CellDingbat->"\[EmptySmallCircle]"],

Cell[BoxData[
 RowBox[{
  RowBox[{"UndoModuloLocals", "[", "sampleSym_Symbol", "]"}], " ", ":=", 
  "\[IndentingNewLine]", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"sampleName", ",", " ", "suffix", 
      StyleBox[",",
       FontWeight->"Plain"], 
      StyleBox[" ",
       FontWeight->"Plain"], "suffixLen", ",", " ", "nameForm"}], "}"}], ",", 
    "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"sampleName", " ", "=", " ", 
      RowBox[{"SymbolName", " ", "@", " ", 
       RowBox[{"Unevaluated", "[", "sampleSym", "]"}]}]}], ";", 
     "\[IndentingNewLine]", 
     RowBox[{"suffix", " ", "=", " ", 
      RowBox[{"StringTake", "[", 
       RowBox[{"sampleName", ",", " ", 
        RowBox[{"{", 
         RowBox[{
          RowBox[{
           RowBox[{"StringPosition", "[", 
            RowBox[{"sampleName", ",", " ", "\"\<$\>\""}], "]"}], "[", 
           RowBox[{"[", 
            RowBox[{
             RowBox[{"-", "1"}], ",", " ", "1"}], "]"}], "]"}], ",", " ", 
          RowBox[{"-", "1"}]}], "}"}]}], "]"}]}], ";", "\[IndentingNewLine]", 
     
     RowBox[{"suffixLen", " ", "=", " ", 
      RowBox[{"StringLength", "[", "suffix", "]"}]}], ";", 
     "\[IndentingNewLine]", 
     RowBox[{"nameForm", " ", "=", " ", 
      RowBox[{"\"\<*\>\"", " ", "<>", " ", "suffix"}]}], ";", 
     "\[IndentingNewLine]", 
     RowBox[{"s_Symbol", " ", "\[RuleDelayed]", " ", 
      RowBox[{"With", "[", 
       RowBox[{
        RowBox[{"{", 
         RowBox[{"str", " ", "=", " ", 
          RowBox[{"SymbolName", " ", "@", " ", 
           RowBox[{"Unevaluated", "[", "s", "]"}]}]}], "}"}], ",", 
        "\[IndentingNewLine]", 
        RowBox[{
         RowBox[{"Symbol", " ", "@", " ", 
          RowBox[{"StringDrop", "[", 
           RowBox[{"str", ",", " ", 
            RowBox[{"-", "suffixLen"}]}], "]"}]}], " ", "/;", " ", 
         RowBox[{"StringMatchQ", "[", 
          RowBox[{"str", ",", " ", "nameForm"}], "]"}]}]}], 
       "\[IndentingNewLine]", "]"}]}]}]}], "\[IndentingNewLine]", 
   "]"}]}]], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Module", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{
    "Times", ",", " ", "Power", ",", " ", "Plus", ",", " ", "expr", ",", " ", 
     "sampleSym"}], "}"}], ",", "\[IndentingNewLine]", 
   RowBox[{
    RowBox[{"expr", " ", "=", " ", 
     RowBox[{
      RowBox[{"2", "^", "1"}], " ", "*", " ", 
      RowBox[{"3", "^", "2"}], " ", "*", " ", 
      RowBox[{"5", "^", "3"}]}]}], ";", "\[IndentingNewLine]", 
    RowBox[{"thread", " ", "=", " ", 
     RowBox[{"Thread", "[", 
      RowBox[{"expr", ",", " ", "Power"}], "]"}]}], ";", 
    "\[IndentingNewLine]", 
    RowBox[{"plus", " ", "=", " ", 
     RowBox[{"thread", " ", "/.", " ", 
      RowBox[{"Power", " ", "\[Rule]", " ", "Plus"}]}]}], ";", 
    "\[IndentingNewLine]", 
    RowBox[{"plus", " ", "/.", " ", 
     RowBox[{"UndoModuloLocals", "[", "sampleSym", "]"}]}]}]}], 
  "\[IndentingNewLine]", "]"}]], "Input"],

Cell[BoxData["36"], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Use Block to temporarily nullify built-in or user-defined functions\
\>", "Subsubsection"],

Cell[TextData[{
 "One of my favorite techniques is to use ",
 StyleBox["Block", "Input",
  FontSize->12],
 " to deactivate built-in functions for a while so I can safely work with \
expressions as meaningless structures.\n\nI don't do much mathematics myself, \
but one question at the Chicago 1998 conference was how to prevent a \
mathematical function, perhaps it was ",
 StyleBox["Integrate", "Input",
  FontSize->12],
 ", from acting until he had done some expanding, factoring, or other algebra \
on the arguments."
}], "Text"],

Cell["Suppose I have this integral:", "Text"],

Cell[BoxData[
 RowBox[{"Clear", "[", 
  RowBox[{"x", ",", " ", "y"}], "]"}]], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Integrate", "[", 
  RowBox[{
   RowBox[{
    RowBox[{"(", 
     RowBox[{"x", " ", "+", " ", "y"}], ")"}], "^", "3"}], ",", " ", "x"}], 
  "]"}]], "Input"],

Cell[BoxData[
 RowBox[{
  FractionBox["1", "4"], " ", 
  SuperscriptBox[
   RowBox[{"(", 
    RowBox[{"x", "+", "y"}], ")"}], "4"]}]], "Output"]
}, Open  ]],

Cell["\<\
Now I decide I want to integrate the expanded form instead.  I can do it \
interactively in the front end by using the \"Evaluate In Place\" feature:\
\>", "Text"],

Cell[BoxData[
 RowBox[{"Integrate", "[", 
  RowBox[{
   StyleBox[
    RowBox[{"Expand", "[", 
     RowBox[{
      RowBox[{"(", 
       RowBox[{"x", " ", "+", " ", "y"}], ")"}], "^", "3"}], "]"}],
    FontColor->RGBColor[0, 0, 1],
    Background->None], ",", " ", "x"}], "]"}]], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Integrate", "[", 
  RowBox[{
   RowBox[{
    SuperscriptBox["x", "3"], "+", 
    RowBox[{"3", " ", 
     SuperscriptBox["x", "2"], " ", "y"}], "+", 
    RowBox[{"3", " ", "x", " ", 
     SuperscriptBox["y", "2"]}], "+", 
    SuperscriptBox["y", "3"]}], ",", " ", "x"}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{
  FractionBox[
   SuperscriptBox["x", "4"], "4"], "+", 
  RowBox[{
   SuperscriptBox["x", "3"], " ", "y"}], "+", 
  FractionBox[
   RowBox[{"3", " ", 
    SuperscriptBox["x", "2"], " ", 
    SuperscriptBox["y", "2"]}], "2"], "+", 
  RowBox[{"x", " ", 
   SuperscriptBox["y", "3"]}]}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "One way to do it programmatically is to deactive ",
 StyleBox["Integrate", "Input",
  FontSize->12],
 " long enough to apply transformations:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Block", "[", 
  RowBox[{
   RowBox[{"{", "Integrate", "}"}], ",", "\[IndentingNewLine]", 
   RowBox[{
    RowBox[{"int", " ", "=", " ", 
     RowBox[{"Integrate", "[", 
      RowBox[{
       RowBox[{
        RowBox[{"(", 
         RowBox[{"x", " ", "+", " ", "y"}], ")"}], "^", "3"}], ",", " ", 
       "x"}], "]"}]}], ";", "\[IndentingNewLine]", 
    RowBox[{"exp", " ", "=", " ", 
     RowBox[{"MapAt", "[", 
      RowBox[{"Expand", ",", " ", "int", ",", " ", "1"}], "]"}]}], ";", 
    "\[IndentingNewLine]", "exp"}]}], "\[IndentingNewLine]", "]"}]], "Input"],

Cell[BoxData[
 RowBox[{
  FractionBox[
   SuperscriptBox["x", "4"], "4"], "+", 
  RowBox[{
   SuperscriptBox["x", "3"], " ", "y"}], "+", 
  FractionBox[
   RowBox[{"3", " ", 
    SuperscriptBox["x", "2"], " ", 
    SuperscriptBox["y", "2"]}], "2"], "+", 
  RowBox[{"x", " ", 
   SuperscriptBox["y", "3"]}]}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "From the final form, it's obvious that it worked.  We could verify it by \
printing the intermediate expression while still in the ",
 StyleBox["Block", "Input",
  FontSize->12],
 ":"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Block", "[", 
  RowBox[{
   RowBox[{"{", "Integrate", "}"}], ",", "\[IndentingNewLine]", 
   RowBox[{
    RowBox[{"int", " ", "=", " ", 
     RowBox[{"Integrate", "[", 
      RowBox[{
       RowBox[{
        RowBox[{"(", 
         RowBox[{"x", " ", "+", " ", "y"}], ")"}], "^", "3"}], ",", " ", 
       "x"}], "]"}]}], ";", "\[IndentingNewLine]", 
    RowBox[{"exp", " ", "=", " ", 
     RowBox[{"MapAt", "[", 
      RowBox[{"Expand", ",", " ", "int", ",", " ", "1"}], "]"}]}], ";", 
    "\[IndentingNewLine]", 
    RowBox[{"Print", "[", 
     RowBox[{"\"\<exp = \>\"", ",", " ", "exp"}], "]"}], ";", 
    "\[IndentingNewLine]", "exp"}]}], "\[IndentingNewLine]", "]"}]], "Input"],

Cell[BoxData[
 InterpretationBox[
  RowBox[{"\<\"exp = \"\>", "\[InvisibleSpace]", 
   RowBox[{"Integrate", "[", 
    RowBox[{
     RowBox[{
      SuperscriptBox["x", "3"], "+", 
      RowBox[{"3", " ", 
       SuperscriptBox["x", "2"], " ", "y"}], "+", 
      RowBox[{"3", " ", "x", " ", 
       SuperscriptBox["y", "2"]}], "+", 
      SuperscriptBox["y", "3"]}], ",", "x"}], "]"}]}],
  SequenceForm["exp = ", 
   Integrate[x^3 + 3 x^2 y + 3 x y^2 + y^3, x]],
  Editable->False]], "Print"],

Cell[BoxData[
 RowBox[{
  FractionBox[
   SuperscriptBox["x", "4"], "4"], "+", 
  RowBox[{
   SuperscriptBox["x", "3"], " ", "y"}], "+", 
  FractionBox[
   RowBox[{"3", " ", 
    SuperscriptBox["x", "2"], " ", 
    SuperscriptBox["y", "2"]}], "2"], "+", 
  RowBox[{"x", " ", 
   SuperscriptBox["y", "3"]}]}]], "Output"]
}, Open  ]]
}, Closed]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Assistants in figuring things out", "Subsection"],

Cell[CellGroupData[{

Cell["\<\
An assistant to understanding:  MapAt or ReplaceAll a Button to prominently \
display what targets are hit by your operation.\
\>", "Subsubsection"],

Cell[TextData[{
 "In the last section, toward the end I suggested a ",
 StyleBox["Hold", "Input",
  FontSize->12],
 "-like wrapper that would display itself as a frame, which is less obtrusive \
visually than ",
 StyleBox["Hold[...]", "Input",
  FontSize->12],
 " wrapped around everything in the expression.\n\nIn that vein, here is a \
technique that sometimes helps in debugging.  Use ",
 StyleBox["Map", "Input",
  FontSize->12],
 " or ",
 StyleBox["ReplaceAll", "Input",
  FontSize->12],
 " or other operations to wrap ",
 StyleBox["Button", "Input",
  FontSize->12],
 ", or some other prominently visible markup, around certain targets, \
especially if you're not sure what the targets will be."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Map", "[", 
  RowBox[{"Button", ",", " ", 
   RowBox[{"ToExpression", "[", 
    RowBox[{
    "\"\<2 + 4 I - 5/7\>\"", ",", " ", "InputForm", ",", " ", "HoldForm"}], 
    "]"}], ",", " ", 
   RowBox[{"{", 
    RowBox[{"-", "1"}], "}"}]}], "]"}]], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{
   ButtonBox["2"], "+", 
   RowBox[{
    ButtonBox["4"], " ", 
    ButtonBox["\[ImaginaryI]"]}], "+", 
   RowBox[{
    ButtonBox[
     RowBox[{"-", "1"}]], " ", 
    ButtonBox["5"], " ", 
    SuperscriptBox[
     ButtonBox["7"], 
     ButtonBox[
      RowBox[{"-", "1"}]]]}]}],
  HoldForm]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Map", "[", 
  RowBox[{"Button", ",", " ", 
   RowBox[{"ToExpression", "[", 
    RowBox[{
    "\"\<2 + 4 I - 5/7\>\"", ",", " ", "InputForm", ",", " ", "HoldForm"}], 
    "]"}], ",", " ", 
   RowBox[{"{", 
    RowBox[{"-", "1"}], "}"}], ",", " ", 
   RowBox[{"Heads", "\[Rule]", "True"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{
  ButtonBox["HoldForm"], "[", 
  RowBox[{
   ButtonBox["Plus"], "[", 
   RowBox[{
    ButtonBox["2"], ",", 
    RowBox[{
     ButtonBox["Times"], "[", 
     RowBox[{
      ButtonBox["4"], ",", 
      ButtonBox["\[ImaginaryI]"]}], "]"}], ",", 
    RowBox[{
     ButtonBox["Times"], "[", 
     RowBox[{
      ButtonBox[
       RowBox[{"-", "1"}]], ",", 
      ButtonBox["5"], ",", 
      RowBox[{
       ButtonBox["Power"], "[", 
       RowBox[{
        ButtonBox["7"], ",", 
        ButtonBox[
         RowBox[{"-", "1"}]]}], "]"}]}], "]"}]}], "]"}], "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Replace", "[", "\[IndentingNewLine]", 
  RowBox[{
   RowBox[{"ToExpression", "[", 
    RowBox[{
    "\"\<2 + 4 I - 5/7\>\"", ",", " ", "InputForm", ",", " ", "HoldForm"}], 
    "]"}], ",", "\[IndentingNewLine]", 
   RowBox[{
    RowBox[{"num_", " ", "/;", " ", 
     RowBox[{"NumberQ", " ", "@", " ", 
      RowBox[{"Unevaluated", "[", "num", "]"}]}]}], " ", "\[RuleDelayed]", 
    " ", 
    RowBox[{"Button", "[", "num", "]"}]}], ",", "\[IndentingNewLine]", 
   RowBox[{"{", 
    RowBox[{"-", "1"}], "}"}]}], "\[IndentingNewLine]", "]"}]], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{
   ButtonBox["2"], "+", 
   RowBox[{
    ButtonBox["4"], " ", "\[ImaginaryI]"}], "+", 
   RowBox[{
    ButtonBox[
     RowBox[{"-", "1"}]], " ", 
    ButtonBox["5"], " ", 
    SuperscriptBox[
     ButtonBox["7"], 
     ButtonBox[
      RowBox[{"-", "1"}]]]}]}],
  HoldForm]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"NumberQ", " ", "@", " ", 
  RowBox[{"Unevaluated", "[", "I", "]"}]}]], "Input"],

Cell[BoxData["False"], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Another assistant:  ParsedForm to show how input parses, before it begins to \
evaluate\
\>", "Subsubsection"],

Cell[TextData[{
 "When I'm writing typesetting rules, or analyzing code, I often need to \
search for patterns in unevaluated input or code.  Sometimes the actual \
structure in the unevaluated form isn't what I deduce from its displayed form \
or my past playing with ",
 StyleBox["FullForm", "Input",
  FontSize->12],
 " of ",
 StyleBox["evaluated",
  FontSlant->"Italic"],
 " things.\n\nHere's a wrapper I've used for many years to show me how things \
parse, before they begin evaluating."
}], "Text"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{
    RowBox[{"Attributes", "[", "ParsedForm", "]"}], " ", "=", " ", 
    "HoldAll"}], ";"}], "\[IndentingNewLine]"}], "\n", 
 RowBox[{
  RowBox[{"Format", "[", 
   RowBox[{"ParsedForm", "[", "expr_", "]"}], "]"}], " ", ":=", " ", 
  RowBox[{"HoldForm", "[", 
   RowBox[{"FullForm", "[", "expr", "]"}], "]"}]}]}], "Input"],

Cell["\<\
It reveals the parsed form of differences, fractions, and \"complex\" numbers.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"ParsedForm", "[", 
  RowBox[{"x", " ", "-", " ", "y"}], "]"}]], "Input"],

Cell[BoxData[
 TagBox[
  TagBox[
   StyleBox[
    RowBox[{"Plus", "[", 
     RowBox[{"x", ",", 
      RowBox[{"Times", "[", 
       RowBox[{
        RowBox[{"-", "1"}], ",", "y"}], "]"}]}], "]"}],
    ShowSpecialCharacters->False,
    ShowStringCharacters->True,
    NumberMarks->True],
   FullForm],
  HoldForm]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"ParsedForm", "[", 
  RowBox[{"1", "/", "5"}], "]"}]], "Input"],

Cell[BoxData[
 TagBox[
  TagBox[
   StyleBox[
    RowBox[{"Times", "[", 
     RowBox[{"1", ",", 
      RowBox[{"Power", "[", 
       RowBox[{"5", ",", 
        RowBox[{"-", "1"}]}], "]"}]}], "]"}],
    ShowSpecialCharacters->False,
    ShowStringCharacters->True,
    NumberMarks->True],
   FullForm],
  HoldForm]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"ParsedForm", "[", 
  RowBox[{"2", " ", "-", " ", 
   RowBox[{"5", " ", "I"}]}], "]"}]], "Input"],

Cell[BoxData[
 TagBox[
  TagBox[
   StyleBox[
    RowBox[{"Plus", "[", 
     RowBox[{"2", ",", 
      RowBox[{"Times", "[", 
       RowBox[{
        RowBox[{"-", "1"}], ",", 
        RowBox[{"Times", "[", 
         RowBox[{"5", ",", "\\[ImaginaryI]"}], "]"}]}], "]"}]}], "]"}],
    ShowSpecialCharacters->False,
    ShowStringCharacters->True,
    NumberMarks->True],
   FullForm],
  HoldForm]], "Output"]
}, Open  ]],

Cell[TextData[{
 "This makes it obvious that these things aren't the same as you think if you \
call ",
 StyleBox["FullForm", "Input",
  FontSize->12],
 " on the ",
 StyleBox["evaluated",
  FontSlant->"Italic"],
 " forms a lot."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Using HoldForm to what it looked like before evaluation", \
"Subsubsection"],

Cell[TextData[{
 "A lot of people get confused by nested scoping constructs, in particular, \
the automatic renaming of the inner construct's local variables, e.g. ",
 StyleBox["x -> x$", "Input",
  FontSize->12],
 ".  Using ",
 StyleBox["HoldForm", "Input",
  FontSize->12],
 ", you capture on film what the outer construct did to the inner construct, \
before the inner construct even begins evaluating:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"With", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"a", " ", "=", " ", "3"}], "}"}], ",", " ", 
   RowBox[{"HoldForm", " ", "@", " ", 
    RowBox[{"Module", "[", 
     RowBox[{
      RowBox[{"{", "x", "}"}], ",", " ", 
      RowBox[{"x", " ", "+", " ", "a"}]}], "]"}]}]}], "]"}]], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", "x$", "}"}], ",", 
    RowBox[{"x$", "+", "3"}]}], "]"}],
  HoldForm]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Module", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"a", " ", "=", " ", "0"}], "}"}], ",", " ", 
   RowBox[{"HoldForm", " ", "@", " ", 
    RowBox[{"Compile", "[", 
     RowBox[{
      RowBox[{"{", 
       RowBox[{"x", ",", " ", "y"}], "}"}], ",", " ", 
      RowBox[{
       RowBox[{"a", " ", "x"}], " ", "+", " ", "y"}]}], "]"}]}]}], 
  "]"}]], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{"Compile", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"x$", ",", "y$"}], "}"}], ",", 
    RowBox[{
     RowBox[{"a$6234", " ", "x$"}], "+", "y$"}]}], "]"}],
  HoldForm]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"Function", "[", 
   RowBox[{
    RowBox[{"{", "a", "}"}], ",", " ", 
    RowBox[{"HoldForm", "[", 
     RowBox[{
      RowBox[{"f", "[", 
       RowBox[{"x_", ",", " ", "y_"}], "]"}], " ", "=", " ", 
      RowBox[{
       RowBox[{"a", " ", "x"}], " ", "+", " ", "y"}]}], "]"}]}], "]"}], " ", 
  "[", "7", "]"}]], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{
   RowBox[{"f", "[", 
    RowBox[{"x$_", ",", "y$_"}], "]"}], "=", 
   RowBox[{
    RowBox[{"7", " ", "x$"}], "+", "y$"}]}],
  HoldForm]], "Output"]
}, Open  ]],

Cell[TextData[{
 "The same technique reveals that ",
 StyleBox["Block", "Input",
  FontSize->12],
 " doesn't participate in these lexical scoping activities.  If it is inside, \
its variables aren't renamed:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Module", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"a", " ", "=", " ", "0"}], "}"}], ",", " ", 
   RowBox[{"HoldForm", " ", "@", " ", 
    RowBox[{"Block", "[", 
     RowBox[{
      RowBox[{"{", 
       RowBox[{"x", ",", " ", "y"}], "}"}], ",", " ", 
      RowBox[{
       RowBox[{"a", " ", "x"}], " ", "+", " ", "y"}]}], "]"}]}]}], 
  "]"}]], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{"Block", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"x", ",", "y"}], "}"}], ",", 
    RowBox[{
     RowBox[{"a$6233", " ", "x"}], "+", "y"}]}], "]"}],
  HoldForm]], "Output"]
}, Open  ]],

Cell["\<\
And if it is outside, it doesn't perform renaming on constructs inside:\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Block", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"a", " ", "=", " ", "0"}], "}"}], ",", " ", 
   RowBox[{"HoldForm", " ", "@", " ", 
    RowBox[{"Module", "[", 
     RowBox[{
      RowBox[{"{", 
       RowBox[{"x", ",", " ", "y"}], "}"}], ",", " ", 
      RowBox[{
       RowBox[{"a", " ", "x"}], " ", "+", " ", "y"}]}], "]"}]}]}], 
  "]"}]], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"x", ",", "y"}], "}"}], ",", 
    RowBox[{
     RowBox[{"a", " ", "x"}], "+", "y"}]}], "]"}],
  HoldForm]], "Output"]
}, Open  ]]
}, Closed]]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["More on principles and methods", "Section"],

Cell[CellGroupData[{

Cell["\<\
Structural operations are your friends; they work well on unevaluated \
expressions.\
\>", "Subsection"],

Cell[CellGroupData[{

Cell["Flatten", "Subsubsection"],

Cell[TextData[{
 "An example of ",
 StyleBox["Flatten", "Input",
  FontSize->12],
 ":"
}], "Text"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"ClearAll", "[", "f", "]"}], "\[IndentingNewLine]"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{
    RowBox[{"Attributes", "[", "f", "]"}], " ", "=", " ", "HoldAll"}], ";"}], 
  "\[IndentingNewLine]"}], "\n", 
 RowBox[{
  RowBox[{"f", "[", 
   RowBox[{"Xor", "[", "elems___", "]"}], "]"}], " ", ":=", 
  "\[IndentingNewLine]", 
  RowBox[{"Replace", "[", "\[IndentingNewLine]", 
   RowBox[{
    RowBox[{"Sort", "[", 
     RowBox[{"Flatten", "[", 
      RowBox[{
       RowBox[{"Hold", "[", "elems", "]"}], ",", " ", "Infinity", ",", " ", 
       "Xor"}], "]"}], "]"}], ",", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"Hold", "[", "args___", "]"}], " ", "\[RuleDelayed]", " ", 
     RowBox[{"HoldForm", "[", 
      RowBox[{"CirclePlus", "[", "args", "]"}], "]"}]}]}], 
   "\[IndentingNewLine]", "]"}]}]}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"f", "[", 
  RowBox[{"Xor", "[", 
   RowBox[{
    RowBox[{"Xor", "[", 
     RowBox[{
      RowBox[{"1", " ", "\[Equal]", " ", "1"}], ",", " ", 
      RowBox[{"Xor", "[", 
       RowBox[{"0", " ", "\[Equal]", " ", "1"}], "]"}]}], "]"}], ",", " ", 
    RowBox[{"Xor", "[", 
     RowBox[{
      RowBox[{"Xor", "[", 
       RowBox[{
        RowBox[{"2", " ", "\[Equal]", " ", "1"}], ",", " ", 
        RowBox[{"1", " ", "\[Equal]", " ", "0"}]}], "]"}], ",", " ", 
      RowBox[{"2", " ", "\[Equal]", " ", "0"}]}], "]"}]}], "]"}], 
  "]"}]], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{
   RowBox[{"(", 
    RowBox[{"0", "==", "1"}], ")"}], "\[CirclePlus]", 
   RowBox[{"(", 
    RowBox[{"1", "==", "0"}], ")"}], "\[CirclePlus]", 
   RowBox[{"(", 
    RowBox[{"1", "==", "1"}], ")"}], "\[CirclePlus]", 
   RowBox[{"(", 
    RowBox[{"2", "==", "0"}], ")"}], "\[CirclePlus]", 
   RowBox[{"(", 
    RowBox[{"2", "==", "1"}], ")"}]}],
  HoldForm]], "Output"]
}, Open  ]],

Cell["\<\
Here is a function automatically flattens multiple levels of itself.  It also \
acts as the identity on a singleton.\
\>", "Text"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"ClearAll", "[", "f", "]"}], "\[IndentingNewLine]"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{
    RowBox[{"Attributes", "[", "f", "]"}], " ", "=", " ", "HoldAll"}], ";"}], 
  "\[IndentingNewLine]"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{
    RowBox[{"f", "[", "args___", "]"}], " ", "/;", " ", 
    RowBox[{"MemberQ", "[", 
     RowBox[{
      RowBox[{"Unevaluated", "[", 
       RowBox[{"{", "args", "}"}], "]"}], ",", "_f"}], "]"}]}], " ", ":=", 
   " ", 
   RowBox[{"Flatten", "[", 
    RowBox[{
     RowBox[{"Unevaluated", "[", 
      RowBox[{"f", "[", "args", "]"}], "]"}], ",", " ", "Infinity", ",", " ", 
     "f"}], "]"}]}], "\[IndentingNewLine]"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"f", "[", "singleton_", "]"}], " ", ":=", " ", "singleton"}], 
  "\[IndentingNewLine]"}], "\n", 
 RowBox[{
  RowBox[{"f", "[", "elems___", "]"}], " ", ":=", " ", 
  RowBox[{"Hold", "[", "elems", "]"}]}]}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"f", "[", 
  RowBox[{
   RowBox[{"f", "[", 
    RowBox[{"1", ",", " ", "2"}], "]"}], ",", " ", 
   RowBox[{"f", "[", 
    RowBox[{"3", ",", " ", "4", ",", " ", "5"}], "]"}], ",", " ", 
   RowBox[{"f", "[", 
    RowBox[{"6", ",", " ", 
     RowBox[{"f", "[", 
      RowBox[{"7", ",", " ", "8"}], "]"}]}], "]"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"Hold", "[", 
  RowBox[{
  "1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", ",", "8"}],
   "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"f", "[", "1", "]"}]], "Input"],

Cell[BoxData["1"], "Output"]
}, Open  ]],

Cell[TextData[{
 "Usually people try to do this with ",
 StyleBox["Flat", "Input",
  FontSize->12],
 ", but that causes infinite recursion because ",
 StyleBox["Flat", "Input",
  FontSize->12],
 " also interferes with pattern-matching of your rules."
}], "Text"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"ClearAll", "[", "f", "]"}], "\[IndentingNewLine]"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{
    RowBox[{"Attributes", "[", "f", "]"}], " ", "=", " ", 
    RowBox[{"{", 
     RowBox[{"HoldAll", ",", " ", "Flat"}], "}"}]}], ";"}], 
  "\[IndentingNewLine]"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"f", "[", "singleton_", "]"}], " ", ":=", " ", "singleton"}], 
  "\[IndentingNewLine]"}], "\n", 
 RowBox[{
  RowBox[{"f", "[", "elems___", "]"}], " ", ":=", " ", 
  RowBox[{"Hold", "[", "elems", "]"}]}]}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"f", "[", 
  RowBox[{
   RowBox[{"f", "[", 
    RowBox[{"1", ",", " ", "2"}], "]"}], ",", " ", 
   RowBox[{"f", "[", 
    RowBox[{"3", ",", " ", "4", ",", " ", "5"}], "]"}], ",", " ", 
   RowBox[{"f", "[", 
    RowBox[{"6", ",", " ", 
     RowBox[{"f", "[", 
      RowBox[{"7", ",", " ", "8"}], "]"}]}], "]"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{
  RowBox[{"$IterationLimit", "::", "\<\"itlim\"\>"}], 
  RowBox[{
  ":", " "}], "\<\"Iteration limit of \\!\\(4096\\) exceeded.\"\>"}]], \
"Message"],

Cell[BoxData[
 RowBox[{"Hold", "[", 
  RowBox[{"f", "[", 
   RowBox[{
   "1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", ",", 
    "8"}], "]"}], "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"f", "[", "1", "]"}]], "Input"],

Cell[BoxData[
 RowBox[{
  RowBox[{"$IterationLimit", "::", "\<\"itlim\"\>"}], 
  RowBox[{
  ":", " "}], "\<\"Iteration limit of \\!\\(4096\\) exceeded.\"\>"}]], \
"Message"],

Cell[BoxData[
 RowBox[{"Hold", "[", 
  RowBox[{"f", "[", "1", "]"}], "]"}]], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["Thread", "Subsubsection"],

Cell["\<\
If your f is already a holding function, and you want to map it across a \
list, of course without letting the elements of the list evaluate before f \
gets to them, then you can do:\
\>", "Text"],

Cell[BoxData[
 RowBox[{"List", " ", "@@", " ", 
  RowBox[{"(", 
   RowBox[{"f", " ", "/@", " ", 
    RowBox[{"Hold", "[", 
     RowBox[{"e1", ",", " ", "\[Ellipsis]", ",", " ", "en"}], "]"}]}], 
   ")"}]}]], "Input"],

Cell[BoxData[
 RowBox[{"ReleaseHold", " ", "@", " ", 
  RowBox[{"Map", "[", 
   RowBox[{"f", ",", " ", 
    RowBox[{"Hold", "[", 
     RowBox[{"{", 
      RowBox[{"e1", ",", " ", "\[Ellipsis]", ",", " ", "en"}], "}"}], "]"}], 
    ",", " ", 
    RowBox[{"{", "2", "}"}]}], "]"}]}]], "Input"],

Cell[TextData[{
 "But an even more compact method is ",
 StyleBox["Thread", "Input",
  FontSize->12],
 ", which is really a controlled ",
 StyleBox["Listable", "Input",
  FontSize->12],
 ", just one application of ",
 StyleBox["Listable", "Input",
  FontSize->12],
 " instead of recursive application of it:"
}], "Text"],

Cell[BoxData[
 RowBox[{"Thread", " ", "@", " ", 
  RowBox[{"Unevaluated", " ", "@", " ", 
   RowBox[{"f", "[", 
    RowBox[{"{", 
     RowBox[{"e1", ",", " ", "\[Ellipsis]", ",", " ", "en"}], "}"}], 
    "]"}]}]}]], "Input"],

Cell[TextData[{
 "If you have to express it as a pure function, e.g. if f is a two-variable \
function, and one argument is some fixed value, then to make it holding, you \
must use ",
 StyleBox["Function[vars, body, attrs]", "Input",
  FontSize->12],
 ":"
}], "Text"],

Cell[BoxData[
 RowBox[{"List", " ", "@@", " ", 
  RowBox[{"(", 
   RowBox[{
    RowBox[{"Function", "[", 
     RowBox[{"e", ",", " ", 
      RowBox[{"f", "[", 
       RowBox[{"0", ",", " ", "e"}], "]"}], ",", " ", "HoldFirst"}], "]"}], 
    " ", "/@", " ", 
    RowBox[{"Hold", "[", 
     RowBox[{"e1", ",", " ", "\[Ellipsis]", ",", " ", "en"}], "]"}]}], 
   ")"}]}]], "Input"],

Cell[BoxData[
 RowBox[{"ReleaseHold", " ", "@", " ", 
  RowBox[{"Map", "[", 
   RowBox[{
    RowBox[{"Function", "[", 
     RowBox[{"e", ",", " ", 
      RowBox[{"f", "[", 
       RowBox[{"0", ",", " ", "e"}], "]"}], ",", " ", "HoldFirst"}], "]"}], 
    ",", " ", 
    RowBox[{"Hold", "[", 
     RowBox[{"{", 
      RowBox[{"e1", ",", " ", "\[Ellipsis]", ",", " ", "en"}], "}"}], "]"}], 
    ",", " ", 
    RowBox[{"{", "2", "}"}]}], "]"}]}]], "Input"],

Cell[TextData[{
 "However, again ",
 StyleBox["Thread", "Input",
  FontSize->12],
 " makes it short and elegant:"
}], "Text"],

Cell[BoxData[
 RowBox[{"Thread", "[", 
  RowBox[{
   RowBox[{"Unevaluated", " ", "@", " ", 
    RowBox[{"f", "[", 
     RowBox[{"0", ",", " ", 
      RowBox[{"{", 
       RowBox[{"e1", ",", " ", "\[Ellipsis]", ",", " ", "en"}], "}"}]}], 
     "]"}]}], ",", " ", 
   RowBox[{"-", "1"}]}], "]"}]], "Input"],

Cell["Here's a real use from the top-level typesetting packages:", "Text"],

Cell["\<\
SetAttributes[{HeldOptionQ, HeldNonOptionQ}, HoldAllComplete]

HeldOptionQ[expr_] := OptionQ @ Unevaluated[expr]
HeldOptionQ[exprs__] := Thread[Unevaluated @ HeldOptionQ[And[exprs]], And]


HeldNonOptionQ[expr_] := Not @ HeldOptionQ[expr]
HeldNonOptionQ[exprs__] := Thread[Unevaluated @ HeldNonOptionQ[And[exprs]], \
And]\
\>", "Program",
 FontFamily->"Courier",
 FontSize->12],

Cell[TextData[{
 "Another real use in the typesetting packages is when I want to map ",
 StyleBox["MakeBoxes", "Input",
  FontSize->12],
 ", or its sister ",
 StyleBox["Parenthesize", "Input",
  FontSize->12],
 ", across a list:"
}], "Text"],

Cell[BoxData[
 RowBox[{"Thread", "[", "\[IndentingNewLine]", 
  RowBox[{
   RowBox[{"Unevaluated", " ", "@", " ", 
    RowBox[{"Parenthesize", "[", 
     RowBox[{
      RowBox[{"{", "exprs", "}"}], ",", "fmt", ",", "CompoundExpression"}], 
     "]"}]}], ",", "\[IndentingNewLine]", "List", ",", "\[IndentingNewLine]", 
   "1"}], "\[IndentingNewLine]", "]"}]], "Input"],

Cell[TextData[{
 "To feed the output of ",
 StyleBox["MakeExpression", "Input",
  FontSize->12],
 " to something else without the ",
 StyleBox["HoldComplete", "Input",
  FontSize->12],
 " wrapper.  Or in general, any function that returns result in ",
 StyleBox["Hold", "Input",
  FontSize->12],
 " can feed its result, sans the wrapper, to another thing."
}], "Text"],

Cell[BoxData[
 RowBox[{"TagBox", "/:", 
  RowBox[{"MakeExpression", "[", 
   RowBox[{
    RowBox[{"TagBox", "[", 
     RowBox[{
      RowBox[{"GridBox", "[", 
       RowBox[{"boxexpr_", ",", "opts___"}], "]"}], ",", "Grid"}], "]"}], ",",
     "fmt_"}], "]"}], ":=", 
  RowBox[{"Thread", "[", 
   RowBox[{
    RowBox[{"Grid", "[", 
     RowBox[{
      RowBox[{"MakeExpression", "[", 
       RowBox[{
        RowBox[{"GridBox", "[", "boxexpr", "]"}], ",", "fmt"}], "]"}], ",", 
      "opts"}], "]"}], ",", "HoldComplete", ",", "1"}], "]"}]}]], "Input"],

Cell[TextData[{
 StyleBox["Grid", "Input",
  FontSize->12],
 " is conveniently inert; it just sits there and does nothing to its \
argument.  If your f doesn't sit still, use ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 " or ",
 StyleBox["Block", "Input",
  FontSize->12],
 " methods:"
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"ReleaseHold", " ", "@", " ", 
    RowBox[{"Thread", "[", 
     RowBox[{
      RowBox[{"Unevaluated", " ", "@", " ", 
       RowBox[{"f", "[", 
        RowBox[{"#", ",", "opts"}], "]"}]}], ",", "HoldComplete", ",", "1"}], 
     "]"}]}], "&"}], " ", "@", " ", 
  RowBox[{"MakeExpression", "[", 
   RowBox[{
    RowBox[{"GridBox", "[", "boxexpr", "]"}], ",", "fmt"}], "]"}]}]], "Input"],

Cell[BoxData[
 RowBox[{"Block", "[", 
  RowBox[{
   RowBox[{"{", "f", "}"}], ",", "\[IndentingNewLine]", 
   RowBox[{"ReleaseHold", " ", "@", " ", 
    RowBox[{"Thread", "[", 
     RowBox[{
      RowBox[{"f", "[", 
       RowBox[{
        RowBox[{"MakeExpression", "[", 
         RowBox[{
          RowBox[{"GridBox", "[", "boxexpr", "]"}], ",", "fmt"}], "]"}], ",", 
        "opts"}], "]"}], ",", "HoldComplete", ",", "1"}], "]"}]}]}], 
  "\[IndentingNewLine]", "]"}]], "Input"],

Cell[TextData[{
 "In general, ",
 StyleBox["Thread", "Input",
  FontSize->12],
 " can be used to manually implement one level of ",
 StyleBox["Listable", "Input",
  FontSize->12],
 "."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Pointwise operators:  ReplacePart, Delete, FlattenAt, MapAt", \
"Subsubsection"],

Cell[TextData[{
 StyleBox["ReplacePart", "Input",
  FontSize->12],
 " gives you complete power to do whatever you want, though it takes a bit \
more work because you have to specify all the target locations.  With it, you \
can implement a ",
 StyleBox["ReplaceAt", "Input",
  FontSize->12],
 ", which gives you even finer control than ",
 StyleBox["Replace", "Input",
  FontSize->12],
 " with level specification."
}], "Text"],

Cell[TextData[{
 "Here's an ",
 StyleBox["EvaluateAt", "Input",
  FontSize->12],
 " function that evaluates just the subexpressions you tell it to.  I wrote \
this for the Further Examples during Version 3.0 development, and it's not \
the most efficient method, as its use of ",
 StyleBox["Fold", "Input",
  FontSize->12],
 " makes it O(n^2), but it illustrates what you can do:"
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"EvaluateAt", "[", 
   RowBox[{"expr_", ",", "positions_"}], "]"}], ":=", 
  RowBox[{"Fold", "[", 
   RowBox[{
    RowBox[{
     RowBox[{"ReplacePart", "[", 
      RowBox[{"#1", ",", 
       RowBox[{"Part", "[", 
        RowBox[{"#1", ",", 
         RowBox[{"Sequence", "@@", "#2"}]}], "]"}], ",", "#2"}], "]"}], "&"}],
     ",", "expr", ",", "positions"}], "]"}]}]], "Input"],

Cell[TextData[{
 "A faster implementation would be based on the 4-argument form of ",
 StyleBox["ReplacePart", "Input",
  FontSize->12],
 ".  I will include this in a later revision of this document."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Identify what's bad to evaluate:  the whole, or the parts, or the return \
value?\
\>", "Subsubsection"],

Cell[TextData[{
 "If the whole, then ",
 StyleBox["Block", "Input",
  FontSize->12],
 " is one of the easiest methods"
}], "Text"],

Cell[TextData[{
 "If the parts, then you're more likely to need ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 " or ",
 StyleBox["Hold", "Input",
  FontSize->12],
 "* stuff.  You could use ",
 StyleBox["Block", "Input",
  FontSize->12],
 ", but then you have to assemble a list of all the types of parts and scope \
their heads."
}], "Text"],

Cell[TextData[{
 "If the return value must remain unevaluated, and you're going to return it \
to some arbitrary function calling you as a service, rather than you passing \
the unevaluated result immediately to some other function in your code, then \
you may have to return it wrapped in ",
 StyleBox["Hold", "Input",
  FontSize->12],
 " or some holding container.  Like ",
 StyleBox["MakeExpression", "Input",
  FontSize->12],
 " (whose return value is in ",
 StyleBox["HoldComplete", "Input",
  FontSize->12],
 ") or ",
 StyleBox["Trace", "Input",
  FontSize->12],
 " (whose return value wraps stages of evaluation in ",
 StyleBox["HoldForm", "Input",
  FontSize->12],
 ") or ",
 StyleBox["DownValues", "Input",
  FontSize->12],
 " (whose return value represents definitions, protecting the left-hand side \
with ",
 StyleBox["HoldPattern", "Input",
  FontSize->12],
 " and the right-hand side with ",
 StyleBox["RuleDelayed", "Input",
  FontSize->12],
 ")"
}], "Text"]
}, Closed]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Some subtle topics to demystify", "Subsection"],

Cell[CellGroupData[{

Cell[TextData[{
 "Functions that hold some or all their arguments, e.g. Plot, Table, and \
HoldComplete, get ",
 StyleBox["all their power",
  FontSlant->"Italic"],
 " of preventing evaluation from ",
 StyleBox["attributes",
  FontSlant->"Italic"],
 "."
}], "Subsubsection"],

Cell[TextData[{
 "Some ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " users believe that functions such as ",
 StyleBox["Plot", "Input",
  FontSize->12],
 ", ",
 StyleBox["Table", "Input",
  FontSize->12],
 ", and ",
 StyleBox["HoldComplete", "Input",
  FontSize->12],
 " have magical internal code to prevent their arguments from evaluating.  \
Well, there is no mysterious internal magic here.  These functions get all \
their power from the attributes they carry, e.g. ",
 StyleBox["HoldFirst", "Input",
  FontSize->12],
 ", ",
 StyleBox["HoldRest", "Input",
  FontSize->12],
 ", ",
 StyleBox["HoldAll", "Input",
  FontSize->12],
 ", ",
 StyleBox["HoldAllComplete", "Input",
  FontSize->12],
 ".  You can endow your own functions with these attributes.\n\nIf a function \
is ",
 StyleBox["HoldFirst", "Input",
  FontSize->12],
 ", it will receive its first argument unevaluated, and the others evaluated. \
 It's that simple.  You the user can deprive any function of its power by \
using ",
 StyleBox["ClearAttributes", "Input",
  FontSize->12],
 ".  Example:  ",
 StyleBox["Context", "Input",
  FontSize->12],
 " must receive its first argument unevaluated, since it might be a symbol \
with a value."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"x", " ", "=", " ", "777"}], ";"}]], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Context", "[", "x", "]"}]], "Input"],

Cell[BoxData["\<\"Global`\"\>"], "Output"]
}, Open  ]],

Cell[BoxData[
 RowBox[{
  RowBox[{"ClearAttributes", "[", 
   RowBox[{"Context", ",", " ", "HoldFirst"}], "]"}], ";"}]], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Context", "[", "x", "]"}]], "Input"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Context", "::", "\<\"ssle\"\>"}], 
  RowBox[{
  ":", " "}], "\<\"Symbol, string, or HoldPattern[symbol] expected at \
position \\!\\(1\\) in \\!\\(Context[777]\\).\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{"Context", "[", "777", "]"}]], "Output"]
}, Open  ]],

Cell[BoxData[
 RowBox[{
  RowBox[{"SetAttributes", "[", 
   RowBox[{"Context", ",", " ", "HoldFirst"}], "]"}], ";"}]], "Input"],

Cell[TextData[{
 "It's actually the ",
 StyleBox["top-level evaluator that decides",
  FontSlant->"Italic"],
 " what arguments a function receives, not the function itself.  The \
evaluator always looks at a function call's arguments and does \
pre-processing, unless the function carries the attribute ",
 StyleBox["HoldAllComplete", "Input",
  FontSize->12],
 ".  Even the ",
 StyleBox["HoldAll", "Input",
  FontSize->12],
 " attribute allows a few kinds of pre-processing to take effect:  ",
 StyleBox["Evaluate", "Input",
  FontSize->12],
 " take effect, ",
 StyleBox["Sequence", "Input",
  FontSize->12],
 " is flattened, and ",
 StyleBox["UpValues", "Input",
  FontSize->12],
 " of the arguments do fire."
}], "Text"],

Cell[TextData[{
 StyleBox["Hold", "Input",
  FontSize->12],
 " is the prototypical ",
 StyleBox["HoldAll", "Input",
  FontSize->12],
 " function:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Attributes", "[", "Hold", "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"HoldAll", ",", "Protected"}], "}"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "It lets ",
 StyleBox["Evaluate", "Input",
  FontSize->12],
 " and ",
 StyleBox["Sequence", "Input",
  FontSize->12],
 " do their thing:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Hold", "[", 
  RowBox[{
   RowBox[{"Evaluate", "[", 
    RowBox[{"1", " ", "+", " ", "2"}], "]"}], ",", " ", 
   RowBox[{"Sequence", "[", 
    RowBox[{"7", ",", " ", 
     RowBox[{"Print", "[", "8", "]"}]}], "]"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"Hold", "[", 
  RowBox[{"3", ",", "7", ",", 
   RowBox[{"Print", "[", "8", "]"}]}], "]"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 StyleBox["HoldComplete", "Input",
  FontSize->12],
 " is stronger; it doesn't allow even this:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"HoldComplete", "[", 
  RowBox[{
   RowBox[{"Evaluate", "[", 
    RowBox[{"1", " ", "+", " ", "2"}], "]"}], ",", " ", 
   RowBox[{"Sequence", "[", 
    RowBox[{"7", ",", " ", 
     RowBox[{"Print", "[", "8", "]"}]}], "]"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"HoldComplete", "[", 
  RowBox[{
   RowBox[{"Evaluate", "[", 
    RowBox[{"1", "+", "2"}], "]"}], ",", 
   RowBox[{"Sequence", "[", 
    RowBox[{"7", ",", 
     RowBox[{"Print", "[", "8", "]"}]}], "]"}]}], "]"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "But deprive of its ",
 StyleBox["HoldAllComplete", "Input",
  FontSize->12],
 " attribute, and it becomes powerless to hold anything.  However, you'd \
better not do this when running in the front end, because ",
 StyleBox["HoldComplete", "Input",
  FontSize->12],
 " is used by the typesetting code,which is an integral part of the main loop \
when you're in a front end."
}], "Text"],

Cell[TextData[{
 "For more information, see \"A.4.1 The Standard Evaluation Sequence\" in The \
",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " Book, or for even more detail, Dave Withoff's talk from the 1992 \
conference Course Notes."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
 "Misconception:  Block will deactivate absolutely all properties and \
meaningful behavior of a symbol in ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ".  Wrong!  Only ",
 StyleBox["rewrite rules",
  FontSlant->"Italic"],
 " are deactivated."
}], "Subsubsection"],

Cell[TextData[{
 "Basically, a command or function that ",
 StyleBox["performs an action",
  FontSlant->"Italic"],
 " or ",
 StyleBox["applies a transformation",
  FontSlant->"Italic"],
 ", e.g. ",
 StyleBox["OpenWrite", "Input",
  FontSize->12],
 ", ",
 StyleBox["Map", "Input",
  FontSize->12],
 ", and so on, you can deactivate.  ",
 StyleBox["Block", "Input",
  FontSize->12],
 " will turn off just about all the these properties of a symbol (both \
top-level and built-in versions of these):"
}], "Text"],

Cell[BoxData[
 RowBox[{"$ValueTypes", "=", 
  RowBox[{"{", 
   RowBox[{
   "Attributes", ",", "DefaultValues", ",", "DownValues", ",", "FormatValues",
     ",", "NValues", ",", "OwnValues", ",", "Options", ",", "SubValues", ",", 
    "UpValues"}], "}"}]}]], "Input"],

Cell[TextData[{
 "which are the assignments to a symbol.  This is about what you expect, and \
won't surprise you, though note ",
 StyleBox["FormatValues", "Input",
  FontSize->12],
 ", which means that ",
 StyleBox["Block", "Input",
  FontSize->12],
 " will also turn off pretty-printing rules for the symbol, a fact that is \
often missed, and is sometimes useful, sometimes annoying."
}], "Text"],

Cell[TextData[{
 "But some symbols have a special meaning that is recognized by some other \
part of the system, such as the fact that ",
 StyleBox["Slot", "Input",
  FontSize->12],
 " is recognized by ",
 StyleBox["Function", "Input",
  FontSize->12],
 " as labelling the function's formal variables.  It may surprise you that \
such extrinsic properties are ",
 StyleBox["not deactivated",
  FontSlant->"Italic"],
 " by ",
 StyleBox["Block", "Input",
  FontSize->12],
 "!"
}], "Text"],

Cell[TextData[{
 "Here are a few  categories of properties that ",
 StyleBox["Block", "Input",
  FontSize->12],
 " will ",
 StyleBox["not",
  FontSlant->"Italic"],
 " deactivate, to give you a feeling for the limits of ",
 StyleBox["Block", "Input",
  FontSize->12],
 ":\n\n(1)  Attributes, e.g. ",
 StyleBox["Listable", "Input",
  FontSize->12],
 " and ",
 StyleBox["HoldAll", "Input",
  FontSize->12],
 ".\n\n(2)  Names of options, e.g. ",
 StyleBox["PlotPoints", "Input",
  FontSize->12],
 " or ",
 StyleBox["WorkingPrecision", "Input",
  FontSize->12],
 ".\n\n(3)  The meta-expression status of the various pattern types:  ",
 StyleBox["Pattern", "Input",
  FontSize->12],
 ", ",
 StyleBox["Blank", "Input",
  FontSize->12],
 "*, ",
 StyleBox["Repeated", "Input",
  FontSize->12],
 "*, ",
 StyleBox["Alternatives", "Input",
  FontSize->12],
 ", ",
 StyleBox["Optional", "Input",
  FontSize->12],
 ", ",
 StyleBox["PatternTest", "Input",
  FontSize->12],
 ", ",
 StyleBox["Condition", "Input",
  FontSize->12],
 ", ",
 StyleBox["HoldPattern (", "Input",
  FontSize->12],
 "formerly ",
 StyleBox["Literal)", "Input",
  FontSize->12],
 ", ",
 StyleBox["Verbatim", "Input",
  FontSize->12],
 ".\n\n(4)  The fact that ",
 StyleBox["Slot[i]", "Input",
  FontSize->12],
 " and ",
 StyleBox["SlotSequence[i]", "Input",
  FontSize->12],
 ", i.e. ",
 StyleBox["#n", "Input",
  FontSize->12],
 " and ",
 StyleBox["##n", "Input",
  FontSize->12],
 ",  refer to the arguments of ",
 StyleBox["Function[body]", "Input",
  FontSize->12],
 ".\n\n(5)  The status of being a lexical scoping construct, including ",
 StyleBox["Module", "Input",
  FontSize->12],
 ", ",
 StyleBox["With", "Input",
  FontSize->12],
 ", ",
 StyleBox["Function", "Input",
  FontSize->12],
 ", ",
 StyleBox["Compile", "Input",
  FontSize->12],
 ", the ",
 StyleBox["Rule", "Input",
  FontSize->12],
 "* and *",
 StyleBox["Set", "Input",
  FontSize->12],
 "* family, ",
 StyleBox["Condition", "Input",
  FontSize->12],
 ", when it comes to things like variable renaming ",
 StyleBox["x -> x$", "Input",
  FontSize->12],
 ".  Though ",
 StyleBox["Block", "Input",
  FontSize->12],
 " can certainly make any of these a do-nothing command.\n\n(6)  Lots of \
other magic symbols like ",
 StyleBox["Evaluate", "Input",
  FontSize->12],
 ", ",
 StyleBox["Sequence", "Input",
  FontSize->12],
 ", ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 "; and just about any symbol that is simply a name or container for data \
that is recognized or acted upon by an actual command or function: ",
 StyleBox["Rule", "Input",
  FontSize->12],
 " and ",
 StyleBox["RuleDelayed", "Input",
  FontSize->12],
 "; ",
 StyleBox["LinkObject", "Input",
  FontSize->12],
 ", ",
 StyleBox["InputStream", "Input",
  FontSize->12],
 ", and ",
 StyleBox["OutputStream", "Input",
  FontSize->12],
 "; ",
 StyleBox["Word", "Input",
  FontSize->12],
 " and ",
 StyleBox["Number;", "Input",
  FontSize->12],
 " ",
 StyleBox["MessageName", "Input",
  FontSize->12],
 ", ",
 StyleBox["Label", "Input",
  FontSize->12],
 " (for ",
 StyleBox["Goto", "Input",
  FontSize->12],
 "); many others."
}], "Text"],

Cell["Further explanation and examples:", "Text",
 FontWeight->"Bold"],

Cell["\<\
(1)  Attributes

They do not derive their power from having rewrite rules attached to them; \
i.e. they don't have \"function definitions\".  Their power is that major \
subsystems of the kernel, such as the evaluator, the pattern-matcher, and \
lexical scoping, recognize them conferring special properties to symbols.\
\>", "Text"],

Cell[TextData[{
 StyleBox["Block", "Input",
  FontSize->12],
 "'ing ",
 StyleBox["HoldAll", "Input",
  FontSize->12],
 " doesn't affect ",
 StyleBox["HoldAll", "Input",
  FontSize->12],
 " functions:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Block", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"HoldAll", ",", " ", "f"}], "}"}], ",", "\[IndentingNewLine]", 
   RowBox[{
    RowBox[{
     RowBox[{"Attributes", "[", "f", "]"}], " ", "=", " ", 
     RowBox[{"{", "HoldAll", "}"}]}], ";", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"f", "[", "expr_", "]"}], " ", "=", " ", "0"}], ";", 
    "\[IndentingNewLine]", 
    RowBox[{"f", "[", 
     RowBox[{"Print", "[", "3", "]"}], "]"}]}]}], "\[IndentingNewLine]", 
  "]"}]], "Input"],

Cell[BoxData["0"], "Output"]
}, Open  ]],

Cell[TextData[{
 "If ",
 StyleBox["HoldAll", "Input",
  FontSize->12],
 " lost its meaning, then f would have let ",
 StyleBox["Print[3]", "Input",
  FontSize->12],
 " evaluate, as below."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Block", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"Attributes", ",", " ", "f"}], "}"}], ",", "\[IndentingNewLine]", 
   
   RowBox[{
    RowBox[{
     RowBox[{"Attributes", "[", "f", "]"}], " ", "=", " ", 
     RowBox[{"{", "HoldAll", "}"}]}], ";", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"f", "[", "expr_", "]"}], " ", "=", " ", "0"}], ";", 
    "\[IndentingNewLine]", 
    RowBox[{"f", "[", 
     RowBox[{"Print", "[", "3", "]"}], "]"}]}]}], "\[IndentingNewLine]", 
  "]"}]], "Input"],

Cell[BoxData["3"], "Print"],

Cell[BoxData["0"], "Output"]
}, Open  ]],

Cell[TextData[{
 "(2)  Option names, and symbolic option values, are recognized by the parent \
function, they don't have their own values.  You must ",
 StyleBox["Block", "Input",
  FontSize->12],
 " the parent function if you want to deactivate it."
}], "Text"],

Cell["\<\
(3)  Patterns are just data types recognized as special by one major \
subsystem of the kernel:  the pattern-matcher.  They don't have values.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Block", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"Pattern", ",", "Blank"}], "}"}], ",", "\[IndentingNewLine]", 
   RowBox[{"Replace", "[", 
    RowBox[{"0", ",", " ", 
     RowBox[{"i_Integer", " ", "\[RuleDelayed]", " ", 
      RowBox[{"Hold", "[", 
       RowBox[{"i", "^", "2"}], "]"}]}]}], "]"}]}], "\[IndentingNewLine]", 
  "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"Hold", "[", 
  SuperscriptBox["0", "2"], "]"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "(4)  ",
 StyleBox["Slot", "Input",
  FontSize->12],
 " variables of ",
 StyleBox["Function", "Input",
  FontSize->12],
 " are again data types given special meaning by their parent function.  \
Neither of these fails, nor should it:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Block", "[", 
  RowBox[{
   RowBox[{"{", "Slot", "}"}], ",", "\[IndentingNewLine]", 
   RowBox[{
    RowBox[{
     RowBox[{"(", 
      RowBox[{"#", " ", "+", " ", "1"}], ")"}], "&"}], " ", "[", "0", "]"}]}],
   "\[IndentingNewLine]", "]"}]], "Input"],

Cell[BoxData["1"], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Block", "[", 
  RowBox[{
   RowBox[{"{", "x", "}"}], ",", "\[IndentingNewLine]", 
   RowBox[{
    RowBox[{"Function", "[", 
     RowBox[{"x", ",", " ", 
      RowBox[{"x", " ", "+", " ", "1"}]}], "]"}], " ", "[", "0", "]"}]}], 
  "\[IndentingNewLine]", "]"}]], "Input"],

Cell[BoxData["1"], "Output"]
}, Open  ]],

Cell[TextData[{
 "But this will make ",
 StyleBox["Function", "Input",
  FontSize->12],
 " a no-op:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Block", "[", 
  RowBox[{
   RowBox[{"{", "Function", "}"}], ",", "\[IndentingNewLine]", 
   RowBox[{"Print", "[", " ", 
    RowBox[{"{", 
     RowBox[{
      RowBox[{
       RowBox[{
        RowBox[{"(", 
         RowBox[{"#", " ", "+", " ", "1"}], ")"}], "&"}], " ", "[", "0", 
       "]"}], ",", " ", 
      RowBox[{
       RowBox[{"Function", "[", 
        RowBox[{"x", ",", " ", 
         RowBox[{"x", " ", "+", " ", "1"}]}], "]"}], " ", "[", "0", "]"}]}], 
     "}"}], " ", "]"}]}], "\[IndentingNewLine]", "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{
    RowBox[{"(", 
     RowBox[{
      RowBox[{"1", "+", "#1"}], "&"}], ")"}], "[", "0", "]"}], ",", 
   RowBox[{
    RowBox[{"Function", "[", 
     RowBox[{"x", ",", 
      RowBox[{"1", "+", "x"}]}], "]"}], "[", "0", "]"}]}], "}"}]], "Print"]
}, Open  ]],

Cell[TextData[{
 "(5)  ",
 StyleBox["Module", "Input",
  FontSize->12],
 " and the rest of the lexical scoping family \"respect\" each other by not \
overwriting each other's local variables (well, ",
 StyleBox["Rule", "Input",
  FontSize->12],
 " and ",
 StyleBox["Set", "Input",
  FontSize->12],
 " do), and by renaming each other's variables if there is potential \
intersection of scope.  You can make ",
 StyleBox["Function", "Input",
  FontSize->12],
 " a no-op, but it will still be respected as a scoping construct by a ",
 StyleBox["With", "Input",
  FontSize->12],
 " that contains it, and thus can have its variables renamed."
}], "Text"],

Cell["Here's the renaming captured:", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"With", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"a", " ", "=", " ", "1"}], "}"}], ",", " ", 
   RowBox[{"HoldForm", "[", " ", 
    RowBox[{
     RowBox[{"Function", "[", 
      RowBox[{"x", ",", " ", 
       RowBox[{"x", " ", "+", " ", "a"}]}], "]"}], "[", "2", "]"}], " ", 
    "]"}]}], " ", "]"}]], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{
   RowBox[{"Function", "[", 
    RowBox[{"x$", ",", 
     RowBox[{"x$", "+", "1"}]}], "]"}], "[", "2", "]"}],
  HoldForm]], "Output"]
}, Open  ]],

Cell[TextData[{
 "Here we prove that ",
 StyleBox["Function", "Input",
  FontSize->12],
 " is a no-op, but renaming still happens."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Block", "[", 
  RowBox[{
   RowBox[{"{", "Function", "}"}], ",", "\[IndentingNewLine]", 
   "\[IndentingNewLine]", 
   RowBox[{"With", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"a", " ", "=", " ", "1"}], "}"}], ",", " ", 
     RowBox[{"Print", "[", " ", 
      RowBox[{
       RowBox[{"Function", "[", 
        RowBox[{"x", ",", " ", 
         RowBox[{"x", " ", "+", " ", "a"}]}], "]"}], "[", "2", "]"}], " ", 
      "]"}]}], " ", "]"}]}], "\[IndentingNewLine]", "\[IndentingNewLine]", 
  "]"}]], "Input"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Function", "[", 
   RowBox[{"x$", ",", 
    RowBox[{"1", "+", "x$"}]}], "]"}], "[", "2", "]"}]], "Print"]
}, Open  ]],

Cell[TextData[{
 "(6)  Miscelleaneous meaningful names without values.\n\nBe careful what you \
deactivate.  If you make ",
 StyleBox["Module", "Input",
  FontSize->12],
 " or ",
 StyleBox["LinkWrite", "Input",
  FontSize->12],
 " or certain other things into no-ops, you might cripple the system."
}], "Text"],

Cell["\<\
You must deactivate the symbol which owns the definitions or rules\
\>", "Text",
 FontSize->16,
 FontWeight->"Bold"],

Cell[TextData[{
 "Sometimes you may guess wrong as to which symbol owns the definitons you \
want to deactivate.  For instance, if you want to disable typeset output in a \
procedure, ",
 StyleBox["Block", "Input",
  FontSize->12],
 "'ing ",
 StyleBox["StandardForm", "Input",
  FontSize->12],
 " will disable few, if any, output forms."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Block", "[", 
  RowBox[{
   RowBox[{"{", "StandardForm", "}"}], ",", " ", 
   RowBox[{"Print", "[", 
    RowBox[{
     RowBox[{"x", "^", "2"}], " ", "-", " ", 
     RowBox[{"y", "/", "3"}]}], "]"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{
  SuperscriptBox["x", "2"], "-", 
  FractionBox["y", "3"]}]], "Print"]
}, Open  ]],

Cell["But this works as you wish:", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Block", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"Plus", ",", " ", "Power", ",", " ", "Times"}], "}"}], ",", " ", 
   RowBox[{"Print", "[", 
    RowBox[{
     RowBox[{"x", "^", "2"}], " ", "-", " ", 
     RowBox[{"y", "/", "3"}]}], "]"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{
  RowBox[{"x", "^", "2"}], "+", 
  RowBox[{
   RowBox[{"-", "1"}], "*", 
   RowBox[{"(", 
    RowBox[{"y", "*", 
     RowBox[{"3", "^", 
      RowBox[{"(", 
       RowBox[{"-", "1"}], ")"}]}]}], ")"}]}]}]], "Print"]
}, Open  ]],

Cell[TextData[{
 "Most formatting rules are associated with individual functions, not with \
types like ",
 StyleBox["OutputForm", "Input",
  FontSize->12],
 " or ",
 StyleBox["StandardForm", "Input",
  FontSize->12],
 ".  There are exceptions; ",
 StyleBox["TraditionalForm", "Input",
  FontSize->12],
 " carries some formatting rules (and has an auto-loading rule attached to \
it)."
}], "Text"],

Cell[TextData[{
 "Another case:  ",
 StyleBox["MessageName", "Input",
  FontSize->12],
 " has only a formatting rule; it's not in charge of issuing messages:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Block", "[", 
  RowBox[{
   RowBox[{"{", "MessageName", "}"}], ",", " ", 
   RowBox[{"1", "/", "0"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{
  RowBox[{"MessageName", "[", 
   RowBox[{"Power", ",", "\<\"infy\"\>"}], "]"}], 
  RowBox[{
  ":", " "}], "\<\"Infinite expression \\!\\(1\\/0\\) encountered.\"\>"}]], \
"Message"],

Cell[BoxData[
 InterpretationBox["ComplexInfinity",
  DirectedInfinity[]]], "Output"]
}, Open  ]],

Cell[TextData[{
 StyleBox["Message", "Input",
  FontSize->12],
 " is in charge of this:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Block", "[", 
  RowBox[{
   RowBox[{"{", "Message", "}"}], ",", " ", 
   RowBox[{"1", "/", "0"}]}], "]"}]], "Input"],

Cell[BoxData[
 InterpretationBox["ComplexInfinity",
  DirectedInfinity[]]], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["Why is MakeBoxes so nasty, I mean HoldAllComplete?", "Subsubsection"],

Cell[TextData[{
 "It's not simply a user function for typesetting.  It's a core part of the \
main loop when the kernel is being run in a front end.  And any expression, \
including ",
 StyleBox["Sequence[1, 2]", "Input",
  FontSize->12],
 " or ",
 StyleBox["Unevaluated[3 + 4]", "Input",
  FontSize->12],
 ", could be the result of an evaluation, assigned to ",
 StyleBox["Out[n]", "Input",
  FontSize->12],
 ".  Even a ",
 StyleBox["HoldAll", "Input",
  FontSize->12],
 " function would flatten ",
 StyleBox["Sequence", "Input",
  FontSize->12],
 " or discard ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 ".\n\nFurthermore, a user could have a universal ",
 StyleBox["UpValue", "Input",
  FontSize->12],
 " such as\n\n",
 StyleBox["  f /: _[fExpr_f, ___] := fExpr", "Input",
  FontSize->12],
 StyleBox["\n\n",
  FontSize->12],
 "She might do this to define some data type that should be \"slippery\", and \
not allow things to act on it, or to make the data type also canonicalize \
itself or alter itself depending on the caller.  In fact, ",
 StyleBox["Sequence", "Input",
  FontSize->12],
 " itself could almost be implemented as a universal ",
 StyleBox["UpValue", "Input",
  FontSize->12],
 " (maybe Dave Withoff or Roman Maeder remembers if that's not quite true).\n \
\nBut it would be a disaster if one of the main components of the main loop \
allowed itself to be rewritten or discarded, such as the output formatter, \
because then this part of the main loop could not complete.\n\nSo that's why \
we needed a few functions able to prevent ",
 StyleBox["any rewrites whatsoever",
  FontSlant->"Italic"],
 " from occurring."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["When to use the different categories of holding stuff?", "Subsubsection"],

Cell[TextData[{
 "Here are some categories of holding methods we've discussed:\n\n(1) ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 "\n\n(2) the ",
 StyleBox["Hold", "Input",
  FontSize->12],
 "* family and ",
 StyleBox["ReleaseHold", "Input",
  FontSize->12],
 "\n\n(3) give my function f some ",
 StyleBox["Hold", "Input",
  FontSize->12],
 "* attribute\n\n(D) ",
 StyleBox["HoldPattern", "Input",
  FontSize->12],
 " is ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 " for patterns, but it can occur at any depth, and no matter where it \
occurs, it is transparent to the pattern matcher.  For purposes of \
pattern-matching, it's as if the HoldPattern wrapper isn't there, yet its \
effect is felt because it prevented evaluation at storage-time of the rule."
}], "Text"],

Cell["\<\


This section isn't very polished, but here are some of my thoughts on when to \
use each.\
\>", "Text"],

Cell[TextData[{
 "(1)  Use ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 " for one-shot passing of unevaluated argument."
}], "Text"],

Cell[TextData[{
 "(2)  Use ",
 StyleBox["Hold", "Input",
  FontSize->12],
 " containers if you need to play with an expression for a while, can't just \
have it sit still for one operation.  Or if you need to ",
 StyleBox["return a value",
  FontSlant->"Italic"],
 " ",
 "unevaluated",
 ".  Anything you return from a function will instantly get fully evaluated, \
so you have to use a protective container."
}], "Text"],

Cell[TextData[{
 "(3)  When your function most of the time needs to operate on held thing.\n\n\
- anything that acts on a symbol itself as a name.  ",
 StyleBox["Context", "Input",
  FontSize->12],
 ", ",
 StyleBox["AppendTo", "Input",
  FontSize->12],
 ", ",
 StyleBox["SetDelayed", "Input",
  FontSize->12],
 ".\n\n- If you're making a programming construct that must establish a \
special environment before executing the body, e.g. scoping of vars, setting \
state vars, turning on logging or tracing, trapping calls to built-ins, etc.  \
Iterators like ",
 StyleBox["Table", "Input",
  FontSize->12],
 " and ",
 StyleBox["Plot", "Input",
  FontSize->12],
 " need to pre-scope the variable.\n\n- When your function is a formatter, \
whose job is simply to print the structure as is for display, speech \
rendering, or whatever.  \.14This applies to tex, typeset, or other output \
forms.\n\n   Another way to think of this is that output formatting is a \
different subsystem from evaluation, so it doesn't recognize the evaluator's \
special flags such as Evaluate and Sequence as anything special."
}], "Text"],

Cell["\<\
Hold vs. HoldComplete (or attribute HoldAll vs. HoldAllComplete)\
\>", "Text",
 FontWeight->"Bold"],

Cell[TextData[{
 "When is ",
 StyleBox["HoldAll", "Input",
  FontSize->12],
 " a strong enough attribute for your function, and when is ",
 StyleBox["HoldAllComplete", "Input",
  FontSize->12],
 " necessary?\n\nUnless your function must treat ",
 StyleBox["Sequence[...]", "Input",
  FontSize->12],
 " and ",
 StyleBox["Evaluate[...]", "Input",
  FontSize->12],
 " as generic expressions with no meaning, or it needs to prevent ",
 StyleBox["UpValues", "Input",
  FontSize->12],
 " of its arguments from firing, then you don't need ",
 StyleBox["HoldAllComplete", "Input",
  FontSize->12],
 "."
}], "Text"],

Cell[TextData[{
 "Ask yourself:  ",
 StyleBox["Why is it compelling",
  FontSlant->"Italic"],
 " for me to override the normal semantics of ",
 StyleBox["Evaluate", "Input",
  FontSize->12],
 " and ",
 StyleBox["Sequence", "Input",
  FontSize->12],
 " and ",
 StyleBox["UpValues", "Input",
  FontSize->12],
 ", to prevent ",
 StyleBox["f[Evaluate[1 + 2]]", "Input",
  FontSize->12],
 " from calling ",
 StyleBox["f[3]", "Input",
  FontSize->12],
 "?\nIt had better be that f almost always wants to consider ",
 StyleBox["Evaluate", "Input",
  FontSize->12],
 " a dumb expression, not something meaningful."
}], "Text"],

Cell[TextData[{
 "Not many functions carry the attribute ",
 StyleBox["HoldAllComplete", "Input",
  FontSize->12],
 ":"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Select", "[", 
  RowBox[{
   RowBox[{"Names", "[", "\"\<System`*\>\"", "]"}], ",", " ", 
   RowBox[{
    RowBox[{"MemberQ", "[", 
     RowBox[{
      RowBox[{"Attributes", " ", "@@", " ", 
       RowBox[{"ToHeldExpression", "[", "#", "]"}]}], ",", " ", 
      "HoldAllComplete"}], "]"}], "&"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"\<\"HoldComplete\"\>", ",", "\<\"InterpretationBox\"\>", 
   ",", "\<\"MakeBoxes\"\>", ",", "\<\"Parenthesize\"\>", 
   ",", "\<\"Unevaluated\"\>"}], "}"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 StyleBox["MakeBoxes", "Input",
  FontSize->12],
 ", and its sibling ",
 StyleBox["Parenthesize", "Input",
  FontSize->12],
 ", must be able to format absolutely any expression for output, as it is a \
critical part of the main loop when a front end is involved.  If the result \
of evaluation is ",
 StyleBox["Sequence[1, 2]", "Input",
  FontSize->12],
 ", or if you display ",
 StyleBox["DownValues[f]", "Input",
  FontSize->12],
 " and a piece of code contains ",
 StyleBox["Evaluate[arg]", "Input",
  FontSize->12],
 ", ",
 StyleBox["MakeBoxes", "Input",
  FontSize->12],
 " ",
 StyleBox["must",
  FontSlant->"Italic"],
 " treat it as a dumb expression."
}], "Text"],

Cell[TextData[{
 StyleBox["Cardinal rule",
  FontWeight->"Bold",
  FontSlant->"Italic"],
 ":  Formatting must never evaluate what it is given.  It should simply \
figure out how to display it, never evaluating any parts."
}], "Text"],

Cell[TextData[{
 "Not many functions are ",
 StyleBox["SequenceHold", "Input",
  FontSize->12],
 ", either:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Select", "[", 
  RowBox[{
   RowBox[{"Names", "[", "\"\<System`*\>\"", "]"}], ",", " ", 
   RowBox[{
    RowBox[{"MemberQ", "[", 
     RowBox[{
      RowBox[{"Attributes", " ", "@@", " ", 
       RowBox[{"ToHeldExpression", "[", "#", "]"}]}], ",", " ", 
      "SequenceHold"}], "]"}], "&"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"\<\"Rule\"\>", ",", "\<\"RuleDelayed\"\>", ",", "\<\"Set\"\>", 
   ",", "\<\"SetDelayed\"\>", ",", "\<\"TagSet\"\>", 
   ",", "\<\"TagSetDelayed\"\>", ",", "\<\"Timing\"\>", ",", "\<\"UpSet\"\>", 
   ",", "\<\"UpSetDelayed\"\>"}], "}"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "Other than the ",
 StyleBox["Rule", "Input",
  FontSize->12],
 "* and *",
 StyleBox["Set", "Input",
  FontSize->12],
 "* family, which need to handle an rhs (right-hand side) of ",
 StyleBox["Sequence[...]", "Input",
  FontSize->12],
 ", there is only one function that prevents flattening of sequences:  ",
 StyleBox["Timing", "Input",
  FontSize->12],
 ".  I don't offhand know why it is more compelling for ",
 StyleBox["Timing", "Input",
  FontSize->12],
 " to handle ",
 StyleBox["Sequence", "Input",
  FontSize->12],
 " input than, say, the ",
 StyleBox["Trace", "Input",
  FontSize->12],
 "* family, so let's ask someone else this question.  In other words, why is \
it more unreasonable to require the user to do ",
 StyleBox["Timing[Unevaluated[Sequence[...]]]", "Input",
  FontSize->12],
 " than to require ",
 StyleBox["Timing[Unevaluated[Sequence[...]]]", "Input",
  FontSize->12],
 "?"
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Myth debunking:  HoldAllComplete isn't some super insulator against the \
parser, against generic structural operations or pattern-finders or the like. \
 It is somewhat more powerful than HoldAll, in four ways, and that's it!\
\>", "Subsubsection"],

Cell[TextData[{
 "A function h with the attribute ",
 StyleBox["HoldAllComplete", "Input",
  FontSize->12],
 ", such as ",
 StyleBox["HoldComplete", "Input",
  FontSize->12],
 ", is only slightly stronger than one with the ",
 StyleBox["HoldAll", "Input",
  FontSize->12],
 " attribute, despite its reputation as some super insulator that prevents \
anything from happening inside it.  The differences are for arguments at \
level 1 of h[...]:\n\n(1)  ",
 StyleBox["Sequence", "Input",
  FontSize->12],
 " won't be flattened\n\n(2)  ",
 StyleBox["Evaluate", "Input",
  FontSize->12],
 " won't cause evaluation.\n\n(3)  ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 " won't be discarded before the argument is fed to a definition.\n\n(4)  \
g[...] won't cause an ",
 StyleBox["UpValue", "Input",
  FontSize->12],
 " for g to fire even if the rule matches."
}], "Text"],

Cell[TextData[{
 StyleBox["\[HappySmiley]",
  FontSize->24,
  FontColor->RGBColor[1, 0, 1]],
 "  Hence, you can modify or analyze held expressions with all the familiar \
functional and other commands, e.g. ",
 StyleBox["Map, ReplaceAll, FlattenAt, DeleteCases, Count", "Input",
  FontSize->12],
 ", whatever you want."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Argument evaluation precedes {Listable, Orderless, Flat, ...}, and any other \
structure-rewriting attributes.\
\>", "Subsubsection"],

Cell[TextData[{
 "Thus, if you make nested ",
 StyleBox["Dot", "Input",
  FontSize->12],
 " calls on actual matrices, the grouping you specified will be respected, \
even though ",
 StyleBox["Dot", "Input",
  FontSize->12],
 " carries the attribute ",
 StyleBox["Flat", "Input",
  FontSize->12],
 ".  You might think it would not because if you evaluate it for abstract \
symbolic arguments, it is treated as if it's associative:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Dot", "[", 
  RowBox[{
   RowBox[{"Dot", "[", 
    RowBox[{"A", ",", " ", 
     RowBox[{"Dot", "[", 
      RowBox[{"B", ",", " ", "C"}], "]"}]}], "]"}], ",", " ", 
   RowBox[{"Dot", "[", 
    RowBox[{"D", ",", " ", "B"}], "]"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"A", ".", "B", ".", "C", ".", "D", ".", "B"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "But if the symbols are actual matrices, then the innermost ",
 StyleBox["Dot", "Input",
  FontSize->12],
 "'s will evaluate fully before the outer ",
 StyleBox["Dot", "Input",
  FontSize->12],
 " acts, so it will work fine."
}], "Text"],

Cell[TextData[{
 "In some cases, you want a function to invoke attributes on the original \
form of the arguments, not on the post-evaluated arguments.  You do that \
simply by adding ",
 StyleBox["HoldAll", "Input",
  FontSize->12],
 " to the attributes:"
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"Attributes", "[", "f", "]"}], " ", "=", " ", 
   RowBox[{"{", "Flat", "}"}]}], ";"}]], "Input"],

Cell[BoxData[
 RowBox[{
  RowBox[{"SetAttributes", "[", 
   RowBox[{"f", ",", " ", "HoldAll"}], "]"}], ";"}]], "Input"],

Cell[BoxData[
 RowBox[{
  RowBox[{"f", "[", "whatever", "]"}], " ", ":=", " ", "whatever"}]], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Wrapping an argument in Unevaluated does NOT prevent that argument's head \
from exercising its UpValues!\
\>", "Subsubsection"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"ClearAll", "[", "\"\<a\>\"", "]"}], ";"}], "\n", 
 RowBox[{"a", " ", "/:", " ", 
  RowBox[{"_", "[", 
   RowBox[{"___", ",", " ", "a", ",", " ", "___"}], "]"}], " ", ":=", " ", 
  RowBox[{"(", 
   RowBox[{
    RowBox[{"Print", "[", "\"\<a fired\>\"", "]"}], ";", " ", "Null"}], 
   ")"}]}]}], "Input"],

Cell[BoxData[
 RowBox[{
  RowBox[{"f", "[", "x_", "]"}], " ", ":=", " ", 
  RowBox[{"HoldComplete", "[", "x", "]"}]}]], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"f", "[", "a", "]"}]], "Input"],

Cell[BoxData["\<\"a fired\"\>"], "Print"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"f", "[", 
  RowBox[{"Unevaluated", "[", "a", "]"}], "]"}]], "Input"],

Cell[BoxData["\<\"a fired\"\>"], "Print"]
}, Open  ]],

Cell[TextData[{
 "The reason is that ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 " simply ensures that the symbol 'a' is passed to f in original form, then \
",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 " disappears.  "
}], "Text"],

Cell["\<\
So how do you assign new values to it?  Set and Unset and family don't work:\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"a", " ", "=."}]], "Input"],

Cell[BoxData["\<\"a fired\"\>"], "Print"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"a", " ", "=", " ", "0"}], ";"}]], "Input"],

Cell[BoxData["\<\"a fired\"\>"], "Print"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"?", " ", "a"}]], "Input"],

Cell[BoxData["\<\"a fired\"\>"], "Print"],

Cell[BoxData["\<\"Global`a\"\>"], "Print"],

Cell[BoxData[
 InterpretationBox[GridBox[{
    {GridBox[{
       {
        RowBox[{
         RowBox[{"_", "[", 
          RowBox[{"___", ",", "a", ",", "___"}], "]"}], "^:=", 
         RowBox[{"(", 
          RowBox[{
           RowBox[{"Print", "[", "\<\"a fired\"\>", "]"}], ";"}], ")"}]}]}
      },
      BaselinePosition->{Baseline, {1, 1}},
      GridBoxAlignment->{
       "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
        "RowsIndexed" -> {}},
      GridBoxItemSize->{"Columns" -> {{
           Scaled[0.999]}}, "ColumnsIndexed" -> {}, "Rows" -> {{1.}}, 
        "RowsIndexed" -> {}}]}
   },
   BaselinePosition->{Baseline, {1, 1}},
   GridBoxAlignment->{
    "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
     "RowsIndexed" -> {}}],
  Definition[a],
  Editable->False]], "Print"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"TagUnset", "[", 
  RowBox[{
   RowBox[{"Unevaluated", "[", "a", "]"}], ",", "\[IndentingNewLine]", 
   RowBox[{"HoldPattern", "[", 
    RowBox[{"HoldPattern", "[", "\[IndentingNewLine]", 
     RowBox[{"_", "[", 
      RowBox[{"___", ",", " ", "a", ",", " ", "___"}], "]"}], 
     "\[IndentingNewLine]", "]"}], "]"}]}], "]"}]], "Input"],

Cell[BoxData["\<\"a fired\"\>"], "Print"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"??", " ", "a"}]], "Input"],

Cell[BoxData["\<\"a fired\"\>"], "Print"],

Cell[BoxData["\<\"Global`a\"\>"], "Print"],

Cell[BoxData[
 InterpretationBox[GridBox[{
    {GridBox[{
       {
        RowBox[{
         RowBox[{"_", "[", 
          RowBox[{"___", ",", "a", ",", "___"}], "]"}], "^:=", 
         RowBox[{"(", 
          RowBox[{
           RowBox[{"Print", "[", "\<\"a fired\"\>", "]"}], ";"}], ")"}]}]}
      },
      BaselinePosition->{Baseline, {1, 1}},
      GridBoxAlignment->{
       "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
        "RowsIndexed" -> {}},
      GridBoxItemSize->{"Columns" -> {{
           Scaled[0.999]}}, "ColumnsIndexed" -> {}, "Rows" -> {{1.}}, 
        "RowsIndexed" -> {}}]}
   },
   BaselinePosition->{Baseline, {1, 1}},
   GridBoxAlignment->{
    "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
     "RowsIndexed" -> {}}],
  Definition[a],
  Editable->False]], "Print"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"HoldPattern", " ", "@", " ", 
   RowBox[{"HoldPattern", "[", "a", "]"}]}], " ", "=", " ", "0"}]], "Input"],

Cell[BoxData["0"], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"?", " ", "a"}]], "Input"],

Cell[BoxData["\<\"a fired\"\>"], "Print"],

Cell[BoxData["\<\"Global`a\"\>"], "Print"],

Cell[BoxData[
 InterpretationBox[GridBox[{
    {GridBox[{
       {
        RowBox[{
         RowBox[{"HoldPattern", "[", 
          RowBox[{"HoldPattern", "[", "a", "]"}], "]"}], "=", "0"}]}
      },
      BaselinePosition->{Baseline, {1, 1}},
      GridBoxAlignment->{
       "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
        "RowsIndexed" -> {}},
      GridBoxItemSize->{"Columns" -> {{
           Scaled[0.999]}}, "ColumnsIndexed" -> {}, "Rows" -> {{1.}}, 
        "RowsIndexed" -> {}}]},
    {" "},
    {GridBox[{
       {
        RowBox[{
         RowBox[{"_", "[", 
          RowBox[{"___", ",", "a", ",", "___"}], "]"}], "^:=", 
         RowBox[{"(", 
          RowBox[{
           RowBox[{"Print", "[", "\<\"a fired\"\>", "]"}], ";"}], ")"}]}]}
      },
      BaselinePosition->{Baseline, {1, 1}},
      GridBoxAlignment->{
       "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
        "RowsIndexed" -> {}},
      GridBoxItemSize->{"Columns" -> {{
           Scaled[0.999]}}, "ColumnsIndexed" -> {}, "Rows" -> {{1.}}, 
        "RowsIndexed" -> {}}]}
   },
   BaselinePosition->{Baseline, {1, 1}},
   GridBoxAlignment->{
    "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
     "RowsIndexed" -> {}}],
  Definition[a],
  Editable->False]], "Print"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Print", " ", "@", " ", 
  RowBox[{"Unevaluated", " ", "@", " ", 
   RowBox[{"Definition", "[", "a", "]"}]}]}]], "Input"],

Cell[BoxData[
 InterpretationBox[GridBox[{
    {GridBox[{
       {
        RowBox[{
         RowBox[{"_", "[", 
          RowBox[{"___", ",", "a", ",", "___"}], "]"}], "^:=", 
         RowBox[{"(", 
          RowBox[{
           RowBox[{"Print", "[", "\<\"a fired\"\>", "]"}], ";"}], ")"}]}]}
      },
      BaselinePosition->{Baseline, {1, 1}},
      GridBoxAlignment->{
       "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
        "RowsIndexed" -> {}},
      GridBoxItemSize->{"Columns" -> {{
           Scaled[0.999]}}, "ColumnsIndexed" -> {}, "Rows" -> {{1.}}, 
        "RowsIndexed" -> {}}]}
   },
   BaselinePosition->{Baseline, {1, 1}},
   GridBoxAlignment->{
    "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
     "RowsIndexed" -> {}}],
  Definition[a],
  Editable->False]], "Print"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Print", " ", "@", " ", 
  RowBox[{"Unevaluated", " ", "@", " ", 
   RowBox[{"FullDefinition", "[", "a", "]"}]}]}]], "Input"],

Cell[BoxData[
 InterpretationBox[GridBox[{
    {GridBox[{
       {GridBox[{
          {
           RowBox[{
            RowBox[{"_", "[", 
             RowBox[{"___", ",", "a", ",", "___"}], "]"}], "^:=", 
            RowBox[{"(", 
             RowBox[{
              RowBox[{"Print", "[", "\<\"a fired\"\>", "]"}], ";"}], ")"}]}]}
         },
         BaselinePosition->{Baseline, {1, 1}},
         GridBoxAlignment->{
          "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, 
           "Rows" -> {{Baseline}}, "RowsIndexed" -> {}},
         GridBoxItemSize->{"Columns" -> {{
              Scaled[0.999]}}, "ColumnsIndexed" -> {}, "Rows" -> {{1.}}, 
           "RowsIndexed" -> {}}]}
      },
      BaselinePosition->{Baseline, {1, 1}},
      GridBoxAlignment->{
       "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
        "RowsIndexed" -> {}}]}
   },
   BaselinePosition->{Baseline, {1, 1}},
   GridBoxAlignment->{
    "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
     "RowsIndexed" -> {}}],
  FullDefinition[a],
  Editable->False]], "Print"]
}, Open  ]],

Cell["This is a puzzle for the reader.", "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
\"Non-standard Evaluation\":  That unexplained complicated thing.\
\>", "Subsubsection"],

Cell["Listing of types of special evaluation", "Text",
 FontSize->16,
 FontWeight->"Bold"],

Cell["There are different categories of  non-standard evaluation.", "Text"],

Cell[TextData[{
 "(1)  ",
 StyleBox["Left-hand side of ",
  FontVariations->{"Underline"->True}],
 StyleBox["assignments",
  FontSlant->"Italic",
  FontVariations->{"Underline"->True}],
 " (NOT ",
 StyleBox["rules",
  FontSlant->"Italic"],
 "!) \[Element] {*",
 StyleBox["Set", "Input",
  FontSize->12],
 "* and *",
 StyleBox["SetDelayed", "Input",
  FontSize->12],
 "* family, ",
 StyleBox["AddTo", "Input",
  FontSize->12],
 " & ",
 StyleBox["SubtractFrom", "Input",
  FontSize->12],
 " & ",
 StyleBox["TimesBy", "Input",
  FontSize->12],
 " & ",
 StyleBox["DivideBy", "Input",
  FontSize->12],
 ", ",
 StyleBox["AppendTo", "Input",
  FontSize->12],
 ", ",
 StyleBox["PrependTo", "Input",
  FontSize->12],
 "}.  Hopefully this is a complete listing of destructive functions in ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ".\n",
 StyleBox["How they are special",
  FontVariations->{"Underline"->True}],
 ":  They evaluate head and args, but don't let head ",
 StyleBox["act on",
  FontSlant->"Italic"],
 " args.  Of course, if head is a holding container, then args won't even \
evaluate, so this is consistent with evaluating ordinary expressions.  You \
could just about simulate what the partially evaluated lhs will be in the \
stored assignment:"
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"H", "[", 
   RowBox[{"e1", ",", " ", "\[Ellipsis]", ",", " ", "en"}], "]"}], " ", ":=", 
  " ", "rhs"}]], "Input"],

Cell["\<\
by evaluating the head and args separately, then sticking them into a template\
\>", "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"HoldComplete", "[", " ", 
    RowBox[{"#1", "[", "##2", "]"}], " ", "]"}], "&"}], " ", "[", 
  RowBox[{"H", ",", " ", "e1", ",", " ", "\[Ellipsis]", ",", " ", "en"}], 
  "]"}]], "Input"],

Cell[TextData[{
 "(2)  ",
 StyleBox["Iterators",
  FontVariations->{"Underline"->True}],
 " \[Element] {",
 StyleBox["Table", "Input",
  FontSize->12],
 " & ",
 StyleBox["Do", "Input",
  FontSize->12],
 " & ",
 StyleBox["While", "Input",
  FontSize->12],
 " & ",
 StyleBox["For", "Input",
  FontSize->12],
 ", ",
 StyleBox["Sum", "Input",
  FontSize->12],
 " & ",
 StyleBox["Product", "Input",
  FontSize->12],
 ", ",
 StyleBox["Plot", "Input",
  FontSize->12],
 " and ",
 StyleBox["Play", "Input",
  FontSize->12],
 " family},\nbut NOT functional iterators or recursors {",
 StyleBox["Nest", "Input",
  FontSize->12],
 " and ",
 StyleBox["Fold", "Input",
  FontSize->12],
 " family, ",
 StyleBox["Array", "Input",
  FontSize->12],
 ", ",
 StyleBox["Map", "Input",
  FontSize->12],
 " and its many related things)\n",
 StyleBox["How they are special",
  FontVariations->{"Underline"->True}],
 ":  They dynamically scope the iterator variables (found in rgs 2 and \
beyond) then evaluate the iterand (arg 1) for all values of the iterators in \
sequence."
}], "Text"],

Cell[TextData[{
 "(3)  ",
 StyleBox["Misc. control structures",
  FontVariations->{"Underline"->True}],
 ":  {",
 StyleBox["And, Or, If, Which, Switch", "Input",
  FontSize->12],
 ")\n",
 StyleBox["How they are special",
  FontVariations->{"Underline"->True}],
 ":  They basically go from left to right, but don't necessarily evaluate all \
arguments.  In fact, except for the short-circuit ",
 StyleBox["And", "Input",
  FontSize->12],
 " and ",
 StyleBox["Or", "Input",
  FontSize->12],
 ", they are guaranteed not to evaluate all args if there are two or more \
branches (a single branch would be a degenerate case for ",
 StyleBox["If", "Input",
  FontSize->12],
 ", ",
 StyleBox["Which", "Input",
  FontSize->12],
 ", and ",
 StyleBox["Switch", "Input",
  FontSize->12],
 ")."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Switch", "[", 
  RowBox[{"0", ",", "\[IndentingNewLine]", "_String", ",", " ", 
   RowBox[{"Print", "[", "\"\<String\>\"", "]"}], ",", "\[IndentingNewLine]", 
   "_Symbol", ",", " ", 
   RowBox[{"Print", "[", "\"\<Symbol\>\"", "]"}], ",", "\[IndentingNewLine]", 
   "_Integer", ",", " ", 
   RowBox[{"Print", "[", "\"\<Integer\>\"", "]"}]}], "\[IndentingNewLine]", 
  "]"}]], "Input"],

Cell[BoxData["\<\"Integer\"\>"], "Print"]
}, Open  ]],

Cell[TextData[{
 "(4)  ",
 StyleBox["Scoping constructs",
  FontVariations->{"Underline"->True}],
 ":  ",
 StyleBox["Module, With, Block, Function, Compile, Condition", "Input",
  FontSize->12],
 " (of course, the *",
 StyleBox["Rule", "Input",
  FontSize->12],
 "* and *",
 StyleBox["Set", "Input",
  FontSize->12],
 "* family are scoping constructs, too, but when categorizing things \
according to uneval'n behavior, they don't belong in this category).\n",
 StyleBox["How they are special",
  FontVariations->{"Underline"->True}],
 ":  \n\n",
 StyleBox["Short Version",
  FontVariations->{"Underline"->True}],
 ":\n- Evaluate initializations of localvars\n- Perform actual scoping of \
declared local vars by either temporarily forgetting their own values \
(dynamic scoping) or by marking their occurrences in unevaluated body.\n- \
Evaluate body (either with its fixed set of markings, known as static \
scoping; or with no markings cuz original symbols are being used simply with \
new values, known as dynamic scoping)"
}], "Text"],

Cell[TextData[{
 "(5)  Miscellaneous:\n\nMany others query or modify their argument, like ",
 StyleBox["Context", "Input",
  FontSize->12],
 " and ",
 StyleBox["Protect", "Input",
  FontSize->12],
 ", which act on symbols.  Nothing special; they just need to receive the \
symbol intact in case it has a value.\n\nSome things set up a special \
environment, such as the ",
 StyleBox["Trace", "Input",
  FontSize->12],
 "* and ",
 StyleBox["Stack", "Input",
  FontSize->12],
 "* family, which turn on extra logging info."
}], "Text"],

Cell["\<\



\
\>", "Text"],

Cell[TextData[{
 StyleBox["Long Version",
  FontVariations->{"Underline"->True}],
 ":\nFirst they look at the local variable declaration.  If there are any \
initializations, they evaluate those, in the outside scope.\nThen they \
\"perform localization\" of the declared local vars.\nFinally they evaluate \
the body with this localization \"in effect\"."
}], "Text"],

Cell[BoxData[
 RowBox[{"ScopingConstruct", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{
     RowBox[{"v1", " ", "=", " ", "a1"}], ",", " ", "\[Ellipsis]", ",", " ", 
     RowBox[{"vn", " ", "=", " ", "an"}]}], "}"}], ",", "\[IndentingNewLine]",
    "body"}], "\[IndentingNewLine]", "]"}]], "Input"],

Cell[TextData[{
 "\"perform localization\":\n\n- ",
 StyleBox["Block", "Input",
  FontSize->12],
 " simply saves the original values of the specified symbols then clears \
them.\n\n- All the others, which are static scopers, take each local variable \
x, scan the unevaluated body for occurrences of x that are owned by this \
scoping construct, and mark them.  In the case of ",
 StyleBox["Module", "Input",
  FontSize->12],
 ", the marking is visible at top-level:  x is replaced by a new, unique \
symbol x$n.  In the others, ",
 StyleBox["the marking stage cannot be captured on film",
  FontSlant->"Italic"],
 "!"
}], "Text"],

Cell[TextData[{
 "\"in effect\":\n\n  - For ",
 StyleBox["Block", "Input",
  FontSize->12],
 ", the symbols you specified simply have temporary amnesia.  The body is \
executed in an environment where any time these symbols arise in the \
computation, whether they were originally in the text of ",
 StyleBox["body",
  FontSlant->"Italic"],
 "'s code or not, they'll have the temporary values (or lack of values).\n  \n\
  - For static scopers, the unevaluated ",
 StyleBox["body",
  FontSlant->"Italic"],
 " has already had all owned instances marked.  In the case of ",
 StyleBox["Module", "Input",
  FontSize->12],
 ", the dummy symbols will get evaluated when the evaluator reaches them \
[their turn comes up].  In the others, they do instant substitution, ",
 StyleBox["ReplaceAll", "Input",
  FontSize->12],
 "-style (forgetting different levels of scoping respect, please), on the \
body before evaluating, so the \"temporary variables\" are too ephemeral for \
top-level film capture (unless withoff or bruce knows some method I don't)."
}], "Text"],

Cell["Generating list of built-in funcs with Hold attributes", "Text",
 FontSize->16,
 FontWeight->"Bold"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"mappings", " ", "=", " ", 
   RowBox[{"Cases", "[", 
    RowBox[{
     RowBox[{"Names", "[", "\"\<System`*\>\"", "]"}], ",", 
     "\[IndentingNewLine]", 
     RowBox[{"symName_String", " ", "\[RuleDelayed]", " ", 
      RowBox[{"With", "[", 
       RowBox[{
        RowBox[{"{", 
         RowBox[{"holdAttrs", " ", "=", " ", 
          RowBox[{"Select", "[", 
           RowBox[{
            RowBox[{"Attributes", " ", "@@", " ", 
             RowBox[{"ToHeldExpression", "[", "symName", "]"}]}], ",", " ", 
            RowBox[{
             RowBox[{"StringMatchQ", "[", 
              RowBox[{
               RowBox[{"ToString", "[", "#", "]"}], ",", " ", 
               "\"\<*Hold*\>\""}], "]"}], "&"}]}], "]"}]}], "}"}], ",", " ", 
        RowBox[{
         RowBox[{"(", 
          RowBox[{
           RowBox[{"Symbol", "[", "symName", "]"}], " ", "\[Rule]", " ", 
           "holdAttrs"}], ")"}], " ", "/;", " ", 
         RowBox[{"holdAttrs", " ", "=!=", " ", 
          RowBox[{"{", "}"}]}]}]}], "]"}]}]}], "\[IndentingNewLine]", "]"}]}],
   ";"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"{", 
    RowBox[{"funcsWithHoldAttrs", ",", " ", "holdAttrs"}], "}"}], " ", "=", 
   " ", 
   RowBox[{
    RowBox[{
     RowBox[{"{", 
      RowBox[{
       RowBox[{"Identity", "[", "#1", "]"}], ",", " ", 
       RowBox[{"Union", " ", "@@", " ", "#2"}]}], "}"}], "&"}], " ", "@@", 
    " ", 
    RowBox[{"Thread", "[", 
     RowBox[{"mappings", ",", " ", "Rule"}], "]"}]}]}], ";"}]}], "Input"],

Cell[CellGroupData[{

Cell[BoxData["holdAttrs"], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
  "HoldAll", ",", "HoldAllComplete", ",", "HoldFirst", ",", "HoldRest", ",", 
   "NHoldAll", ",", "NHoldFirst", ",", "NHoldRest", ",", "SequenceHold"}], 
  "}"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"ordinaryHoldFuncs", " ", "=", " ", 
  RowBox[{"First", " ", "/@", " ", 
   RowBox[{"Select", "[", 
    RowBox[{"mappings", ",", "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"MemberQ", "[", 
       RowBox[{
        RowBox[{"#", "\[LeftDoubleBracket]", "2", "\[RightDoubleBracket]"}], 
        ",", " ", 
        RowBox[{
        "HoldAll", " ", "|", " ", "HoldAllComplete", " ", "|", " ", 
         "HoldFirst", " ", "|", " ", "HoldRest", " ", "|", " ", 
         "SequenceHold"}]}], "]"}], "&"}]}], "]"}]}]}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
  "AbortProtect", ",", "AddTo", ",", "Alias", ",", "And", ",", "AppendTo", 
   ",", "Attributes", ",", "Block", ",", "Catch", ",", "Check", ",", 
   "CheckAbort", ",", "CheckAll", ",", "Clear", ",", "ClearAll", ",", 
   "ClearAttributes", ",", "Compile", ",", "CompiledFunction", ",", 
   "CompoundExpression", ",", "Condition", ",", "ConsoleMessage", ",", 
   "ConsolePrint", ",", "Context", ",", "ContourPlot", ",", "Debug", ",", 
   "Decrement", ",", "DefaultValues", ",", "Definition", ",", "DensityPlot", 
   ",", "Dialog", ",", "DivideBy", ",", "Do", ",", "DownValues", ",", 
   "DumpSave", ",", "EditDefinition", ",", "Exists", ",", "FileName", ",", 
   "FindMinimum", ",", "FindRoot", ",", "For", ",", "ForAll", ",", 
   "FormatValues", ",", "FullDefinition", ",", "Function", ",", 
   "FunctionInterpolation", ",", "Hold", ",", "HoldComplete", ",", "HoldForm",
    ",", "HoldPattern", ",", "If", ",", "Increment", ",", "Information", ",", 
   "InterpretationBox", ",", "Literal", ",", "MakeBoxes", ",", 
   "MatchLocalNameQ", ",", "MemoryConstrained", ",", "Message", ",", 
   "MessageName", ",", "MessagePacket", ",", "Messages", ",", "Module", ",", 
   "NIntegrate", ",", "NProduct", ",", "NSum", ",", "NValues", ",", "Off", 
   ",", "On", ",", "Or", ",", "OwnValues", ",", "ParametricPlot", ",", 
   "ParametricPlot3D", ",", "Parenthesize", ",", "Pattern", ",", 
   "PatternTest", ",", "Play", ",", "Plot", ",", "Plot3D", ",", 
   "PreDecrement", ",", "PreIncrement", ",", "PrependTo", ",", "Product", ",",
    "Protect", ",", "Remove", ",", "Rule", ",", "RuleCondition", ",", 
   "RuleDelayed", ",", "SampledSoundFunction", ",", "Save", ",", "Set", ",", 
   "SetAttributes", ",", "SetDelayed", ",", "Stack", ",", "StackBegin", ",", 
   "StackComplete", ",", "StackInhibit", ",", "SubtractFrom", ",", 
   "SubValues", ",", "Sum", ",", "Switch", ",", "Table", ",", "TagSet", ",", 
   "TagSetDelayed", ",", "TagUnset", ",", "TimeConstrained", ",", "TimesBy", 
   ",", "Timing", ",", "Trace", ",", "TraceDialog", ",", "TracePrint", ",", 
   "TraceScan", ",", "UnAlias", ",", "Unevaluated", ",", "Unprotect", ",", 
   "Unset", ",", "UpSet", ",", "UpSetDelayed", ",", "UpValues", ",", "ValueQ",
    ",", "Which", ",", "While", ",", "With", ",", "$ConditionHold", ",", 
   "$Failed"}], "}"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"nHoldFuncs", " ", "=", " ", 
  RowBox[{"First", " ", "/@", " ", 
   RowBox[{"Select", "[", 
    RowBox[{"mappings", ",", "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"MemberQ", "[", 
       RowBox[{
        RowBox[{"#", "\[LeftDoubleBracket]", "2", "\[RightDoubleBracket]"}], 
        ",", " ", 
        RowBox[{
        "NHoldAll", " ", "|", " ", "NHoldFirst", " ", "|", " ", 
         "NHoldRest"}]}], "]"}], "&"}]}], "]"}]}]}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
  "Drop", ",", "EllipticTheta", ",", "EllipticThetaPrime", ",", "Extract", 
   ",", "HeldPart", ",", "MathieuC", ",", "MathieuCharacteristicA", ",", 
   "MathieuCharacteristicB", ",", "MathieuCPrime", ",", "MathieuS", ",", 
   "MathieuSPrime", ",", "Part", ",", "PolyGamma", ",", "Root", ",", 
   "StieltjesGamma", ",", "Take"}], "}"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Select", "[", 
  RowBox[{
   RowBox[{"Names", "[", "\"\<System`*\>\"", "]"}], ",", " ", 
   RowBox[{
    RowBox[{"MemberQ", "[", 
     RowBox[{
      RowBox[{"ToExpression", "[", 
       RowBox[{"#", ",", " ", "InputForm", ",", " ", "Attributes"}], "]"}], 
      ",", " ", 
      RowBox[{
      "NHoldAll", " ", "|", " ", "NHoldFirst", " ", "|", " ", "NHoldRest"}]}],
      "]"}], "&"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"\<\"Drop\"\>", ",", "\<\"EllipticTheta\"\>", 
   ",", "\<\"EllipticThetaPrime\"\>", ",", "\<\"Extract\"\>", 
   ",", "\<\"HeldPart\"\>", ",", "\<\"MathieuC\"\>", 
   ",", "\<\"MathieuCharacteristicA\"\>", 
   ",", "\<\"MathieuCharacteristicB\"\>", ",", "\<\"MathieuCPrime\"\>", 
   ",", "\<\"MathieuS\"\>", ",", "\<\"MathieuSPrime\"\>", ",", "\<\"Part\"\>",
    ",", "\<\"PolyGamma\"\>", ",", "\<\"Root\"\>", 
   ",", "\<\"StieltjesGamma\"\>", ",", "\<\"Take\"\>"}], "}"}]], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
 "Always anticipate that users might send Unevaluated arguments into your \
function!\n",
 StyleBox["\"Add a mental red flag to your programming habits\"",
  FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
Here I'm referring to any uses you make of the arguments passed to your \
function.  Take this:\
\>", "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"FindThem", "[", 
   RowBox[{"expr_", ",", " ", "patt_", ",", " ", "opts___"}], "]"}], " ", ":=",
   "\[IndentingNewLine]", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", "...", "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{
      RowBox[{"Cases", "[", 
       RowBox[{
        RowBox[{"Unevaluated", "[", "expr", "]"}], ",", " ", 
        RowBox[{"Unevaluated", "[", "patt", "]"}]}], "]"}], ";"}], 
     "\[IndentingNewLine]", "..."}]}], "\[IndentingNewLine]", 
   "]"}]}]], "Input"],

Cell[TextData[{
 "If you want your function to \"respect\" ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 " as specified by the user, you have to wrap every instance of your pattern \
variables (in the example above, those are ",
 StyleBox["expr", "Input",
  FontSize->12],
 ", ",
 StyleBox["patt", "Input",
  FontSize->12],
 ", and ",
 StyleBox["opts", "Input",
  FontSize->12],
 ") in ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 " when you pass it on to some built-in function (or even another top-level \
function).\n\nOtherwise, the arguments carefully protected by the user will \
get evaluated when you operate on them.  I call these ",
 StyleBox["evaluation leaks",
  FontVariations->{"Underline"->True}],
 ", and they're very important to avoid in typesetting or code analysis tools."
}], "Text"],

Cell["\<\
Let's say you write a function to insert a given expression between every \
consecutive pair of elements in another expression.  Here's one way you might \
write it:\
\>", "Text"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"(*", " ", 
   RowBox[{"First", " ", "version"}], " ", "*)"}], "\[IndentingNewLine]", 
  RowBox[{"Clear", "[", "Intercalate", "]"}]}], "\n", 
 RowBox[{
  RowBox[{"Intercalate", "[", 
   RowBox[{"list_", ",", "object_"}], "]"}], ":=", 
  RowBox[{"Insert", "[", 
   RowBox[{"list", ",", " ", "object", ",", " ", 
    RowBox[{"List", "/@", 
     RowBox[{"Range", "[", 
      RowBox[{"2", ",", 
       RowBox[{"Length", "[", "list", "]"}]}], "]"}]}]}], "]"}]}]}], "Input"],

Cell["Works fine for \"ordinary\" expressions:", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Intercalate", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"1", ",", " ", "2", ",", " ", "3"}], "}"}], ",", " ", "x"}], 
  "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"1", ",", "x", ",", "2", ",", "x", ",", "3"}], "}"}]], "Output"]
}, Open  ]],

Cell["But not for unevaluated stuff:", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Intercalate", "[", 
  RowBox[{
   RowBox[{"Hold", "[", 
    RowBox[{"1", ",", " ", "2", ",", " ", "3"}], "]"}], ",", " ", 
   RowBox[{"Unevaluated", " ", "@", " ", 
    RowBox[{"Print", "[", "4", "]"}]}]}], "]"}]], "Input"],

Cell[BoxData["4"], "Print"],

Cell[BoxData[
 RowBox[{"Hold", "[", 
  RowBox[{"1", ",", "Null", ",", "2", ",", "Null", ",", "3"}], 
  "]"}]], "Output"]
}, Open  ]],

Cell["\<\
So here's another implementation that tries to keep the elements unevaluated \
until the end:\
\>", "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"(*", " ", 
   RowBox[{"Second", " ", "version"}], " ", "*)"}], "\[IndentingNewLine]", 
  RowBox[{
   RowBox[{"Intercalate", "[", 
    RowBox[{"list_", ",", "object_"}], "]"}], ":=", 
   RowBox[{"Insert", "[", 
    RowBox[{"list", ",", " ", 
     RowBox[{"Unevaluated", "[", "object", "]"}], ",", " ", 
     RowBox[{"List", "/@", 
      RowBox[{"Range", "[", 
       RowBox[{"2", ",", 
        RowBox[{"Length", "[", "list", "]"}]}], "]"}]}]}], "]"}]}]}]], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Intercalate", "[", 
  RowBox[{
   RowBox[{"Hold", "[", 
    RowBox[{"1", ",", " ", "2", ",", " ", "3"}], "]"}], ",", " ", 
   RowBox[{"Unevaluated", " ", "@", " ", 
    RowBox[{"Print", "[", "4", "]"}]}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"Hold", "[", 
  RowBox[{"1", ",", 
   RowBox[{"Print", "[", "4", "]"}], ",", "2", ",", 
   RowBox[{"Print", "[", "4", "]"}], ",", "3"}], "]"}]], "Output"]
}, Open  ]],

Cell["\<\
But it doesn't work if the first argument is an unevaluated expression:\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Intercalate", "[", 
  RowBox[{
   RowBox[{"Unevaluated", "[", 
    RowBox[{"2", " ", "*", " ", "3", " ", "*", " ", "4"}], "]"}], ",", " ", 
   "x"}], "]"}]], "Input"],

Cell[BoxData["24"], "Output"]
}, Open  ]],

Cell[TextData[{
 "From ",
 StyleBox["Times[2, 3, 4]", "Input",
  FontSize->12],
 ", it should have produced ",
 StyleBox["Times[2, x, 3, x, 4]", "Input",
  FontSize->12],
 ", i.e. ",
 StyleBox["24 x^2", "Input",
  FontSize->12],
 ", but the ",
 StyleBox["Times[2, 3, 4]", "Input",
  FontSize->12],
 " collapsed to 24 too soon."
}], "Text"],

Cell[TextData[{
 "Looking back at our code, we realize that we forgot to wrap all our uses of \
",
 StyleBox["list", "Input",
  FontSize->12],
 " in ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 ":"
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"(*", " ", 
   RowBox[{"Third", " ", "version"}], " ", "*)"}], "\[IndentingNewLine]", 
  RowBox[{
   RowBox[{"Intercalate", "[", 
    RowBox[{"list_", ",", "object_"}], "]"}], ":=", "\[IndentingNewLine]", 
   RowBox[{"Insert", "[", 
    RowBox[{
     RowBox[{"Unevaluated", "[", "list", "]"}], ",", "\[IndentingNewLine]", 
     RowBox[{"Unevaluated", "[", "object", "]"}], ",", "\[IndentingNewLine]", 
     
     RowBox[{"List", " ", "/@", " ", 
      RowBox[{"Range", "[", 
       RowBox[{"2", ",", 
        RowBox[{"Length", " ", "@", " ", 
         RowBox[{"Unevaluated", "[", "list", "]"}]}]}], "]"}]}]}], 
    "\[IndentingNewLine]", "]"}]}]}]], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Intercalate", "[", 
  RowBox[{
   RowBox[{"Unevaluated", "[", 
    RowBox[{"2", " ", "*", " ", "3", " ", "*", " ", "4"}], "]"}], ",", " ", 
   "x"}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"24", " ", 
  SuperscriptBox["x", "2"]}]], "Output"]
}, Open  ]],

Cell[TextData[{
 StyleBox["\[WarningSign]",
  FontSize->24,
  FontColor->RGBColor[1, 0, 0]],
 " Check your ",
 StyleBox["entire function body for all occurrences",
  FontSlant->"Italic"],
 " of the pattern variables, and if they are passed to another function, wrap \
them in Unevaluated!"
}], "Text",
 CellDingbat->None,
 FontWeight->"Bold"],

Cell["\<\
Now, for some functions, notably the whole class of functions we might dub \
\"mathematical functions\", this is probably pedantic and inconvenient.  \
Mathematical functions want to operate on and yield fully evaluated algebraic \
or numeric expressions.\
\>", "Text"],

Cell[TextData[{
 "But for any purely structural command - any auxiliary functions or \
utilities that might fall in the category of \"Programming Functions\" - they \
",
 StyleBox["should be capable of acting on unevaluated expressions",
  FontSlant->"Italic"],
 "!"
}], "Text"],

Cell[TextData[{
 "General Principle:\n\nProtect your uses of the incoming variables from ",
 StyleBox["default interpretation",
  FontSlant->"Italic"],
 " by the language if the arguments are either passed with an explicit flag \
to prevent interpretation (Unevaluated) or the semantics of your function \
naturally doesn't want to use the default interpretation (e.g. a function \
that dumbly counts occurrences of things, who cares if \"things\" includes \
fancy objects like patterns)."
}], "Text",
 FontWeight->"Bold"]
}, Closed]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Miscellaneous advanced techniques, and subtle topics", "Subsection"],

Cell[CellGroupData[{

Cell["\<\
Using tests on patterns:
  /; MyTestQ @ Unevaluated[p]
instead of
  /; MyTestQ[p]\
\>", "Subsubsection"],

Cell["Patterns can be specified in two ways:", "Text"],

Cell[TextData[{
 "(1)  Structure.\nUsing the ",
 StyleBox["Blank", "Input",
  FontSize->12],
 "* family, ",
 StyleBox["Pattern, Alternatives, Repeated", "Input",
  FontSize->12],
 " and ",
 StyleBox["RepeatedNull", "Input",
  FontSize->12],
 ", ",
 StyleBox["Optional", "Input",
  FontSize->12]
}], "Text",
 CellDingbat->"\[FilledSmallCircle]"],

Cell["Examples", "Text"],

Cell[BoxData["n_Integer"], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"n_Integer", ",", " ", "x_Real"}], "}"}]], "Input"],

Cell[BoxData[
 RowBox[{"f", "[", 
  RowBox[{"elems__", ",", " ", "n_Integer"}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"_Integer", " ", "|", " ", "_Rational", " ", "|", " ", 
  "_Real"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"z_Complex", ",", " ", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"_Real", ",", " ", "_Real"}], "}"}], "..."}]}], "}"}]], "Input"],

Cell[TextData[{
 "(2)  Boolean tests.\nUsing ",
 StyleBox["PatternTest", "Input",
  FontSize->12],
 " (",
 StyleBox["patt?func", "Input",
  FontSize->12],
 ") or ",
 StyleBox["Condition", "Input",
  FontSize->12],
 " (",
 StyleBox["patt /; expr", "Input",
  FontSize->12],
 ")"
}], "Text",
 CellDingbat->"\[FilledSmallCircle]"],

Cell["Examples:", "Text"],

Cell[BoxData[
 RowBox[{"n_Integer", 
  StyleBox["?",
   FontColor->RGBColor[0, 0, 1]], 
  StyleBox["Positive",
   FontColor->RGBColor[0, 0, 1]]}]], "Input"],

Cell[BoxData[
 RowBox[{"x_String", 
  StyleBox["?",
   FontColor->RGBColor[0, 0, 1]], 
  StyleBox["MyTest",
   FontColor->RGBColor[0, 0, 1]]}]], "Input"],

Cell[TextData[{
 StyleBox["PatternTest", "Input",
  FontSize->12],
 " (",
 StyleBox["patt?func", "Input",
  FontSize->12],
 ") and ",
 StyleBox["Condition", "Input",
  FontSize->12],
 " (",
 StyleBox["patt /; expr", "Input",
  FontSize->12],
 "), are unlike the components of the pattern language because they perform \
",
 StyleBox["evaluation",
  FontSlant->"Italic"],
 " on the prospective match, or parts thereof, instead of simply checking ",
 StyleBox["structure",
  FontSlant->"Italic"],
 ".  By default, they will evaluate each and every prospective match.  If \
you're searching something that contains function bodies, rules, or any sort \
of unevaluated code, then these tests will evaluate those things while \
checking if they match!  This is often the wrong thing to do, and if the \
unevaluated code contains things like assignments, it will change the state \
of your ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " session.\n\nHardly anyone is accustomed to this subtlety of pattern tests, \
so you have to train yourself to remember it, setting a mental flag on your \
usage of ",
 StyleBox["PatternTest", "Input",
  FontSize->12],
 " and ",
 StyleBox["Condition", "Input",
  FontSize->12],
 "."
}], "Text"],

Cell[TextData[{
 "Here's a surprisingly realistic example of how casual use of ",
 StyleBox["PatternTest", "Input",
  FontSize->12],
 " can cause code to execute.  The user wants to find all ",
 StyleBox["Cell", "Input",
  FontSize->12],
 " options whose values are themselves lists with suboptions."
}], "Text",
 CellDingbat->"\[EmptySmallCircle]"],

Cell[BoxData[
 RowBox[{
  RowBox[{"thingsThatAreSubOptions", " ", "=", " ", 
   RowBox[{"Cases", "[", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"Options", "[", "Cell", "]"}], ",", "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"(", 
       RowBox[{"Rule", " ", "|", " ", "RuleDelayed"}], ")"}], "[", 
      RowBox[{"optName_", ",", " ", 
       RowBox[{"optValue_List", " ", "/;", " ", 
        RowBox[{"Not", " ", "@", " ", 
         RowBox[{"FreeQ", "[", 
          RowBox[{"optValue", ",", " ", 
           RowBox[{"_", "?", "OptionQ"}]}], "]"}]}]}]}], "]"}]}], 
    "\[IndentingNewLine]", "]"}]}], ";"}]], "Input"],

Cell[BoxData[
 RowBox[{
  ErrorBox[\(Slot[1]\)], 
  ErrorBox[\(Slot[1]\)]}]], "Input"],

Cell[TextData[{
 "Whoa, why did red-underlined ",
 StyleBox["Slot[1]", "Input",
  FontSize->12],
 " get written to a cell??\n\nAnswer:  One of the options of ",
 StyleBox["Cell", "Input",
  FontSize->12],
 " is ",
 StyleBox["ButtonBoxOptions", "Input",
  FontSize->12],
 ", which provides defaults for things like ",
 StyleBox["ButtonData :> data", "Input",
  FontSize->12],
 " and ",
 StyleBox["ButtonFunction :> func", "Input",
  FontSize->12],
 ".  Notice that the latter are delayed rules, because their rhs contains \
code!  Our condition on ",
 StyleBox["optValue_List", "Input",
  FontSize->12],
 " used the very aggressive ",
 StyleBox["FreeQ", "Input",
  FontSize->12],
 " test, which searches all levels of an expression for a match of the \
pattern.  The pattern we asked ",
 StyleBox["FreeQ", "Input",
  FontSize->12],
 " to search for was ",
 StyleBox["_?OptionQ", "Input",
  FontSize->12],
 ", which evaluates ",
 StyleBox["OptionQ", "Input",
  FontSize->12],
 " on every prospective match!  Since ",
 StyleBox["FreeQ", "Input",
  FontSize->12],
 " tests every subexpression from the top on down to the atoms, this \
evaluates code inside of ",
 StyleBox["ButtonFunction", "Input",
  FontSize->12],
 ", particularly a pure function involving ",
 StyleBox["NotebookApply", "Input",
  FontSize->12],
 ".  That's what printed then ",
 StyleBox["Slot[1]", "Input",
  FontSize->12],
 "'s."
}], "Text"],

Cell["\<\
Here are a few other common types of tests.  The first in each pair \
carelessly evaluates; the second is the corrected version with no evaluation \
leaks.\
\>", "Text",
 CellDingbat->"\[EmptySmallCircle]"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"(*", " ", 
   RowBox[{"Incorrect", ":"}], " ", "*)"}], "\[IndentingNewLine]", 
  RowBox[{
   RowBox[{"things_List", " ", "/;", " ", 
    RowBox[{
     RowBox[{"Length", "[", "things", "]"}], " ", "\[GreaterEqual]", " ", 
     "2"}]}], "\n", "\[IndentingNewLine]", 
   RowBox[{"(*", " ", 
    RowBox[{"Correct", ":"}], " ", "*)"}]}]}], "\n", 
 RowBox[{"things_List", " ", "/;", " ", 
  RowBox[{
   RowBox[{"Length", " ", "@", " ", 
    RowBox[{"Unevaluated", "[", "things", "]"}]}], " ", "\[GreaterEqual]", 
   " ", "2"}]}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"(*", " ", 
   RowBox[{"Incorrect", ":"}], " ", "*)"}], "\[IndentingNewLine]", 
  RowBox[{
   RowBox[{"num_", "?", "NumberQ"}], "\n", "\[IndentingNewLine]", 
   RowBox[{"(*", " ", 
    RowBox[{"Correct", ":"}], " ", "*)"}]}]}], "\n", 
 RowBox[{"num_", "?", 
  RowBox[{"(", 
   RowBox[{"Function", "[", 
    RowBox[{"e", ",", " ", 
     RowBox[{"NumberQ", " ", "@", " ", 
      RowBox[{"Unevaluated", "[", "e", "]"}]}], ",", " ", "HoldAllComplete"}],
     "]"}], ")"}]}]}], "Input"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"(*", " ", 
   RowBox[{"Incorrect", ":"}], " ", "*)"}], "\[IndentingNewLine]", 
  RowBox[{
   RowBox[{"args___", " ", "/;", " ", 
    RowBox[{"FreeQ", "[", 
     RowBox[{
      RowBox[{"{", "args", "}"}], ",", " ", 
      RowBox[{"_Rule", " ", "|", " ", "_RuleDelayed"}]}], "]"}]}], "\n", 
   "\[IndentingNewLine]", 
   RowBox[{"(*", " ", 
    RowBox[{"Correct", ":"}], " ", "*)"}]}]}], "\n", 
 RowBox[{"args___", " ", "/;", " ", 
  RowBox[{"FreeQ", "[", 
   RowBox[{
    RowBox[{"Unevaluated", "[", 
     RowBox[{"{", "args", "}"}], "]"}], ",", " ", 
    RowBox[{"_Rule", " ", "|", " ", "_RuleDelayed"}]}], "]"}]}]}], "Input"],

Cell[TextData[{
 "Personally, I hate the appearance of ",
 StyleBox["x?(Function[...])", "Input",
  FontSize->12],
 " so I either define my own ",
 StyleBox["HoldAll", "Input",
  FontSize->12],
 " or ",
 StyleBox["HoldAllComplete", "Input",
  FontSize->12],
 " test function to make the code clearer:"
}], "Text"],

Cell[BoxData[
 RowBox[{"x_", "?", "HeldNumberQ"}]], "Input"],

Cell[TextData[{
 "or I use ",
 StyleBox["Condition", "Input",
  FontSize->12],
 ", where I can make the code a little clearer by naming the parts I want to \
reference."
}], "Text"],

Cell[TextData[{
 "In general, the handful of ",
 StyleBox["raw objects",
  FontSlant->"Italic"],
 " of ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " are often specified using these patterns:\n\n  x_Integer\n  x_Rational\n  \
x_Real\n  x_Complex\n  \n  x_String\n  x_Symbol\n  \n  Technically, these \
patterns catch more than the raw atoms.  ",
 StyleBox["Integer[0, \"Hello\"]", "Input",
  FontSize->12],
 " is a perfectly valid expression whose head is ",
 StyleBox["Integer", "Input",
  FontSize->12],
 ", therefore it matches ",
 StyleBox["_", "Input",
  FontSize->12],
 StyleBox["Integer", "Input",
  FontSize->12],
 ".  In practice, rarely do these occur, so it would just make code scary \
looking to use anything other than the common and almost-correct idioms.\n  \n\
    But if you're writing advanced code that must not have any evaluation \
leaks, e.g. typesetting code or code analysis tools, you need the \
bullet-proof version."
}], "Text",
 CellDingbat->"\[EmptySmallCircle]"],

Cell["Here's a template for bullet-proof pattern test:", "Text"],

Cell[BoxData[
 RowBox[{
  StyleBox[
   RowBox[{"x_", 
    StyleBox["RawType",
     FontSlant->"Italic"]}]], " ", 
  StyleBox["/;",
   FontColor->RGBColor[0, 0, 1]], 
  StyleBox[" ",
   FontColor->RGBColor[0, 0, 1]], 
  StyleBox[
   RowBox[{"AtomQ", " ", "@", " ", 
    RowBox[{"Unevaluated", "[", "x", "]"}]}],
   FontColor->RGBColor[0, 0, 1]]}]], "Input"],

Cell[TextData[{
 "where ",
 StyleBox["RawType", "Input",
  FontSize->12,
  FontSlant->"Italic"],
 " \[Element] {",
 StyleBox["Integer", "Input",
  FontSize->12],
 ", ",
 StyleBox["Rational", "Input",
  FontSize->12],
 ", ",
 StyleBox["Real", "Input",
  FontSize->12],
 ", ",
 StyleBox["Complex", "Input",
  FontSize->12],
 ", ",
 StyleBox["Symbol", "Input",
  FontSize->12],
 ", ",
 StyleBox["String", "Input",
  FontSize->12],
 "}."
}], "Text"],

Cell[TextData[{
 "Often you won't need the ",
 StyleBox["AtomQ", "Input",
  FontSize->12],
 " test, though, because you're selecting matches using one of the family of \
commands that takes a level specification, such as ",
 StyleBox["Replace", "Input",
  FontSize->12],
 ", ",
 StyleBox["Cases", "Input",
  FontSize->12],
 ", or ",
 StyleBox["MemberQ", "Input",
  FontSize->12],
 ".  In that case, you can give a levelspec of ",
 StyleBox["{-1}", "Input",
  FontSize->12],
 ", or ",
 StyleBox["{Infinity}", "Input",
  FontSize->12],
 ", to the main command, which is a nice way to restrict the search space, \
relieving some of the burden on the actual pattern.\n\nTemplate examples:"
}], "Text"],

Cell[BoxData[
 RowBox[{"Cases", "[", 
  RowBox[{"expr", ",", " ", 
   RowBox[{"s_Symbol", " ", "\[RuleDelayed]", " ", 
    RowBox[{"Context", "[", "s", "]"}]}], ",", " ", 
   RowBox[{"{", 
    RowBox[{"-", "1"}], "}"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"MemberQ", "[", 
  RowBox[{"expr", ",", " ", "s_String", " ", ",", " ", 
   RowBox[{"{", 
    RowBox[{"-", "1"}], "}"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"Replace", "[", 
  RowBox[{"expr", ",", " ", 
   RowBox[{"x_Real", " ", "\[RuleDelayed]", " ", 
    RowBox[{"Sqrt", "[", "x", "]"}]}], ",", " ", 
   RowBox[{"{", 
    RowBox[{"-", "1"}], "}"}]}], "]"}]], "Input"],

Cell[TextData[{
 "You could define test to detect potentially dangerous subexpressions if you \
wish.  Look for expressions whose head has a ",
 StyleBox["Hold", "Input",
  FontSize->12],
 "* attribute:"
}], "Text",
 CellDingbat->"\[EmptySmallCircle]"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{
    RowBox[{"Attributes", "[", "HoldQ", "]"}], " ", "=", " ", 
    "HoldAllComplete"}], ";"}], "\[IndentingNewLine]"}], "\n", 
 RowBox[{
  RowBox[{"HoldQ", "[", 
   RowBox[{"s_Symbol", " ", "/;", " ", 
    RowBox[{"AtomQ", " ", "@", " ", 
     RowBox[{"Unevaluated", "[", "s", "]"}]}]}], "]"}], " ", ":=", 
  "\[IndentingNewLine]", 
  RowBox[{"MemberQ", "[", 
   RowBox[{
    RowBox[{"Attributes", "[", "s", "]"}], ",", " ", 
    RowBox[{
    "HoldFirst", " ", "|", " ", "HoldRest", " ", "|", " ", "HoldAll", " ", 
     "|", " ", "HoldAllComplete"}]}], "]"}]}]}], "Input"],

Cell[BoxData[
 RowBox[{
  RowBox[{"ContainsUnevaluatedQ", "[", "expr_", "]"}], " ", ":=", 
  "\[IndentingNewLine]", 
  RowBox[{"MemberQ", "[", 
   RowBox[{
    RowBox[{"Unevaluated", "[", "expr", "]"}], ",", " ", 
    RowBox[{
     RowBox[{"h_Symbol", "?", "HoldQ"}], "[", "___", "]"}], ",", " ", 
    RowBox[{"{", 
     RowBox[{"0", ",", " ", 
      RowBox[{"-", "1"}]}], "}"}], ",", " ", 
    RowBox[{"Heads", "\[Rule]", "True"}]}], "]"}]}]], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"ContainsUnevaluatedQ", "[", 
  RowBox[{"Options", "[", "Cell", "]"}], "]"}]], "Input"],

Cell[BoxData["True"], "Output"]
}, Open  ]],

Cell["\<\
You can also return a list of them to see what you're up against:\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Cases", "[", 
  RowBox[{
   RowBox[{"Options", "[", "Cell", "]"}], ",", " ", 
   RowBox[{
    RowBox[{"h_Symbol", "?", "HoldQ"}], "[", "___", "]"}], ",", " ", 
   RowBox[{"{", 
    RowBox[{"0", ",", " ", 
     RowBox[{"-", "1"}]}], "}"}], ",", " ", 
   RowBox[{"Heads", "\[Rule]", "True"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"\<\"\[Rule]\"\>", "\[RuleDelayed]", "\<\"->\"\>"}], ",", 
   RowBox[{"\<\"\[RuleDelayed]\"\>", "\[RuleDelayed]", "\<\":>\"\>"}], ",", 
   RowBox[{"\<\"\[LessEqual]\"\>", "\[RuleDelayed]", "\<\"<=\"\>"}], ",", 
   RowBox[{"\<\"\[GreaterEqual]\"\>", "\[RuleDelayed]", "\<\">=\"\>"}], ",", 
   RowBox[{"\<\"\[NotEqual]\"\>", "\[RuleDelayed]", "\<\"!=\"\>"}], ",", 
   RowBox[{"\<\"\[Equal]\"\>", "\[RuleDelayed]", "\<\"==\"\>"}], ",", 
   RowBox[{"ConversionRules", "\[RuleDelayed]", "None"}], ",", 
   RowBox[{"TaggingRules", "\[RuleDelayed]", "None"}], ",", 
   RowBox[{"LayoutInformation", "\[RuleDelayed]", "None"}], ",", 
   RowBox[{"DragAndDropFunction", "\[RuleDelayed]", "None"}], ",", 
   RowBox[{"CoordinateDisplayFunction", "\[RuleDelayed]", "Identity"}], ",", 
   RowBox[{"CounterFunction", "\[RuleDelayed]", "Identity"}], ",", 
   RowBox[{"CounterData", "\[RuleDelayed]", "Identity"}], ",", 
   RowBox[{
    RowBox[{"FrontEndExecute", "[", 
     RowBox[{"{", 
      RowBox[{"FrontEnd`NotebookApply", "[", 
       RowBox[{
        RowBox[{"FrontEnd`InputNotebook", "[", "]"}], ",", "#1", ",", 
        "Placeholder"}], "]"}], "}"}], "]"}], "&"}], ",", 
   RowBox[{"ButtonFunction", "\[RuleDelayed]", 
    RowBox[{"(", 
     RowBox[{
      RowBox[{"FrontEndExecute", "[", 
       RowBox[{"{", 
        RowBox[{"FrontEnd`NotebookApply", "[", 
         RowBox[{
          RowBox[{"FrontEnd`InputNotebook", "[", "]"}], ",", "#1", ",", 
          "Placeholder"}], "]"}], "}"}], "]"}], "&"}], ")"}]}], ",", 
   RowBox[{"ButtonData", "\[RuleDelayed]", "Automatic"}], ",", 
   RowBox[{
    RowBox[{"FrontEndExecute", "[", 
     RowBox[{"{", 
      RowBox[{"FrontEnd`NotebookApply", "[", 
       RowBox[{
        RowBox[{"FrontEnd`InputNotebook", "[", "]"}], ",", "#1", ",", 
        "Placeholder"}], "]"}], "}"}], "]"}], "&"}], ",", 
   RowBox[{"ButtonFunction", "\[RuleDelayed]", 
    RowBox[{"(", 
     RowBox[{
      RowBox[{"FrontEndExecute", "[", 
       RowBox[{"{", 
        RowBox[{"FrontEnd`NotebookApply", "[", 
         RowBox[{
          RowBox[{"FrontEnd`InputNotebook", "[", "]"}], ",", "#1", ",", 
          "Placeholder"}], "]"}], "}"}], "]"}], "&"}], ")"}]}], ",", 
   RowBox[{"ButtonData", "\[RuleDelayed]", "Automatic"}], ",", 
   RowBox[{"ButtonFunction", "\[RuleDelayed]", "Null"}], ",", 
   RowBox[{"TrackingFunction", "\[RuleDelayed]", "Null"}], ",", 
   RowBox[{"ButtonData", "\[RuleDelayed]", "Automatic"}], ",", 
   RowBox[{"GridDefaultElement", "\[RuleDelayed]", "\[Placeholder]"}]}], 
  "}"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "Obviously, many of these ",
 StyleBox["RuleDelayed", "Input",
  FontSize->12],
 "'s have atoms as their parts and are safe to evaluate, so you might want to \
prune this down to more dangerous things:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"DeleteCases", "[", 
  RowBox[{"%", ",", " ", 
   RowBox[{"_", " ", "\[RuleDelayed]", " ", 
    RowBox[{"_String", " ", "|", " ", "_Symbol"}]}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{
    RowBox[{"FrontEndExecute", "[", 
     RowBox[{"{", 
      RowBox[{"FrontEnd`NotebookApply", "[", 
       RowBox[{
        RowBox[{"FrontEnd`InputNotebook", "[", "]"}], ",", "#1", ",", 
        "Placeholder"}], "]"}], "}"}], "]"}], "&"}], ",", 
   RowBox[{"ButtonFunction", "\[RuleDelayed]", 
    RowBox[{"(", 
     RowBox[{
      RowBox[{"FrontEndExecute", "[", 
       RowBox[{"{", 
        RowBox[{"FrontEnd`NotebookApply", "[", 
         RowBox[{
          RowBox[{"FrontEnd`InputNotebook", "[", "]"}], ",", "#1", ",", 
          "Placeholder"}], "]"}], "}"}], "]"}], "&"}], ")"}]}], ",", 
   RowBox[{
    RowBox[{"FrontEndExecute", "[", 
     RowBox[{"{", 
      RowBox[{"FrontEnd`NotebookApply", "[", 
       RowBox[{
        RowBox[{"FrontEnd`InputNotebook", "[", "]"}], ",", "#1", ",", 
        "Placeholder"}], "]"}], "}"}], "]"}], "&"}], ",", 
   RowBox[{"ButtonFunction", "\[RuleDelayed]", 
    RowBox[{"(", 
     RowBox[{
      RowBox[{"FrontEndExecute", "[", 
       RowBox[{"{", 
        RowBox[{"FrontEnd`NotebookApply", "[", 
         RowBox[{
          RowBox[{"FrontEnd`InputNotebook", "[", "]"}], ",", "#1", ",", 
          "Placeholder"}], "]"}], "}"}], "]"}], "&"}], ")"}]}]}], 
  "}"}]], "Output"]
}, Open  ]],

Cell["\<\

\
\>", "Text"],

Cell[TextData[{
 "Sometimes you want to specify that an argument not match a pattern, and \
since there is no ",
 StyleBox["PatternNot", "Input",
  FontSize->12],
 " primitive in the language, you need to do this in a Boolean test.  One way \
is to use ",
 StyleBox["MatchQ", "Input",
  FontSize->12],
 "."
}], "Text"],

Cell[BoxData[
 RowBox[{"f", "[", 
  RowBox[{"x_", ",", " ", 
   RowBox[{"y_", " ", 
    StyleBox["/;",
     FontColor->RGBColor[0, 0, 1]], 
    StyleBox[" ",
     FontColor->RGBColor[0, 0, 1]], 
    RowBox[{
     StyleBox["Not",
      FontColor->RGBColor[0, 0, 1]], 
     StyleBox[" ",
      FontColor->RGBColor[0, 0, 1]], 
     StyleBox["@",
      FontColor->RGBColor[0, 0, 1]], 
     StyleBox[" ",
      FontColor->RGBColor[0, 0, 1]], 
     RowBox[{
      StyleBox["MatchQ",
       FontColor->RGBColor[0, 0, 1]], 
      StyleBox["[",
       FontColor->RGBColor[0, 0, 1]], 
      RowBox[{
       StyleBox[
        RowBox[{"Unevaluated", "[", "y", "]"}],
        FontColor->RGBColor[0, 0, 1]], ",", " ", "_List"}], "]"}]}]}]}], 
  "]"}]], "Input"],

Cell[TextData[{
 StyleBox["\[WarningSign]",
  FontSize->24,
  FontColor->RGBColor[1, 0, 0]],
 StyleBox["  ",
  FontColor->RGBColor[1, 0, 0]],
 StyleBox["Warning",
  FontSlant->"Italic",
  FontColor->RGBColor[1, 0, 0]],
 StyleBox[":  Before Version 3, you were virtually guaranteed that _Symbol \
would match only the atomic data type of 'symbols',  But in Versions 3 and \
beyond, Symbol can also be used as a function, e.g. Symbol[\"a\"] \
\[DoubleLongRightArrow] a, so if your program is dealing with unevaluated \
input or code of any sort, you have to now deal with the fact that _Symbol \
matches two classes of legitimate expressions:  atomic symbols, and calls of \
the Symbol function.  Example:",
  FontColor->RGBColor[1, 0, 0]]
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Symbol", "[", "\"\<a\>\"", "]"}]], "Input"],

Cell[BoxData["a"], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Through", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"FullForm", ",", " ", "AtomQ", ",", " ", "Head"}], "}"}], "[", 
   "%", "]"}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   TagBox[
    StyleBox["a",
     ShowSpecialCharacters->False,
     ShowStringCharacters->True,
     NumberMarks->True],
    FullForm], ",", "True", ",", "Symbol"}], "}"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "A weird pseudo-Symbol that you might run in to:  if you remove a symbol \
which is still currently in use in some definitions, then it will be replaced \
by an entity which prints like ",
 StyleBox["Removed[\"symName\"]", "Input",
  FontSize->12],
 " and which is considered an atom and has head ",
 StyleBox["Symbol", "Input",
  FontSize->12],
 ".  It will ",
 StyleBox["match _Symbol", "Input",
  FontSize->12],
 ", and you can assign to it, look up its information or context, and most if \
not all that other stuff you can do with symbols, but it's strange because it \
has no input form (that I know of) and ",
 StyleBox["Names[]", "Input",
  FontSize->12],
 " seems unaware of its existence in any context, let alone the one that ",
 StyleBox["Context", "Input",
  FontSize->12],
 " claims it is in."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"x", " ", "=", " ", "doomed"}], ";", " ", "0"}]], "Input"],

Cell[BoxData["0"], "Output"]
}, Open  ]],

Cell[BoxData[
 RowBox[{"Remove", "[", "\"\<doomed\>\"", "]"}]], "Input"],

Cell[CellGroupData[{

Cell[BoxData["x"], "Input"],

Cell[BoxData[
 TagBox[
  RowBox[{"Removed", "[", "\<\"doomed\"\>", "]"}],
  False,
  Editable->False]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Through", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"FullForm", ",", " ", "AtomQ", ",", " ", "Head"}], "}"}], "[", 
   "x", "]"}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   TagBox[
    StyleBox[
     TagBox[
      RowBox[{"Removed", "[", "\"\<doomed\>\"", "]"}],
      False,
      Editable->False],
     ShowSpecialCharacters->False,
     ShowStringCharacters->True,
     NumberMarks->True],
    FullForm], ",", "True", ",", "Symbol"}], "}"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"isSymbol", "[", "_Symbol", "]"}], " ", "=", " ", "True"}], 
  ";"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"isSymbol", "[", "_", "]"}], " ", "=", " ", "False"}], ";"}], "\n", 
 RowBox[{"isSymbol", "[", "x", "]"}]}], "Input"],

Cell[BoxData["True"], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"Evaluate", "[", "x", "]"}], " ", "=", " ", "777"}]], "Input"],

Cell[BoxData["777"], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"Unevaluated", " ", "@", " ", 
   RowBox[{"Information", "[", "x", "]"}]}], " ", "/.", " ", 
  RowBox[{"OwnValues", "[", "x", "]"}]}]], "Input"],

Cell[BoxData["\<\"Global`doomed\"\>"], "Print"],

Cell[BoxData[
 InterpretationBox[GridBox[{
    {GridBox[{
       {
        RowBox[{
         TagBox[
          RowBox[{"Removed", "[", "\<\"doomed\"\>", "]"}],
          False,
          Editable->False], "=", "777"}]}
      },
      BaselinePosition->{Baseline, {1, 1}},
      GridBoxAlignment->{
       "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
        "RowsIndexed" -> {}},
      GridBoxItemSize->{"Columns" -> {{
           Scaled[0.999]}}, "ColumnsIndexed" -> {}, "Rows" -> {{1.}}, 
        "RowsIndexed" -> {}}]}
   },
   BaselinePosition->{Baseline, {1, 1}},
   GridBoxAlignment->{
    "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
     "RowsIndexed" -> {}}],
  Definition[
   Removed["doomed"]],
  Editable->False]], "Print"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"Unevaluated", " ", "@", " ", 
   RowBox[{"Context", "[", "x", "]"}]}], " ", "/.", " ", 
  RowBox[{"OwnValues", "[", "x", "]"}]}]], "Input"],

Cell[BoxData["\<\"Global`\"\>"], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"Characters", "[", "%14", "]"}], " ", "//", "FullForm"}]], "Input"],

Cell[BoxData[
 TagBox[
  StyleBox[
   RowBox[{"List", "[", 
    RowBox[{
    "\"\<G\>\"", ",", "\"\<l\>\"", ",", "\"\<o\>\"", ",", "\"\<b\>\"", ",", 
     "\"\<a\>\"", ",", "\"\<l\>\"", ",", "\"\<`\>\""}], "]"}],
   ShowSpecialCharacters->False,
   ShowStringCharacters->True,
   NumberMarks->True],
  FullForm]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Names", "[", "\"\<Global`*oom*\>\"", "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", "}"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Names", "[", "\"\<Global`*\>\"", "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"\<\"a\"\>", ",", "\<\"isSymbol\"\>", ",", "\<\"x\"\>"}], 
  "}"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Select", "[", 
  RowBox[{
   RowBox[{"Names", "[", "]"}], ",", " ", 
   RowBox[{
    RowBox[{"StringMatchQ", "[", 
     RowBox[{"#", ",", " ", "\"\<*doom*\>\""}], "]"}], "&"}]}], 
  "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", "}"}]], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["Trott-Strzebonski method for In-Place Evaluation", "Subsubsection"],

Cell[TextData[{
 "One of the all-time cleverest idioms I've seen; this was discovered by \
Michael Trott and Adam Strzebonski a few years ago.  The template is a rule \
of the following form:\n\n   ",
 StyleBox["lhs :> With[{eval = lhs}, eval /; True]", "Input",
  FontSize->12]
}], "Text"],

Cell["\<\
Suppose you want to replace a bunch of things inside a held expression, and \
have the replacements evaluate.  You don't want to evaluate the whole, just \
the pieces that are targeted.\
\>", "Text"],

Cell[BoxData[
 RowBox[{"SeedRandom", "[", 
  RowBox[{"2", "^", "51"}], "]"}]], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"jaggedTable", " ", "=", " ", 
  RowBox[{"Table", "[", 
   RowBox[{
    RowBox[{"Random", "[", 
     RowBox[{"Integer", ",", " ", 
      RowBox[{"{", 
       RowBox[{"0", ",", " ", "5"}], "}"}]}], "]"}], ",", " ", 
    RowBox[{"{", 
     RowBox[{"Random", "[", 
      RowBox[{"Integer", ",", " ", 
       RowBox[{"{", 
        RowBox[{"1", ",", " ", "4"}], "}"}]}], "]"}], "}"}], ",", " ", 
    RowBox[{"{", 
     RowBox[{"Random", "[", 
      RowBox[{"Integer", ",", " ", 
       RowBox[{"{", 
        RowBox[{"1", ",", " ", "4"}], "}"}]}], "]"}], "}"}], ",", " ", 
    RowBox[{"{", 
     RowBox[{"Random", "[", 
      RowBox[{"Integer", ",", " ", 
       RowBox[{"{", 
        RowBox[{"1", ",", " ", "4"}], "}"}]}], "]"}], "}"}]}], 
   "]"}]}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"1", ",", "4", ",", "4", ",", "0"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"2", ",", "0", ",", "1"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", "1"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"5", ",", "5", ",", "2", ",", "2"}], "}"}]}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"{", 
     RowBox[{"0", ",", "5", ",", "5"}], "}"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"5", ",", "1", ",", "3"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"4", ",", "1"}], "}"}]}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"3", ",", "3", ",", "4", ",", "0"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"5", ",", "2"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"4", ",", "2", ",", "0"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"2", ",", "5"}], "}"}]}], "}"}]}], "}"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"heldTable", " ", "=", " ", 
  RowBox[{"Apply", "[", 
   RowBox[{"Hold", ",", " ", "jaggedTable", ",", " ", 
    RowBox[{"{", 
     RowBox[{"0", ",", " ", "1"}], "}"}]}], "]"}]}]], "Input"],

Cell[BoxData[
 RowBox[{"Hold", "[", 
  RowBox[{
   RowBox[{"Hold", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"1", ",", "4", ",", "4", ",", "0"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"2", ",", "0", ",", "1"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"1", ",", "1"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"5", ",", "5", ",", "2", ",", "2"}], "}"}]}], "]"}], ",", 
   RowBox[{"Hold", "[", 
    RowBox[{"{", 
     RowBox[{"0", ",", "5", ",", "5"}], "}"}], "]"}], ",", 
   RowBox[{"Hold", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"5", ",", "1", ",", "3"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"4", ",", "1"}], "}"}]}], "]"}], ",", 
   RowBox[{"Hold", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"3", ",", "3", ",", "4", ",", "0"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"5", ",", "2"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"4", ",", "2", ",", "0"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"2", ",", "5"}], "}"}]}], "]"}]}], "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"heldTable", " ", "=", " ", 
  RowBox[{"Apply", "[", 
   RowBox[{"Plus", ",", " ", "heldTable", ",", " ", 
    RowBox[{"{", 
     RowBox[{"-", "2"}], "}"}]}], "]"}]}]], "Input"],

Cell[BoxData[
 RowBox[{"Hold", "[", 
  RowBox[{
   RowBox[{"Hold", "[", 
    RowBox[{
     RowBox[{"1", "+", "4", "+", "4", "+", "0"}], ",", 
     RowBox[{"2", "+", "0", "+", "1"}], ",", 
     RowBox[{"1", "+", "1"}], ",", 
     RowBox[{"5", "+", "5", "+", "2", "+", "2"}]}], "]"}], ",", 
   RowBox[{"Hold", "[", 
    RowBox[{"0", "+", "5", "+", "5"}], "]"}], ",", 
   RowBox[{"Hold", "[", 
    RowBox[{
     RowBox[{"5", "+", "1", "+", "3"}], ",", 
     RowBox[{"4", "+", "1"}]}], "]"}], ",", 
   RowBox[{"Hold", "[", 
    RowBox[{
     RowBox[{"3", "+", "3", "+", "4", "+", "0"}], ",", 
     RowBox[{"5", "+", "2"}], ",", 
     RowBox[{"4", "+", "2", "+", "0"}], ",", 
     RowBox[{"2", "+", "5"}]}], "]"}]}], "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"heldTable", " ", "/.", " ", 
  RowBox[{"p_Plus", " ", "\[RuleDelayed]", " ", 
   RowBox[{"With", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"eval", " ", "=", " ", "p"}], "}"}], ",", " ", 
     RowBox[{"eval", " ", "/;", " ", "True"}]}], "]"}]}]}]], "Input"],

Cell[BoxData[
 RowBox[{"Hold", "[", 
  RowBox[{
   RowBox[{"Hold", "[", 
    RowBox[{"9", ",", "3", ",", "2", ",", "14"}], "]"}], ",", 
   RowBox[{"Hold", "[", "10", "]"}], ",", 
   RowBox[{"Hold", "[", 
    RowBox[{"9", ",", "5"}], "]"}], ",", 
   RowBox[{"Hold", "[", 
    RowBox[{"10", ",", "7", ",", "6", ",", "7"}], "]"}]}], "]"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "You can also do this with ",
 StyleBox["ReplacePart", "Input",
  FontSize->12],
 ", but it's harder to code, and has a worse time and space complexity for a \
large number of substitutions (and using ",
 StyleBox["Fold", "Input",
  FontSize->12],
 " with ",
 StyleBox["ReplacePart", "Input",
  FontSize->12],
 " would be O(n^2))."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["My Block trick for trapping calls to built-in functions", \
"Subsubsection"],

Cell["Prototypical example to use as a template:", "Text"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"wasProtected", " ", "=", " ", 
    RowBox[{"Unprotect", "[", "Get", "]"}]}], ";"}], 
  "\[IndentingNewLine]"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"$TrapGet", " ", "=", " ", "True"}], ";"}], 
  "\[IndentingNewLine]"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"g_Get", " ", "/;", " ", "$TrapGet"}], " ", ":=", 
   "\[IndentingNewLine]", 
   RowBox[{"Block", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"$TrapGet", " ", "=", " ", "False"}], "}"}], ",", 
     "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"Print", "[", 
       RowBox[{
        RowBox[{"Unevaluated", "[", "g", "]"}], ",", " ", 
        "\"\< was evaluated!\>\""}], "]"}], ";", "\[IndentingNewLine]", 
      "g"}]}], "\[IndentingNewLine]", "]"}]}], 
  "\[IndentingNewLine]"}], "\n", 
 RowBox[{
  RowBox[{"Protect", " ", "@@", " ", "wasProtected"}], ";"}]}], "Input"],

Cell[TextData[{
 "You are quite free to make the lhs of the rule more complicated; perhaps \
you need to name some arguments of ",
 StyleBox["Get", "Input",
  FontSize->12],
 " so you can refer to them.  The same template applies. For instance:"
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"Get", "[", 
    RowBox[{"filename_String", ",", " ", "opts___"}], "]"}], " ", "/;", " ", 
   "$TrapGet"}], " ", ":=", "\[IndentingNewLine]", 
  RowBox[{"Block", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"$TrapGet", " ", "=", " ", "False"}], "}"}], ",", 
    "\[IndentingNewLine]", 
    RowBox[{"If", "[", 
     RowBox[{
      RowBox[{"StringMatchQ", "[", 
       RowBox[{"filename", ",", " ", "\"\<http://*\>\""}], "]"}], ",", 
      "\[IndentingNewLine]", 
      RowBox[{"Run", "[", 
       RowBox[{"\"\<wget\>\"", ",", " ", "filename"}], "]"}], ",", 
      "\[IndentingNewLine]", 
      RowBox[{"Get", "[", "filename", "]"}]}], "\[IndentingNewLine]", "]"}]}],
    "\[IndentingNewLine]", "]"}]}]], "Input"],

Cell[TextData[{
 "I recommend that you hang the condition ",
 StyleBox["/; $TrapGet", "Input",
  FontSize->12],
 " off the lhs, not the rhs, because then you can revoke the definition by \
plopping the whole lhs into an ",
 StyleBox["Unset", "Input",
  FontSize->12],
 " command:"
}], "Text"],

Cell[BoxData[
 RowBox[{"Unset", "[", 
  RowBox[{
   RowBox[{"Get", "[", 
    RowBox[{"filename_String", ",", " ", "opts___"}], "]"}], " ", "/;", " ", 
   "$TrapGet"}], "]"}]], "Input"],

Cell["\<\


\
\>", "Text"],

Cell["\<\
Also, an important limitation:  can't be used for recursive, e.g. Module as \
tgayley pointed out?\
\>", "Text"],

Cell["\<\
But using a count variable and checking EvenQ[count++] might do it if there \
is one recursion per trap?  Never did find out for sure.\
\>", "Text"],

Cell["\<\
Another limitation:  probably can't trap SetDelayed, Condition, Block, or \
CompoundExpression with it.  Try to find work-around for this!

One alternative to Block is my old method:  manually set and unset the var, \
must wrap in CheckAbort to prevent dirty state change.\
\>", "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["One-step evaluation using expr /. DownValues[f], and family.", \
"Subsubsection"],

Cell[TextData[{
 "Let's say you want to ",
 StyleBox["Map", "Input",
  FontSize->12],
 " or ",
 StyleBox["MapAt", "Input",
  FontSize->12],
 " an existing function f deep into a held expression, and simply have f \
perform its rewrite rule on the argument without any more evaluation."
}], "Text"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"ClearAll", "[", 
   RowBox[{"f", ",", "array"}], "]"}], "\[IndentingNewLine]"}], "\n", 
 RowBox[{
  RowBox[{"f", "[", "x_", "]"}], " ", ":=", " ", 
  RowBox[{"x", " ", "+", " ", 
   RowBox[{"x", "^", "2"}], " ", "+", " ", 
   RowBox[{"x", "^", "3"}]}]}]}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"array", " ", "=", " ", 
  RowBox[{"Array", "[", 
   RowBox[{"Subtract", ",", " ", 
    RowBox[{"{", 
     RowBox[{"3", ",", " ", "4"}], "}"}]}], "]"}]}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"0", ",", 
     RowBox[{"-", "1"}], ",", 
     RowBox[{"-", "2"}], ",", 
     RowBox[{"-", "3"}]}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "0", ",", 
     RowBox[{"-", "1"}], ",", 
     RowBox[{"-", "2"}]}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2", ",", "1", ",", "0", ",", 
     RowBox[{"-", "1"}]}], "}"}]}], "}"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Map", "[", 
  RowBox[{"f", ",", " ", 
   RowBox[{"Hold", "[", 
    RowBox[{"Evaluate", "[", " ", "array", " ", "]"}], "]"}], ",", " ", 
   RowBox[{"{", "3", "}"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"Hold", "[", 
  RowBox[{"{", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{
      RowBox[{"f", "[", "0", "]"}], ",", 
      RowBox[{"f", "[", 
       RowBox[{"-", "1"}], "]"}], ",", 
      RowBox[{"f", "[", 
       RowBox[{"-", "2"}], "]"}], ",", 
      RowBox[{"f", "[", 
       RowBox[{"-", "3"}], "]"}]}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{
      RowBox[{"f", "[", "1", "]"}], ",", 
      RowBox[{"f", "[", "0", "]"}], ",", 
      RowBox[{"f", "[", 
       RowBox[{"-", "1"}], "]"}], ",", 
      RowBox[{"f", "[", 
       RowBox[{"-", "2"}], "]"}]}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{
      RowBox[{"f", "[", "2", "]"}], ",", 
      RowBox[{"f", "[", "1", "]"}], ",", 
      RowBox[{"f", "[", "0", "]"}], ",", 
      RowBox[{"f", "[", 
       RowBox[{"-", "1"}], "]"}]}], "}"}]}], "}"}], "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"%", " ", "/.", " ", 
  RowBox[{"DownValues", "[", "f", "]"}]}]], "Input"],

Cell[BoxData[
 RowBox[{"Hold", "[", 
  RowBox[{"{", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{
      RowBox[{"0", "+", 
       SuperscriptBox["0", "2"], "+", 
       SuperscriptBox["0", "3"]}], ",", 
      RowBox[{
       RowBox[{"-", "1"}], "+", 
       SuperscriptBox[
        RowBox[{"(", 
         RowBox[{"-", "1"}], ")"}], "2"], "+", 
       SuperscriptBox[
        RowBox[{"(", 
         RowBox[{"-", "1"}], ")"}], "3"]}], ",", 
      RowBox[{
       RowBox[{"-", "2"}], "+", 
       SuperscriptBox[
        RowBox[{"(", 
         RowBox[{"-", "2"}], ")"}], "2"], "+", 
       SuperscriptBox[
        RowBox[{"(", 
         RowBox[{"-", "2"}], ")"}], "3"]}], ",", 
      RowBox[{
       RowBox[{"-", "3"}], "+", 
       SuperscriptBox[
        RowBox[{"(", 
         RowBox[{"-", "3"}], ")"}], "2"], "+", 
       SuperscriptBox[
        RowBox[{"(", 
         RowBox[{"-", "3"}], ")"}], "3"]}]}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{
      RowBox[{"1", "+", 
       SuperscriptBox["1", "2"], "+", 
       SuperscriptBox["1", "3"]}], ",", 
      RowBox[{"0", "+", 
       SuperscriptBox["0", "2"], "+", 
       SuperscriptBox["0", "3"]}], ",", 
      RowBox[{
       RowBox[{"-", "1"}], "+", 
       SuperscriptBox[
        RowBox[{"(", 
         RowBox[{"-", "1"}], ")"}], "2"], "+", 
       SuperscriptBox[
        RowBox[{"(", 
         RowBox[{"-", "1"}], ")"}], "3"]}], ",", 
      RowBox[{
       RowBox[{"-", "2"}], "+", 
       SuperscriptBox[
        RowBox[{"(", 
         RowBox[{"-", "2"}], ")"}], "2"], "+", 
       SuperscriptBox[
        RowBox[{"(", 
         RowBox[{"-", "2"}], ")"}], "3"]}]}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{
      RowBox[{"2", "+", 
       SuperscriptBox["2", "2"], "+", 
       SuperscriptBox["2", "3"]}], ",", 
      RowBox[{"1", "+", 
       SuperscriptBox["1", "2"], "+", 
       SuperscriptBox["1", "3"]}], ",", 
      RowBox[{"0", "+", 
       SuperscriptBox["0", "2"], "+", 
       SuperscriptBox["0", "3"]}], ",", 
      RowBox[{
       RowBox[{"-", "1"}], "+", 
       SuperscriptBox[
        RowBox[{"(", 
         RowBox[{"-", "1"}], ")"}], "2"], "+", 
       SuperscriptBox[
        RowBox[{"(", 
         RowBox[{"-", "1"}], ")"}], "3"]}]}], "}"}]}], "}"}], "]"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "You could write a routine to extract the names of symbols occurring at each \
stage, accumulate their various *Values into a list, and apply that list of \
rules.  To attempt to simulate the evaluator, you'd have to make sure ",
 StyleBox["UpValues", "Input",
  FontSize->12],
 " fires befored ",
 StyleBox["DownValues", "Input",
  FontSize->12],
 ", and lots of details like that.\n\nYou could ",
 StyleBox["Nest", "Input",
  FontSize->12],
 " this routine n times, or do ",
 StyleBox["FixedPoint", "Input",
  FontSize->12],
 " of it to crudely simulate the evaluator."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Traps used for tracing should not evaluate what they print or memoize\
\>", "Subsubsection"],

Cell["\<\
Many of you have written things like this to see when a rule fires:\
\>", "Text"],

Cell[BoxData[{
 RowBox[{"ClearAll", "[", "\"\<f\>\"", "]"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"f", "[", 
    RowBox[{"a_", ",", " ", "b_"}], "]"}], " ", "/;", " ", 
   RowBox[{"(", 
    RowBox[{
     RowBox[{"Print", "[", 
      RowBox[{"\"\<a = \>\"", ",", " ", "a"}], "]"}], ";", " ", 
     RowBox[{"Print", "[", 
      RowBox[{"\"\<b = \>\"", ",", " ", "b"}], "]"}], ";", " ", "False"}], 
    ")"}]}], " ", ":=", " ", "$Failed"}]}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"f", "[", 
  RowBox[{
   RowBox[{"Unevaluated", "[", 
    RowBox[{"1", " ", "+", " ", "2"}], "]"}], ",", " ", 
   RowBox[{"Unevaluated", "[", 
    RowBox[{"3", "*", "4"}], "]"}]}], "]"}]], "Input"],

Cell[BoxData[
 InterpretationBox[
  RowBox[{"\<\"a = \"\>", "\[InvisibleSpace]", "3"}],
  SequenceForm["a = ", 3],
  Editable->False]], "Print"],

Cell[BoxData[
 InterpretationBox[
  RowBox[{"\<\"b = \"\>", "\[InvisibleSpace]", "12"}],
  SequenceForm["b = ", 12],
  Editable->False]], "Print"],

Cell[BoxData[
 RowBox[{"f", "[", 
  RowBox[{
   RowBox[{"Unevaluated", "[", 
    RowBox[{"1", "+", "2"}], "]"}], ",", 
   RowBox[{"Unevaluated", "[", 
    RowBox[{"3", " ", "4"}], "]"}]}], "]"}]], "Output"]
}, Open  ]],

Cell["\<\
But sometimes f,whether it's yours or an internal function, will encounter \
things that are bits of unevaluated code, say in the middle of an evaluation, \
or during a trace, or whatever.  This is a case where you want to prevent \
evaluation:\
\>", "Text"],

Cell[BoxData[{
 RowBox[{"ClearAll", "[", "\"\<f\>\"", "]"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"f", "[", 
    RowBox[{"a_", ",", " ", "b_"}], "]"}], " ", "/;", " ", 
   RowBox[{"(", 
    RowBox[{
     RowBox[{"Print", "[", 
      RowBox[{"\"\<a = \>\"", ",", " ", 
       RowBox[{"Unevaluated", "[", "a", "]"}]}], "]"}], ";", " ", 
     RowBox[{"Print", "[", 
      RowBox[{"\"\<b = \>\"", ",", " ", 
       RowBox[{"Unevaluated", "[", "b", "]"}]}], "]"}], ";", " ", "False"}], 
    ")"}]}], " ", ":=", " ", "$Failed"}]}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"f", "[", 
  RowBox[{
   RowBox[{"Unevaluated", "[", 
    RowBox[{"1", " ", "+", " ", "2"}], "]"}], ",", " ", 
   RowBox[{"Unevaluated", "[", 
    RowBox[{"3", "*", "4"}], "]"}]}], "]"}]], "Input"],

Cell[BoxData[
 InterpretationBox[
  RowBox[{"\<\"a = \"\>", "\[InvisibleSpace]", 
   RowBox[{"1", "+", "2"}]}],
  SequenceForm["a = ", 1 + 2],
  Editable->False]], "Print"],

Cell[BoxData[
 InterpretationBox[
  RowBox[{"\<\"b = \"\>", "\[InvisibleSpace]", 
   RowBox[{"3", " ", "4"}]}],
  SequenceForm["b = ", 3 4],
  Editable->False]], "Print"],

Cell[BoxData[
 RowBox[{"f", "[", 
  RowBox[{
   RowBox[{"Unevaluated", "[", 
    RowBox[{"1", "+", "2"}], "]"}], ",", 
   RowBox[{"Unevaluated", "[", 
    RowBox[{"3", " ", "4"}], "]"}]}], "]"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "Or if you really want to be defensive and are concerned that ",
 StyleBox["UpValues", "Input",
  FontSize->12],
 " might fire on ",
 StyleBox["Print[thing]", "Input",
  FontSize->12],
 " before ",
 StyleBox["Print", "Input",
  FontSize->12],
 " can evaluate, use two levels of protection.  Either ",
 StyleBox["Unevaluated @ HoldForm[thing] ", "Input",
  FontSize->12],
 "or ",
 StyleBox["HoldForm @ HoldForm[thing]", "Input",
  FontSize->12],
 ", or perhaps best of all, define yourself a ",
 StyleBox["HoldAllComplete", "Input",
  FontSize->12],
 " version of ",
 StyleBox["HoldForm", "Input",
  FontSize->12],
 "."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
How to pass arguments to HoldAllComplete functions (such as HoldComplete \
itself), since Evaluate no longer forces evaluation:  Function @@, With, \
Block, Replace, ReplacePart\
\>", "Subsubsection"],

Cell[TextData[{
 ".Of course, ",
 StyleBox["HoldAllComplete", "Input",
  FontSize->12],
 " is a bit of a pain, since when you're writing code in a module and need to \
pass the ",
 StyleBox["value",
  FontSlant->"Italic"],
 " of a variable, like ",
 StyleBox["myexpr", "Input",
  FontSize->12],
 ", into it, you can't use ",
 StyleBox["Evaluate", "Input",
  FontSize->12],
 " like you could with ",
 StyleBox["Hold", "Input",
  FontSize->12],
 " and friends.  So here is a list of some techniques for passing into ",
 StyleBox["HoldAllComplete", "Input",
  FontSize->12],
 " wrappers:"
}], "Text"],

Cell["Passing it fully evaluated:", "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"MyHolder", "[", "#", "]"}], "&"}], " ", "[", "myexpr", 
  "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"MyHolder", " ", "@@", " ", 
  RowBox[{"{", "myexpr", "}"}]}]], "Input"],

Cell[BoxData[
 RowBox[{"With", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"myexpr", " ", "=", " ", "myexpr"}], "}"}], ",", 
   "\[IndentingNewLine]", 
   RowBox[{"MyHolder", "[", "myexpr", "]"}]}], "\[IndentingNewLine]", 
  "]"}]], "Input"],

Cell[TextData[{
 "As always, you can temporarily neutralize with ",
 StyleBox["Block", "Input",
  FontSize->12],
 ".  Keep in mind that ",
 StyleBox["myHolder", "Input",
  FontSize->12],
 " would prevent ",
 StyleBox["UpValues", "Input",
  FontSize->12],
 " of its arguments from firing, but will not do so when you ",
 StyleBox["Block", "Input",
  FontSize->12],
 " it, therefore it's possible for this to not be equivalent to the other \
techniques."
}], "Text"],

Cell[BoxData[
 RowBox[{"Block", "[", 
  RowBox[{
   RowBox[{"{", "myHolder", "}"}], ",", "\[IndentingNewLine]", 
   RowBox[{"myHolder", "[", "myexpr", "]"}]}], "\[IndentingNewLine]", 
  "]"}]], "Input"],

Cell[TextData[{
 StyleBox["Replace", "Input",
  FontSize->12],
 " is useful if you know that your ",
 StyleBox["HoldComplete", "Input",
  FontSize->12],
 " contains a particular form, e.g. ",
 StyleBox["s_Symbol", "Input",
  FontSize->12],
 " or ",
 StyleBox["Plus[a_, b_]", "Input",
  FontSize->12],
 ", for instance if it came out of ",
 StyleBox["MakeExpression", "Input",
  FontSize->12],
 ", or ",
 StyleBox["Extract", "Input",
  FontSize->12],
 " or ",
 StyleBox["ToExpression", "Input",
  FontSize->12],
 " with the container argument specified to be ",
 StyleBox["HoldComplete", "Input",
  FontSize->12],
 "."
}], "Text"],

Cell[BoxData[
 RowBox[{"Replace", "[", 
  RowBox[{
   RowBox[{"HoldComplete", "[", "myexpr", "]"}], ",", " ", 
   RowBox[{
    RowBox[{"HoldComplete", "[", 
     RowBox[{"Plus", "[", 
      RowBox[{"a_", ",", " ", "b_"}], "]"}], "]"}], " ", "\[RuleDelayed]", 
    " ", 
    RowBox[{"MyHolder", "[", 
     RowBox[{"a", ",", " ", "b"}], "]"}]}]}], "]"}]], "Input"],

Cell["\<\
Padding it one-step evaluated, or passing something you construct from parts:\
\
\>", "Text"],

Cell[BoxData[
 RowBox[{"With", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"e", " ", ":=", " ", 
     RowBox[{"Plus", "[", 
      RowBox[{"a", ",", " ", "b"}], "]"}]}], "}"}], ",", 
   "\[IndentingNewLine]", 
   RowBox[{"MyHolder", "[", "e", "]"}]}], "\[IndentingNewLine]", 
  "]"}]], "Input"],

Cell[BoxData[
 RowBox[{
  RowBox[{"MyHolder", "[", "myexpr", "]"}], " ", "/.", " ", 
  RowBox[{"OwnValues", "[", "myexpr", "]"}]}]], "Input"],

Cell[BoxData[
 RowBox[{"ReplacePart", "[", 
  RowBox[{
   RowBox[{"HoldComplete", "[", "myexpr", "]"}], ",", " ", 
   RowBox[{"Unevaluated", " ", "@", " ", 
    RowBox[{"Plus", "[", 
     RowBox[{"a", ",", "b"}], "]"}]}], ",", " ", 
   RowBox[{"{", 
    RowBox[{"{", "1", "}"}], "}"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{
  RowBox[{"(*", " ", 
   RowBox[{
   "This", " ", "will", " ", "let", " ", "Set", " ", "decide", " ", "what", 
    " ", "to", " ", 
    RowBox[{"evaluate", ":"}]}], " ", "*)"}], "\[IndentingNewLine]", 
  RowBox[{"Set", " ", "@@", " ", 
   RowBox[{"HoldComplete", "[", 
    RowBox[{
     RowBox[{"f", "[", 
      RowBox[{"x_", ",", " ", "0"}], "]"}], ",", " ", "rhs"}], 
    "]"}]}]}]], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Use strings for symbol names or even to store FullForm of an expression\
\>", "Subsubsection"],

Cell[TextData[{
 "This is the extreme of preventing interpretation of your expressions:  \
making them no longer expressions, but raw strings.\n\nThis is mainly useful \
for persistent storage, and is essentially what ",
 StyleBox["Save", "Input",
  FontSize->12],
 " does when it writes out code."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
You can even use Unevaluated as a persistent head, but I don't recommend it \
for most cases.\
\>", "Subsubsection"],

Cell[TextData[{
 "Since ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 " is strange in acting differently depending on whether it's there before or \
after arg evaluation, I don't recommend using it as a persistent head until \
you're ",
 StyleBox["very",
  FontSlant->"Italic"],
 " comfortable with it.  Even then, someone who has to modify your code later \
might not be comfortable with it and might easily be misled into treating it \
like an ordinary head.\n\nIts ordinary use as an ephemeral flag is fine, and \
not likely to cause you any problems."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Related (another example of a more general issue) issue:  when to wrap \
incoming argument in Verbatim in case it's a pattern and you're going to pass \
it to a function that does use pattern semantics when given patterns.\
\>", "Subsubsection"],

Cell[TextData[{
 "A related issue:  if you are quite sure that an argument should always be \
considered a literal expression, never a pattern, then you'd better \
anticipate that a user could pass a pattern there.  For instance, I once \
wrote a function to take a list and give you a list of all its distinct \
elements together with the count of their occurrences in the list:  ",
 StyleBox["Frequencies", "Input",
  FontSize->12],
 "."
}], "Text"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{
    RowBox[{"Frequencies", "[", "list_", "]"}], " ", ":=", 
    "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{
      RowBox[{"{", 
       RowBox[{"#", ",", " ", 
        RowBox[{"Count", "[", 
         RowBox[{"list", ",", " ", "#"}], "]"}]}], "}"}], "&"}], " ", "/@", 
     " ", 
     RowBox[{"Union", "[", "list", "]"}]}]}], ";"}], 
  "\[IndentingNewLine]"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"(*", " ", 
   RowBox[{"Never", " ", "mind", " ", "that", " ", "this", " ", 
    RowBox[{"isn", "'"}], "t", " ", "as", " ", "efficient", " ", "as", " ", 
    "it", " ", "could", " ", "be", " ", "due", " ", 
    RowBox[{"to", " ", "'"}], 
    RowBox[{"Count", "'"}], " ", 
    RowBox[{"rescanning", " ", "'"}], 
    RowBox[{"list", "'"}]}], " ", "*)"}]}]}], "Input"],

Cell["This doesn't work if list contains some patterns!", "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"list", " ", "=", " ", 
   RowBox[{"{", 
    RowBox[{
    "1", ",", " ", "2.5", ",", " ", "2.5", ",", " ", "_Integer", ",", " ", 
     "_Integer", ",", " ", "_Real", ",", " ", "_Real", ",", " ", "_Real", ",",
      " ", "_Symbol", ",", " ", "_Symbol", ",", " ", "_Symbol"}], "}"}]}], 
  ";"}]], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Frequencies", "[", "list", "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"1", ",", "1"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"2.5`", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"_Integer", ",", "1"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"_Real", ",", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"_Symbol", ",", "0"}], "}"}]}], "}"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "Well, shucks!  ",
 StyleBox["_Symbol", "Input",
  FontSize->12],
 " occurs 3 times, not 0!  And this result implies that the original list had \
a total of 6 elements:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Plus", " ", "@@", " ", 
  RowBox[{"Map", "[", 
   RowBox[{"Last", ",", " ", "%"}], "]"}]}]], "Input"],

Cell[BoxData["6"], "Output"]
}, Open  ]],

Cell["when we know darn well it had more:", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Length", "[", "list", "]"}]], "Input"],

Cell[BoxData["11"], "Output"]
}, Open  ]]
}, Closed]]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Some examples", "Section"],

Cell["\<\
I will add quite a few examples from my scratch work in the next revision of \
this document.\
\>", "Text"],

Cell[CellGroupData[{

Cell["\<\
To analyze the code in a package:  read the statements from the file as a \
list of Hold[stmt]\
\>", "Subsubsection"],

Cell["\<\
Suppose you want to analyze usages in the package, e.g. symbols.\
\>", "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"heldStatements", " ", "=", " ", 
   RowBox[{"ReadList", "[", 
    RowBox[{"\"\<MyPackage.m\>\"", ",", " ", 
     RowBox[{"Hold", "[", "Expression", "]"}]}], "]"}]}], ";"}]], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
HoldCompleteForm:  a non-printing variant of HoldComplete (just as HoldForm \
is to Hold)\
\>", "Subsubsection"],

Cell[TextData[{
 StyleBox["MyHoldForm", "Input",
  FontSize->12],
 " is a little stronger than ",
 StyleBox["HoldForm", "Input",
  FontSize->12],
 ":\n\n(1)  Prevents ",
 StyleBox["Sequence", "Input",
  FontSize->12],
 " and ",
 StyleBox["Evaluate", "Input",
  FontSize->12],
 " wrappers on arguments intact (and ",
 StyleBox["Unevaluated", "Input",
  FontSize->12],
 ", but that's as much because of not calling any code on the args)\n\n(2)  \
Prevents  ",
 StyleBox["UpValues", "Input",
  FontSize->12],
 " of its arguments from firing and thus rewriting it."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"Attributes", "[", "HoldCompleteForm", "]"}], " ", "=", " ", 
   "HoldAllComplete"}], "\n"}], "\n", 
 RowBox[{
  RowBox[{"Format", "[", 
   RowBox[{"HoldCompleteForm", "[", "expr_", "]"}], "]"}], " ", ":=", " ", 
  RowBox[{"HoldForm", " ", "@", " ", 
   RowBox[{"HoldForm", "[", "expr", "]"}]}]}]}], "Input"],

Cell[BoxData["HoldAllComplete"], "Output"]
}, Open  ]],

Cell[TextData[{
 "This relies on the simple fact that anything deeper than level 1 in a \
holding container won't be touched even if it's wrapped in ",
 StyleBox["Evaluate", "Input",
  FontSize->12],
 " or ",
 StyleBox["Sequence", "Input",
  FontSize->12],
 ", or has ",
 StyleBox["UpValues", "Input",
  FontSize->12],
 ".  For instance:"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Hold", "[", 
  RowBox[{"{", 
   RowBox[{
    RowBox[{"Evaluate", "[", 
     RowBox[{"1", " ", "+", " ", "2"}], "]"}], ",", " ", 
    RowBox[{"Sequence", "[", 
     RowBox[{"3", ",", " ", "4"}], "]"}]}], "}"}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"Hold", "[", 
  RowBox[{"{", 
   RowBox[{
    RowBox[{"Evaluate", "[", 
     RowBox[{"1", "+", "2"}], "]"}], ",", 
    RowBox[{"Sequence", "[", 
     RowBox[{"3", ",", "4"}], "]"}]}], "}"}], "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Function", "[", 
  RowBox[{"e", ",", " ", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"Evaluate", "[", 
      RowBox[{"1", " ", "+", " ", "2"}], "]"}], ",", " ", 
     RowBox[{"Sequence", "[", 
      RowBox[{"3", ",", " ", "4"}], "]"}]}], "}"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"Function", "[", 
  RowBox[{"e", ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"Evaluate", "[", 
      RowBox[{"1", "+", "2"}], "]"}], ",", 
     RowBox[{"Sequence", "[", 
      RowBox[{"3", ",", "4"}], "]"}]}], "}"}]}], "]"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "Hence, there was no need to use two layers of ",
 StyleBox["Hold", "Input",
  FontSize->12],
 ".  I could have used a non-holding head at the inner level (though of \
course I want it to be non-printing):"
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Format", "[", 
   RowBox[{"HoldCompleteForm", "[", "expr_", "]"}], "]"}], " ", ":=", " ", 
  RowBox[{"HoldForm", " ", "@", " ", 
   RowBox[{"SequenceForm", "[", "expr", "]"}]}]}]], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"??", " ", "HoldCompleteForm"}]], "Input"],

Cell[BoxData["\<\"Global`HoldCompleteForm\"\>"], "Print"],

Cell[BoxData[
 InterpretationBox[GridBox[{
    {
     RowBox[{
      RowBox[{"Attributes", "[", "HoldCompleteForm", "]"}], "=", 
      RowBox[{"{", "HoldAllComplete", "}"}]}]},
    {" "},
    {GridBox[{
       {
        RowBox[{
         RowBox[{"MakeBoxes", "[", 
          RowBox[{"expr_", ",", "FormatType_"}], "]"}], "^:=", 
         RowBox[{"\<\"Format\"\>", "[", 
          RowBox[{
           RowBox[{"\<\"HoldForm\"\>", "[", 
            RowBox[{"\<\"SequenceForm\"\>", "[", "expr", "]"}], "]"}], ",", 
           "FormatType"}], "]"}]}]},
       {" "},
       {
        RowBox[{
         RowBox[{"\<\"Format\"\>", "[", "expr_", "]"}], ":=", 
         RowBox[{"\<\"HoldForm\"\>", "[", 
          RowBox[{"\<\"SequenceForm\"\>", "[", "expr", "]"}], "]"}]}]}
      },
      BaselinePosition->{Baseline, {1, 1}},
      GridBoxAlignment->{
       "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
        "RowsIndexed" -> {}},
      GridBoxItemSize->{"Columns" -> {{
           Scaled[0.999]}}, "ColumnsIndexed" -> {}, "Rows" -> {{1.}}, 
        "RowsIndexed" -> {}}]}
   },
   BaselinePosition->{Baseline, {1, 1}},
   GridBoxAlignment->{
    "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
     "RowsIndexed" -> {}}],
  Definition[HoldCompleteForm],
  Editable->False]], "Print"]
}, Open  ]],

Cell[TextData[{
 "But just as for ",
 StyleBox["HoldForm", "Input",
  FontSize->12],
 ", several args don't work.  If you want n args, you maybe want ",
 StyleBox["Sequence", "Input",
  FontSize->12],
 " as the displayed head, not sure.  If so, don't use ",
 StyleBox["SequenceForm", "Input",
  FontSize->12],
 ".\n(Though ",
 StyleBox["HoldForm", "Input",
  FontSize->12],
 " of n args may have printed as ",
 StyleBox["Sequence", "Input",
  FontSize->12],
 " in V2, not sure.)"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"HoldCompleteForm", "[", 
  RowBox[{
   RowBox[{"Evaluate", "[", 
    RowBox[{"1", " ", "+", " ", "2"}], "]"}], ",", " ", 
   RowBox[{"Sequence", "[", 
    RowBox[{"3", ",", " ", "4"}], "]"}]}], "]"}]], "Input"],

Cell[BoxData[
 RowBox[{"HoldCompleteForm", "[", 
  RowBox[{
   RowBox[{"Evaluate", "[", 
    RowBox[{"1", "+", "2"}], "]"}], ",", 
   RowBox[{"Sequence", "[", 
    RowBox[{"3", ",", "4"}], "]"}]}], "]"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"HoldCompleteForm", "[", 
    RowBox[{"Evaluate", "[", 
     RowBox[{"1", " ", "+", " ", "2"}], "]"}], "]"}], ",", " ", 
   RowBox[{"HoldCompleteForm", "[", 
    RowBox[{"Sequence", "[", 
     RowBox[{"3", ",", " ", "4"}], "]"}], "]"}]}], "}"}]], "Input"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   TagBox[
    InterpretationBox[
     RowBox[{"Evaluate", "[", 
      RowBox[{"1", "+", "2"}], "]"}],
     SequenceForm[
      Evaluate[1 + 2]],
     Editable->False],
    HoldForm], ",", 
   TagBox[
    InterpretationBox[
     RowBox[{"Sequence", "[", 
      RowBox[{"3", ",", "4"}], "]"}],
     SequenceForm[
      Sequence[3, 4]],
     Editable->False],
    HoldForm]}], "}"}]], "Output"]
}, Open  ]],

Cell[TextData[{
 "Another implementation of the ",
 StyleBox["Format", "Input",
  FontSize->12],
 " rule (following ",
 StyleBox["$Output", "Input",
  FontSize->12],
 " to be pedantic):\n[",
 StyleBox["Hmmm, ", "EditorialRemark"],
 StyleBox["$Output", "Input",
  FontSize->12],
 StyleBox[" likely has ", "EditorialRemark"],
 StyleBox["FormatType->StandardForm", "Input",
  FontSize->12],
 StyleBox[", which isn't what we want?  Revisit this...]", "EditorialRemark"]
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Format", "[", 
   RowBox[{"HoldCompleteForm", "[", "expr_", "]"}], "]"}], " ", ":=", " ", 
  RowBox[{"ToString", "[", 
   RowBox[{
    RowBox[{"Unevaluated", "[", "expr", "]"}], ",", " ", 
    RowBox[{"Sequence", " ", "@@", " ", 
     RowBox[{"Options", "[", "$Output", "]"}]}]}], "]"}]}]], "Input"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Format", "[", 
   RowBox[{"HoldCompleteForm", "[", "expr_", "]"}], "]"}], " ", ":=", " ", 
  RowBox[{"ToString", "[", 
   RowBox[{
    RowBox[{"Unevaluated", "[", "expr", "]"}], ",", " ", "OutputForm", ",", 
    " ", 
    RowBox[{"Sequence", " ", "@@", " ", 
     RowBox[{"Options", "[", "$Output", "]"}]}]}], "]"}]}]], "Input"],

Cell[TextData[{
 "But this implementation is not as correct, cuz it formats it as a string, \
whereas normally ",
 StyleBox["HoldForm", "Input",
  FontSize->12],
 " would format as an expression, which makes a difference if the output \
format is typeset.  The \"output format\" could be either the default (in ",
 StyleBox["$Output", "Input",
  FontSize->12],
 ") or a one-shot deal like ",
 StyleBox["expr //TraditionalForm", "Input",
  FontSize->12],
 ", at run-time, you just don't know."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Set and SetDelayed can be more flexible.", "Subsubsection"],

Cell[TextData[{
 "- Evaluate certain parts of ",
 StyleBox["SetDelayed", "Input",
  FontSize->12],
 " rhs as exceptions\n- Don't evaluate certain parts of ",
 StyleBox["Set", "Input",
  FontSize->12],
 " rhs as exceptions\n\n- Properly scope pattern vars of ",
 StyleBox["Set", "Input",
  FontSize->12],
 " when conducting assignment to be stored."
}], "Text"],

Cell["\<\
I will include these examples in the next revision of this document.\
\>", "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Temporarily deactivate kernel functions that open files for writing\
\>", "Subsubsection"],

Cell["\<\
Here's a crude \"scoping construct\" that deactivates file writing commands \
for the duration of execution of its body:\
\>", "Text"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"$FileWritingFunctions", "=", 
    RowBox[{"{", 
     RowBox[{
     "Put", ",", "PutAppend", ",", "OpenWrite", ",", "OpenAppend", ",", 
      "Save", ",", "DumpSave", ",", " ", "Splice", ",", "Display", ",", 
      "Write", ",", "WriteString", ",", "Encode"}], "}"}]}], ";"}], 
  "\[IndentingNewLine]"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{
    RowBox[{"Attributes", "[", "NoFiles", "]"}], "=", "HoldFirst"}], ";"}], 
  "\[IndentingNewLine]"}], "\n", 
 RowBox[{
  RowBox[{"NoFiles", "[", "expr_", "]"}], ":=", 
  RowBox[{
   RowBox[{"Unevaluated", "@", 
    RowBox[{"Block", "[", 
     RowBox[{"$FileWritingFunctions", ",", "expr"}], "]"}]}], "/.", 
   RowBox[{"OwnValues", "[", "$FileWritingFunctions", "]"}]}]}]}], "Input"],

Cell["\<\
This is untested, but it illustrates that you can implement your own \
debugging/testing tools with the techniques described in this talk.\
\>", "Text"]
}, Closed]]
}, Open  ]]
},
AutoGeneratedPackage->None,
Evaluator->"Local 4.0.2 (6S, 1 Sep 1999)",
WindowSize->{642, 688},
WindowMargins->{{Automatic, 164}, {Automatic, 0}},
PrintingPageRange->{Automatic, Automatic},
PrintingOptions->{"Magnification"->1,
"PaperOrientation"->"Portrait",
"PaperSize"->{612, 792},
"PostScriptOutputFile":>FrontEnd`FileName[{$RootDirectory, "mnt", "floppy"}, 
  "UnevaluatedExpressions.nb.ps", CharacterEncoding -> "ISO8859-1"]},
CellLabelAutoDelete->True,
SpellingOptions->{"AlwaysStop"->"RepeatedWords"},
SpellingDictionaries->{"CorrectWords"->{
 "heldElems", "elems", "patts", "factored", "held", "initializations", "expr",
   "iterand", "iter", "heldIterSpecs", "heldVars", "heldVarList", "ilim", 
  "Expr", "canonicalize", "Withoff", "Maeder", "formatter", "eval", "ni", 
  "Canonicalize", "args", "Args", "heldArgs", "heldPairs", "ls", 
  "heldDegrees", "ints", "nonInts", "heldDegreesNew", "heldSum", "argrx", 
  "arguments", "myexpr", "rhs", "Delaix", "Robby", "vars", "attrs", "exprs", 
  "fmt", "boxexpr", "cuz", "heldStatements", "var", "lhs", "subexprs", 
  "Hold'ing", "coeff", "outer", "levelspecs", "partspec", "posList", "Trott", 
  "Strzebonski", "jaggedTable", "heldTable", "meta", "for", "wasProtected", 
  "wget", "tgayley", "num", "x$", "Gotchas", "ssle", "Withoff's", "Hmmm", 
  "subexpr", "vs.", "args.", "by", "recursors", "iterator", "rgs", "control", 
  "uneval'n", "localvars", "vn", "scopers", "x$n.", "withoff", "funcs", 
  "mappings", "sym", "Attrs", "holdAttrs", "ordinaryHoldFuncs", "expr.", 
  "nHoldFuncs", "patt", "exprs.", "obj", "hmm", "scratchwork", "n_Integer", 
  "func", "x_String", "things_List", "opt", "x", "x_RawType", "where", 
  "isSymbol", "oom", "isn'", "rescanning", "list", "when", "musings", "x$10", 
  "dgbgn", "dgend", "res", "cont", "Dir", "heldDegreesSorted", 
  "heldDegreesGrouped", "Na", "demystify", "ei", "spam", "Villegas"}},
Magnification->1,
FrontEndVersion->"10.0 for Mac OS X x86 (32-bit, 64-bit Kernel) (December 4, \
2014)",
StyleDefinitions->Notebook[{
   Cell[
    CellGroupData[{
      Cell["Style Definitions", "Subtitle"], 
      Cell[
      "Modify the definitions below to change the default appearance of all \
cells in a given style.  Make modifications to any definition using commands \
in the Format menu.", "Text"], 
      Cell[
       CellGroupData[{
         Cell["Style Environment Names", "Section"], 
         Cell[
          StyleData[All, "Working"], PageWidth -> WindowWidth, 
          CellLabelMargins -> {{12, Inherited}, {Inherited, Inherited}}, 
          ScriptMinSize -> 9], 
         Cell[
          StyleData[All, "Presentation"], PageWidth -> WindowWidth, 
          CellLabelMargins -> {{24, Inherited}, {Inherited, Inherited}}, 
          ScriptMinSize -> 12], 
         Cell[
          StyleData[All, "Condensed"], PageWidth -> WindowWidth, 
          CellLabelMargins -> {{8, Inherited}, {Inherited, Inherited}}, 
          ScriptMinSize -> 8], 
         Cell[
          StyleData[All, "Printout"], PageWidth -> PaperWidth, 
          CellLabelMargins -> {{2, Inherited}, {Inherited, Inherited}}, 
          ScriptMinSize -> 5, 
          PrivateFontOptions -> {"FontType" -> "Outline"}]}, Closed]], 
      Cell[
       CellGroupData[{
         Cell["Notebook Options", "Section"], 
         Cell[
         "The options defined for the style below will be used at the \
Notebook level.", "Text"], 
         Cell[
          StyleData["Notebook"], PageHeaders -> {{
             Cell[
              TextData[{
                CounterBox["Page"]}], "PageNumber"], None, 
             Cell[
              TextData[{
                ValueBox["FileName"]}], "Header"]}, {
             Cell[
              TextData[{
                ValueBox["FileName"]}], "Header"], None, 
             Cell[
              TextData[{
                CounterBox["Page"]}], "PageNumber"]}}, CellFrameLabelMargins -> 
          6, StyleMenuListing -> None]}, Closed]], 
      Cell[
       CellGroupData[{
         Cell["Styles for Headings", "Section"], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Title"], CellMargins -> {{12, Inherited}, {20, 40}}, 
             CellGroupingRules -> {"TitleGrouping", 0}, PageBreakBelow -> 
             False, DefaultNewInlineCellStyle -> "None", 
             InputAutoReplacements -> {"TeX" -> StyleBox[
                 RowBox[{"T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "LaTeX" -> StyleBox[
                 RowBox[{"L", 
                   StyleBox[
                    AdjustmentBox[
                    "A", BoxMargins -> {{-0.36, -0.1}, {0, 0}}, 
                    BoxBaselineShift -> -0.2], FontSize -> Smaller], "T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "mma" -> "Mathematica", 
               "Mma" -> "Mathematica", "MMA" -> "Mathematica"}, 
             LanguageCategory -> "NaturalLanguage", CounterIncrements -> 
             "Title", 
             CounterAssignments -> {{"Section", 0}, {"Equation", 0}, {
               "Figure", 0}, {"Subtitle", 0}, {"Subsubtitle", 0}}, FontFamily -> 
             "Helvetica", FontSize -> 36, FontWeight -> "Bold"], 
            Cell[
             StyleData["Title", "Presentation"], 
             CellMargins -> {{24, 10}, {20, 40}}, LineSpacing -> {1, 0}, 
             FontSize -> 44], 
            Cell[
             StyleData["Title", "Condensed"], 
             CellMargins -> {{8, 10}, {4, 8}}, FontSize -> 20], 
            Cell[
             StyleData["Title", "Printout"], 
             CellMargins -> {{2, 10}, {12, 30}}, FontSize -> 24]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Subtitle"], 
             CellMargins -> {{12, Inherited}, {20, 15}}, 
             CellGroupingRules -> {"TitleGrouping", 10}, PageBreakBelow -> 
             False, DefaultNewInlineCellStyle -> "None", 
             InputAutoReplacements -> {"TeX" -> StyleBox[
                 RowBox[{"T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "LaTeX" -> StyleBox[
                 RowBox[{"L", 
                   StyleBox[
                    AdjustmentBox[
                    "A", BoxMargins -> {{-0.36, -0.1}, {0, 0}}, 
                    BoxBaselineShift -> -0.2], FontSize -> Smaller], "T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "mma" -> "Mathematica", 
               "Mma" -> "Mathematica", "MMA" -> "Mathematica"}, 
             LanguageCategory -> "NaturalLanguage", CounterIncrements -> 
             "Subtitle", 
             CounterAssignments -> {{"Section", 0}, {"Equation", 0}, {
               "Figure", 0}, {"Subsubtitle", 0}}, FontFamily -> "Helvetica", 
             FontSize -> 30, FontWeight -> "Bold"], 
            Cell[
             StyleData["Subtitle", "Presentation"], 
             CellMargins -> {{24, 10}, {20, 20}}, LineSpacing -> {1, 0}, 
             FontSize -> 36], 
            Cell[
             StyleData["Subtitle", "Condensed"], 
             CellMargins -> {{8, 10}, {4, 4}}, FontSize -> 14], 
            Cell[
             StyleData["Subtitle", "Printout"], 
             CellMargins -> {{2, 10}, {12, 8}}, FontSize -> 18]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Subsubtitle"], 
             CellMargins -> {{12, Inherited}, {20, 15}}, 
             CellGroupingRules -> {"TitleGrouping", 20}, PageBreakBelow -> 
             False, DefaultNewInlineCellStyle -> "None", 
             InputAutoReplacements -> {"TeX" -> StyleBox[
                 RowBox[{"T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "LaTeX" -> StyleBox[
                 RowBox[{"L", 
                   StyleBox[
                    AdjustmentBox[
                    "A", BoxMargins -> {{-0.36, -0.1}, {0, 0}}, 
                    BoxBaselineShift -> -0.2], FontSize -> Smaller], "T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "mma" -> "Mathematica", 
               "Mma" -> "Mathematica", "MMA" -> "Mathematica"}, 
             LanguageCategory -> "NaturalLanguage", CounterIncrements -> 
             "Subsubtitle", 
             CounterAssignments -> {{"Section", 0}, {"Equation", 0}, {
               "Figure", 0}}, FontFamily -> "Helvetica", FontSize -> 24, 
             FontWeight -> "Bold", FontSlant -> "Plain"], 
            Cell[
             StyleData["Subsubtitle", "Presentation"], 
             CellMargins -> {{24, 10}, {20, 20}}, LineSpacing -> {1, 0}, 
             FontSize -> 24], 
            Cell[
             StyleData["Subsubtitle", "Condensed"], 
             CellMargins -> {{8, 10}, {8, 8}}, FontSize -> 12], 
            Cell[
             StyleData["Subsubtitle", "Printout"], 
             CellMargins -> {{2, 10}, {12, 8}}, FontSize -> 14]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Section"], CellDingbat -> "\[FilledSquare]", 
             CellMargins -> {{25, Inherited}, {8, 24}}, 
             CellGroupingRules -> {"SectionGrouping", 30}, PageBreakBelow -> 
             False, DefaultNewInlineCellStyle -> "None", 
             InputAutoReplacements -> {"TeX" -> StyleBox[
                 RowBox[{"T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "LaTeX" -> StyleBox[
                 RowBox[{"L", 
                   StyleBox[
                    AdjustmentBox[
                    "A", BoxMargins -> {{-0.36, -0.1}, {0, 0}}, 
                    BoxBaselineShift -> -0.2], FontSize -> Smaller], "T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "mma" -> "Mathematica", 
               "Mma" -> "Mathematica", "MMA" -> "Mathematica"}, 
             LanguageCategory -> "NaturalLanguage", CounterIncrements -> 
             "Section", 
             CounterAssignments -> {{"Subsection", 0}, {"Subsubsection", 0}}, 
             FontFamily -> "Helvetica", FontSize -> 24, FontWeight -> "Bold"], 
            Cell[
             StyleData["Section", "Presentation"], 
             CellMargins -> {{40, 10}, {11, 32}}, LineSpacing -> {1, 0}, 
             FontSize -> 24], 
            Cell[
             StyleData["Section", "Condensed"], 
             CellMargins -> {{18, Inherited}, {6, 12}}, FontSize -> 12], 
            Cell[
             StyleData["Section", "Printout"], 
             CellMargins -> {{13, 0}, {7, 22}}, FontSize -> 14]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Subsection"], CellDingbat -> "\[FilledSmallSquare]", 
             CellMargins -> {{22, Inherited}, {8, 20}}, 
             CellGroupingRules -> {"SectionGrouping", 40}, PageBreakBelow -> 
             False, DefaultNewInlineCellStyle -> "None", 
             InputAutoReplacements -> {"TeX" -> StyleBox[
                 RowBox[{"T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "LaTeX" -> StyleBox[
                 RowBox[{"L", 
                   StyleBox[
                    AdjustmentBox[
                    "A", BoxMargins -> {{-0.36, -0.1}, {0, 0}}, 
                    BoxBaselineShift -> -0.2], FontSize -> Smaller], "T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "mma" -> "Mathematica", 
               "Mma" -> "Mathematica", "MMA" -> "Mathematica"}, 
             LanguageCategory -> "NaturalLanguage", CounterIncrements -> 
             "Subsection", CounterAssignments -> {{"Subsubsection", 0}}, 
             FontFamily -> "Times", FontSize -> 18, FontWeight -> "Bold"], 
            Cell[
             StyleData["Subsection", "Presentation"], 
             CellMargins -> {{36, 10}, {11, 32}}, LineSpacing -> {1, 0}, 
             FontSize -> 22], 
            Cell[
             StyleData["Subsection", "Condensed"], 
             CellMargins -> {{16, Inherited}, {6, 12}}, FontSize -> 12], 
            Cell[
             StyleData["Subsection", "Printout"], 
             CellMargins -> {{9, 0}, {7, 22}}, FontSize -> 12]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Subsubsection"], CellDingbat -> 
             "\[FilledSmallSquare]", 
             CellMargins -> {{22, Inherited}, {8, 18}}, 
             CellGroupingRules -> {"SectionGrouping", 50}, PageBreakBelow -> 
             False, DefaultNewInlineCellStyle -> "None", 
             InputAutoReplacements -> {"TeX" -> StyleBox[
                 RowBox[{"T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "LaTeX" -> StyleBox[
                 RowBox[{"L", 
                   StyleBox[
                    AdjustmentBox[
                    "A", BoxMargins -> {{-0.36, -0.1}, {0, 0}}, 
                    BoxBaselineShift -> -0.2], FontSize -> Smaller], "T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "mma" -> "Mathematica", 
               "Mma" -> "Mathematica", "MMA" -> "Mathematica"}, 
             LanguageCategory -> "NaturalLanguage", CounterIncrements -> 
             "Subsubsection", FontFamily -> "Times", FontSize -> 16, 
             FontWeight -> "Bold"], 
            Cell[
             StyleData["Subsubsection", "Presentation"], 
             CellMargins -> {{34, 10}, {11, 26}}, LineSpacing -> {1, 0}, 
             FontSize -> 18], 
            Cell[
             StyleData["Subsubsection", "Condensed"], 
             CellMargins -> {{17, Inherited}, {6, 12}}, FontSize -> 10], 
            Cell[
             StyleData["Subsubsection", "Printout"], 
             CellMargins -> {{9, 0}, {7, 14}}, FontSize -> 11]}, Closed]]}, 
        Open]], 
      Cell[
       CellGroupData[{
         Cell["Styles for Body Text", "Section"], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Text"], CellMargins -> {{12, 10}, {7, 7}}, 
             InputAutoReplacements -> {"TeX" -> StyleBox[
                 RowBox[{"T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "LaTeX" -> StyleBox[
                 RowBox[{"L", 
                   StyleBox[
                    AdjustmentBox[
                    "A", BoxMargins -> {{-0.36, -0.1}, {0, 0}}, 
                    BoxBaselineShift -> -0.2], FontSize -> Smaller], "T", 
                   AdjustmentBox[
                   "E", BoxMargins -> {{-0.075, -0.085}, {0, 0}}, 
                    BoxBaselineShift -> 0.5], "X"}]], "mma" -> "Mathematica", 
               "Mma" -> "Mathematica", "MMA" -> "Mathematica"}, Hyphenation -> 
             True, LineSpacing -> {1, 3}, CounterIncrements -> "Text", 
             FontSize -> 14], 
            Cell[
             StyleData["Text", "Presentation"], 
             CellMargins -> {{24, 10}, {10, 10}}, LineSpacing -> {1, 5}, 
             FontSize -> 16], 
            Cell[
             StyleData["Text", "Condensed"], CellMargins -> {{8, 10}, {6, 6}},
              LineSpacing -> {1, 1}, FontSize -> 11], 
            Cell[
             StyleData["Text", "Printout"], CellMargins -> {{2, 2}, {6, 6}}, 
             TextJustification -> 0.5, FontSize -> 10]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["SmallText"], CellMargins -> {{12, 10}, {6, 6}}, 
             DefaultNewInlineCellStyle -> "None", Hyphenation -> True, 
             LineSpacing -> {1, 3}, LanguageCategory -> "NaturalLanguage", 
             CounterIncrements -> "SmallText", FontFamily -> "Helvetica", 
             FontSize -> 10], 
            Cell[
             StyleData["SmallText", "Presentation"], 
             CellMargins -> {{24, 10}, {8, 8}}, LineSpacing -> {1, 5}, 
             FontSize -> 12], 
            Cell[
             StyleData["SmallText", "Condensed"], 
             CellMargins -> {{8, 10}, {5, 5}}, LineSpacing -> {1, 2}, 
             FontSize -> 9], 
            Cell[
             StyleData["SmallText", "Printout"], 
             CellMargins -> {{2, 2}, {5, 5}}, TextJustification -> 0.5, 
             FontSize -> 7]}, Closed]]}, Closed]], 
      Cell[
       CellGroupData[{
         Cell["Styles for Input/Output", "Section"], 
         Cell[
         "The cells in this section define styles used for input and output \
to the kernel.  Be careful when modifying, renaming, or removing these \
styles, because the front end associates special meanings with these style \
names. Some attributes for these styles are actually set in FormatType Styles \
(in the last section of this stylesheet). ", "Text"], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Input"], CellMargins -> {{45, 10}, {5, 7}}, 
             Evaluatable -> True, CellGroupingRules -> "InputGrouping", 
             CellHorizontalScrolling -> True, PageBreakWithin -> False, 
             GroupPageBreakWithin -> False, DefaultFormatType -> 
             DefaultInputFormatType, 
             HyphenationOptions -> {
              "HyphenationCharacter" -> "\[Continuation]"}, 
             AutoItalicWords -> {}, LanguageCategory -> "Formula", FormatType -> 
             InputForm, ShowStringCharacters -> True, NumberMarks -> True, 
             LinebreakAdjustments -> {0.85, 2, 10, 0, 1}, CounterIncrements -> 
             "Input", FontWeight -> "Bold"], 
            Cell[
             StyleData["Input", "Presentation"], 
             CellMargins -> {{72, Inherited}, {8, 10}}, LineSpacing -> {1, 0},
              FontSize -> 16], 
            Cell[
             StyleData["Input", "Condensed"], 
             CellMargins -> {{40, 10}, {2, 3}}, FontSize -> 11], 
            Cell[
             StyleData["Input", "Printout"], CellMargins -> {{39, 0}, {4, 6}},
              LinebreakAdjustments -> {0.85, 2, 10, 1, 1}, FontSize -> 9]}, 
           Closed]], 
         Cell[
          StyleData["InputOnly"], Evaluatable -> True, CellGroupingRules -> 
          "InputGrouping", CellHorizontalScrolling -> True, DefaultFormatType -> 
          DefaultInputFormatType, 
          HyphenationOptions -> {"HyphenationCharacter" -> "\[Continuation]"},
           AutoItalicWords -> {}, LanguageCategory -> "Formula", FormatType -> 
          InputForm, ShowStringCharacters -> True, NumberMarks -> True, 
          LinebreakAdjustments -> {0.85, 2, 10, 0, 1}, CounterIncrements -> 
          "Input", StyleMenuListing -> None, FontWeight -> "Bold"], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Output"], CellMargins -> {{47, 10}, {7, 5}}, 
             CellEditDuplicate -> True, CellGroupingRules -> "OutputGrouping",
              CellHorizontalScrolling -> True, PageBreakWithin -> False, 
             GroupPageBreakWithin -> False, GeneratedCell -> True, 
             CellAutoOverwrite -> True, DefaultFormatType -> 
             DefaultOutputFormatType, 
             HyphenationOptions -> {
              "HyphenationCharacter" -> "\[Continuation]"}, 
             AutoItalicWords -> {}, LanguageCategory -> "Formula", FormatType -> 
             InputForm, CounterIncrements -> "Output"], 
            Cell[
             StyleData["Output", "Presentation"], 
             CellMargins -> {{72, Inherited}, {10, 8}}, LineSpacing -> {1, 0},
              FontSize -> 16], 
            Cell[
             StyleData["Output", "Condensed"], 
             CellMargins -> {{41, Inherited}, {3, 2}}, FontSize -> 11], 
            Cell[
             StyleData["Output", "Printout"], 
             CellMargins -> {{39, 0}, {6, 4}}, FontSize -> 9]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Message"], 
             CellMargins -> {{45, Inherited}, {Inherited, Inherited}}, 
             CellGroupingRules -> "OutputGrouping", PageBreakWithin -> False, 
             GroupPageBreakWithin -> False, GeneratedCell -> True, 
             CellAutoOverwrite -> True, ShowCellLabel -> False, 
             DefaultFormatType -> DefaultOutputFormatType, 
             HyphenationOptions -> {
              "HyphenationCharacter" -> "\[Continuation]"}, 
             AutoItalicWords -> {}, FormatType -> InputForm, 
             CounterIncrements -> "Message", StyleMenuListing -> None, 
             FontSize -> 11, FontColor -> RGBColor[0, 0, 1]], 
            Cell[
             StyleData["Message", "Presentation"], 
             CellMargins -> {{72, Inherited}, {Inherited, Inherited}}, 
             LineSpacing -> {1, 0}, FontSize -> 16], 
            Cell[
             StyleData["Message", "Condensed"], 
             CellMargins -> {{41, Inherited}, {Inherited, Inherited}}, 
             FontSize -> 11], 
            Cell[
             StyleData["Message", "Printout"], 
             CellMargins -> {{39, Inherited}, {Inherited, Inherited}}, 
             FontSize -> 7, FontColor -> GrayLevel[0]]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Print"], 
             CellMargins -> {{45, Inherited}, {Inherited, Inherited}}, 
             CellGroupingRules -> "OutputGrouping", CellHorizontalScrolling -> 
             True, PageBreakWithin -> False, GroupPageBreakWithin -> False, 
             GeneratedCell -> True, CellAutoOverwrite -> True, ShowCellLabel -> 
             False, DefaultFormatType -> DefaultOutputFormatType, 
             HyphenationOptions -> {
              "HyphenationCharacter" -> "\[Continuation]"}, 
             AutoItalicWords -> {}, FormatType -> InputForm, 
             CounterIncrements -> "Print", StyleMenuListing -> None], 
            Cell[
             StyleData["Print", "Presentation"], 
             CellMargins -> {{72, Inherited}, {Inherited, Inherited}}, 
             LineSpacing -> {1, 0}, FontSize -> 16], 
            Cell[
             StyleData["Print", "Condensed"], 
             CellMargins -> {{41, Inherited}, {Inherited, Inherited}}, 
             FontSize -> 11], 
            Cell[
             StyleData["Print", "Printout"], 
             CellMargins -> {{39, Inherited}, {Inherited, Inherited}}, 
             FontSize -> 8]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Graphics"], 
             CellMargins -> {{4, Inherited}, {Inherited, Inherited}}, 
             CellGroupingRules -> "GraphicsGrouping", CellHorizontalScrolling -> 
             True, PageBreakWithin -> False, GeneratedCell -> True, 
             CellAutoOverwrite -> True, ShowCellLabel -> False, 
             DefaultFormatType -> DefaultOutputFormatType, LanguageCategory -> 
             None, FormatType -> InputForm, CounterIncrements -> "Graphics", 
             ImageMargins -> {{43, Inherited}, {Inherited, 0}}, 
             StyleMenuListing -> None, FontFamily -> "Courier", FontSize -> 
             10], 
            Cell[
             StyleData["Graphics", "Presentation"], 
             ImageMargins -> {{62, Inherited}, {Inherited, 0}}], 
            Cell[
             StyleData["Graphics", "Condensed"], 
             ImageMargins -> {{38, Inherited}, {Inherited, 0}}, Magnification -> 
             0.6], 
            Cell[
             StyleData["Graphics", "Printout"], 
             ImageMargins -> {{30, Inherited}, {Inherited, 0}}, Magnification -> 
             0.8]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["CellLabel"], StyleMenuListing -> None, FontFamily -> 
             "Helvetica", FontSize -> 9, FontColor -> RGBColor[0, 0, 1]], 
            Cell[
             StyleData["CellLabel", "Presentation"], FontSize -> 12], 
            Cell[
             StyleData["CellLabel", "Condensed"], FontSize -> 9], 
            Cell[
             StyleData["CellLabel", "Printout"], FontFamily -> "Courier", 
             FontSize -> 8, FontSlant -> "Italic", FontColor -> 
             GrayLevel[0]]}, Closed]]}, Closed]], 
      Cell[
       CellGroupData[{
         Cell["Inline Formatting", "Section"], 
         Cell[
         "These styles are for modifying individual words or letters in a \
cell exclusive of the cell tag.", "Text"], 
         Cell[
          StyleData["RM"], StyleMenuListing -> None, FontWeight -> "Plain", 
          FontSlant -> "Plain"], 
         Cell[
          StyleData["BF"], StyleMenuListing -> None, FontWeight -> "Bold"], 
         Cell[
          StyleData["IT"], StyleMenuListing -> None, FontSlant -> "Italic"], 
         Cell[
          StyleData["TR"], StyleMenuListing -> None, FontFamily -> "Times", 
          FontWeight -> "Plain", FontSlant -> "Plain"], 
         Cell[
          StyleData["TI"], StyleMenuListing -> None, FontFamily -> "Times", 
          FontWeight -> "Plain", FontSlant -> "Italic"], 
         Cell[
          StyleData["TB"], StyleMenuListing -> None, FontFamily -> "Times", 
          FontWeight -> "Bold", FontSlant -> "Plain"], 
         Cell[
          StyleData["TBI"], StyleMenuListing -> None, FontFamily -> "Times", 
          FontWeight -> "Bold", FontSlant -> "Italic"], 
         Cell[
          StyleData["MR"], StyleMenuListing -> None, FontFamily -> "Courier", 
          FontWeight -> "Plain", FontSlant -> "Plain"], 
         Cell[
          StyleData["MO"], StyleMenuListing -> None, FontFamily -> "Courier", 
          FontWeight -> "Plain", FontSlant -> "Italic"], 
         Cell[
          StyleData["MB"], StyleMenuListing -> None, FontFamily -> "Courier", 
          FontWeight -> "Bold", FontSlant -> "Plain"], 
         Cell[
          StyleData["MBO"], StyleMenuListing -> None, FontFamily -> "Courier",
           FontWeight -> "Bold", FontSlant -> "Italic"], 
         Cell[
          StyleData["SR"], StyleMenuListing -> None, FontFamily -> 
          "Helvetica", FontWeight -> "Plain", FontSlant -> "Plain"], 
         Cell[
          StyleData["SO"], StyleMenuListing -> None, FontFamily -> 
          "Helvetica", FontWeight -> "Plain", FontSlant -> "Italic"], 
         Cell[
          StyleData["SB"], StyleMenuListing -> None, FontFamily -> 
          "Helvetica", FontWeight -> "Bold", FontSlant -> "Plain"], 
         Cell[
          StyleData["SBO"], StyleMenuListing -> None, FontFamily -> 
          "Helvetica", FontWeight -> "Bold", FontSlant -> "Italic"], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["SO10"], StyleMenuListing -> None, FontFamily -> 
             "Helvetica", FontSize -> 10, FontWeight -> "Plain", FontSlant -> 
             "Italic"], 
            Cell[
             StyleData["SO10", "Printout"], StyleMenuListing -> None, 
             FontFamily -> "Helvetica", FontSize -> 7, FontWeight -> "Plain", 
             FontSlant -> "Italic"], 
            Cell[
             StyleData["SO10", "EnhancedPrintout"], StyleMenuListing -> None, 
             FontFamily -> "Futura", FontSize -> 7, FontWeight -> "Plain", 
             FontSlant -> "Italic"]}, Closed]]}, Closed]], 
      Cell[
       CellGroupData[{
         Cell["Formulas and Programming", "Section"], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["InlineFormula"], CellMargins -> {{10, 4}, {0, 8}}, 
             CellHorizontalScrolling -> True, 
             HyphenationOptions -> {
              "HyphenationCharacter" -> "\[Continuation]"}, LanguageCategory -> 
             "Formula", ScriptLevel -> 1, SingleLetterItalics -> True], 
            Cell[
             StyleData["InlineFormula", "Presentation"], 
             CellMargins -> {{24, 10}, {10, 10}}, LineSpacing -> {1, 5}, 
             FontSize -> 16], 
            Cell[
             StyleData["InlineFormula", "Condensed"], 
             CellMargins -> {{8, 10}, {6, 6}}, LineSpacing -> {1, 1}, 
             FontSize -> 11], 
            Cell[
             StyleData["InlineFormula", "Printout"], 
             CellMargins -> {{2, 0}, {6, 6}}, FontSize -> 10]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["DisplayFormula"], 
             CellMargins -> {{42, Inherited}, {Inherited, Inherited}}, 
             CellHorizontalScrolling -> True, DefaultFormatType -> 
             DefaultInputFormatType, 
             HyphenationOptions -> {
              "HyphenationCharacter" -> "\[Continuation]"}, LanguageCategory -> 
             "Formula", ScriptLevel -> 0, SingleLetterItalics -> True, 
             UnderoverscriptBoxOptions -> {LimitsPositioning -> True}], 
            Cell[
             StyleData["DisplayFormula", "Presentation"], 
             LineSpacing -> {1, 5}, FontSize -> 16], 
            Cell[
             StyleData["DisplayFormula", "Condensed"], LineSpacing -> {1, 1}, 
             FontSize -> 11], 
            Cell[
             StyleData["DisplayFormula", "Printout"], FontSize -> 10]}, 
           Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Program"], CellFrame -> {{0, 0}, {0.5, 0.5}}, 
             CellMargins -> {{10, 4}, {0, 8}}, CellHorizontalScrolling -> 
             True, Hyphenation -> False, LanguageCategory -> "Formula", 
             ScriptLevel -> 1, FontFamily -> "Courier"], 
            Cell[
             StyleData["Program", "Presentation"], 
             CellMargins -> {{24, 10}, {10, 10}}, LineSpacing -> {1, 5}, 
             FontSize -> 16], 
            Cell[
             StyleData["Program", "Condensed"], 
             CellMargins -> {{8, 10}, {6, 6}}, LineSpacing -> {1, 1}, 
             FontSize -> 11], 
            Cell[
             StyleData["Program", "Printout"], 
             CellMargins -> {{2, 0}, {6, 6}}, FontSize -> 9]}, Closed]]}, 
        Closed]], 
      Cell[
       CellGroupData[{
         Cell["Hyperlink Styles", "Section"], 
         Cell[
         "The cells below define styles useful for making hypertext \
ButtonBoxes.  The \"Hyperlink\" style is for links within the same Notebook, \
or between Notebooks.", "Text"], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Hyperlink"], StyleMenuListing -> None, 
             ButtonStyleMenuListing -> Automatic, 
             FontVariations -> {"Underline" -> True}, FontColor -> 
             RGBColor[0, 0, 1], 
             ButtonBoxOptions -> {
              Active -> True, ButtonFunction :> (FrontEndExecute[{
                  FrontEnd`NotebookLocate[#2]}]& ), ButtonNote -> 
               ButtonData}], 
            Cell[
             StyleData["Hyperlink", "Presentation"], FontSize -> 16], 
            Cell[
             StyleData["Hyperlink", "Condensed"], FontSize -> 11], 
            Cell[
             StyleData["Hyperlink", "Printout"], FontSize -> 10, 
             FontVariations -> {"Underline" -> False}, FontColor -> 
             GrayLevel[0]]}, Closed]], 
         Cell[
         "The following styles are for linking automatically to the on-line \
help system.", "Text"], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["MainBookLink"], StyleMenuListing -> None, 
             ButtonStyleMenuListing -> Automatic, 
             FontVariations -> {"Underline" -> True}, FontColor -> 
             RGBColor[0, 0, 1], 
             ButtonBoxOptions -> {
              Active -> True, Appearance -> {Automatic, None}, 
               ButtonFunction :> (FrontEndExecute[{
                  FrontEnd`HelpBrowserLookup["MainBook", #]}]& )}], 
            Cell[
             StyleData["MainBookLink", "Presentation"], FontSize -> 16], 
            Cell[
             StyleData["MainBookLink", "Condensed"], FontSize -> 11], 
            Cell[
             StyleData["MainBookLink", "Printout"], FontSize -> 10, 
             FontVariations -> {"Underline" -> False}, FontColor -> 
             GrayLevel[0]]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["AddOnsLink"], StyleMenuListing -> None, 
             ButtonStyleMenuListing -> Automatic, FontFamily -> "Courier", 
             FontVariations -> {"Underline" -> True}, FontColor -> 
             RGBColor[0, 0, 1], 
             ButtonBoxOptions -> {
              Active -> True, Appearance -> {Automatic, None}, 
               ButtonFunction :> (FrontEndExecute[{
                  FrontEnd`HelpBrowserLookup["AddOns", #]}]& )}], 
            Cell[
             StyleData["AddOnsLink", "Presentation"], FontSize -> 16], 
            Cell[
             StyleData["AddOnsLink", "Condensed"], FontSize -> 11], 
            Cell[
             StyleData["AddOnsLink", "Printout"], FontSize -> 10, 
             FontVariations -> {"Underline" -> False}, FontColor -> 
             GrayLevel[0]]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["RefGuideLink"], StyleMenuListing -> None, 
             ButtonStyleMenuListing -> Automatic, FontFamily -> "Courier", 
             FontVariations -> {"Underline" -> True}, FontColor -> 
             RGBColor[0, 0, 1], 
             ButtonBoxOptions -> {
              Active -> True, Appearance -> {Automatic, None}, 
               ButtonFunction :> (FrontEndExecute[{
                  FrontEnd`HelpBrowserLookup["RefGuide", #]}]& )}], 
            Cell[
             StyleData["RefGuideLink", "Presentation"], FontSize -> 16], 
            Cell[
             StyleData["RefGuideLink", "Condensed"], FontSize -> 11], 
            Cell[
             StyleData["RefGuideLink", "Printout"], FontSize -> 10, 
             FontVariations -> {"Underline" -> False}, FontColor -> 
             GrayLevel[0]]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["GettingStartedLink"], StyleMenuListing -> None, 
             ButtonStyleMenuListing -> Automatic, 
             FontVariations -> {"Underline" -> True}, FontColor -> 
             RGBColor[0, 0, 1], 
             ButtonBoxOptions -> {
              Active -> True, Appearance -> {Automatic, None}, 
               ButtonFunction :> (FrontEndExecute[{
                  FrontEnd`HelpBrowserLookup["GettingStarted", #]}]& )}], 
            Cell[
             StyleData["GettingStartedLink", "Presentation"], FontSize -> 16], 
            Cell[
             StyleData["GettingStartedLink", "Condensed"], FontSize -> 11], 
            Cell[
             StyleData["GettingStartedLink", "Printout"], FontSize -> 10, 
             FontVariations -> {"Underline" -> False}, FontColor -> 
             GrayLevel[0]]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["OtherInformationLink"], StyleMenuListing -> None, 
             ButtonStyleMenuListing -> Automatic, 
             FontVariations -> {"Underline" -> True}, FontColor -> 
             RGBColor[0, 0, 1], 
             ButtonBoxOptions -> {
              Active -> True, Appearance -> {Automatic, None}, 
               ButtonFunction :> (FrontEndExecute[{
                  FrontEnd`HelpBrowserLookup["OtherInformation", #]}]& )}], 
            Cell[
             StyleData["OtherInformationLink", "Presentation"], FontSize -> 
             16], 
            Cell[
             StyleData["OtherInformationLink", "Condensed"], FontSize -> 11], 
            
            Cell[
             StyleData["OtherInformationLink", "Printout"], FontSize -> 10, 
             FontVariations -> {"Underline" -> False}, FontColor -> 
             GrayLevel[0]]}, Closed]]}, Closed]], 
      Cell[
       CellGroupData[{
         Cell["Styles for Headers and Footers", "Section"], 
         Cell[
          StyleData["Header"], CellMargins -> {{0, 0}, {4, 1}}, 
          DefaultNewInlineCellStyle -> "None", LanguageCategory -> 
          "NaturalLanguage", StyleMenuListing -> None, FontSize -> 10, 
          FontSlant -> "Italic"], 
         Cell[
          StyleData["Footer"], CellMargins -> {{0, 0}, {0, 4}}, 
          DefaultNewInlineCellStyle -> "None", LanguageCategory -> 
          "NaturalLanguage", StyleMenuListing -> None, FontSize -> 9, 
          FontSlant -> "Italic"], 
         Cell[
          StyleData["PageNumber"], CellMargins -> {{0, 0}, {4, 1}}, 
          StyleMenuListing -> None, FontFamily -> "Times", FontSize -> 10]}, 
        Closed]], 
      Cell[
       CellGroupData[{
         Cell["Palette Styles", "Section"], 
         Cell[
         "The cells below define styles that define standard ButtonFunctions, \
for use in palette buttons.", "Text"], 
         Cell[
          StyleData["Paste"], StyleMenuListing -> None, 
          ButtonStyleMenuListing -> Automatic, 
          ButtonBoxOptions -> {ButtonFunction :> (FrontEndExecute[{
               FrontEnd`NotebookApply[
                FrontEnd`InputNotebook[], #, After]}]& )}], 
         Cell[
          StyleData["Evaluate"], StyleMenuListing -> None, 
          ButtonStyleMenuListing -> Automatic, 
          ButtonBoxOptions -> {ButtonFunction :> (FrontEndExecute[{
               FrontEnd`NotebookApply[
                FrontEnd`InputNotebook[], #, All], 
               SelectionEvaluate[
                FrontEnd`InputNotebook[], All]}]& )}], 
         Cell[
          StyleData["EvaluateCell"], StyleMenuListing -> None, 
          ButtonStyleMenuListing -> Automatic, 
          ButtonBoxOptions -> {ButtonFunction :> (FrontEndExecute[{
               FrontEnd`NotebookApply[
                FrontEnd`InputNotebook[], #, All], 
               FrontEnd`SelectionMove[
                FrontEnd`InputNotebook[], All, Cell, 1], 
               FrontEnd`SelectionEvaluateCreateCell[
                FrontEnd`InputNotebook[], All]}]& )}], 
         Cell[
          StyleData["CopyEvaluate"], StyleMenuListing -> None, 
          ButtonStyleMenuListing -> Automatic, 
          ButtonBoxOptions -> {ButtonFunction :> (FrontEndExecute[{
               FrontEnd`SelectionCreateCell[
                FrontEnd`InputNotebook[], All], 
               FrontEnd`NotebookApply[
                FrontEnd`InputNotebook[], #, All], 
               FrontEnd`SelectionEvaluate[
                FrontEnd`InputNotebook[], All]}]& )}], 
         Cell[
          StyleData["CopyEvaluateCell"], StyleMenuListing -> None, 
          ButtonStyleMenuListing -> Automatic, 
          ButtonBoxOptions -> {ButtonFunction :> (FrontEndExecute[{
               FrontEnd`SelectionCreateCell[
                FrontEnd`InputNotebook[], All], 
               FrontEnd`NotebookApply[
                FrontEnd`InputNotebook[], #, All], 
               FrontEnd`SelectionEvaluateCreateCell[
                FrontEnd`InputNotebook[], All]}]& )}]}, Closed]], 
      Cell[
       CellGroupData[{
         Cell["Placeholder Styles", "Section"], 
         Cell[
         "The cells below define styles useful for making placeholder objects \
in palette templates.", "Text"], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["Placeholder"], Placeholder -> True, StyleMenuListing -> 
             None, FontSlant -> "Italic", FontColor -> 
             RGBColor[0.890623, 0.864698, 0.384756], 
             TagBoxOptions -> {
              Editable -> False, Selectable -> False, StripWrapperBoxes -> 
               False}], 
            Cell[
             StyleData["Placeholder", "Presentation"]], 
            Cell[
             StyleData["Placeholder", "Condensed"]], 
            Cell[
             StyleData["Placeholder", "Printout"]]}, Closed]], 
         Cell[
          CellGroupData[{
            Cell[
             StyleData["PrimaryPlaceholder"], StyleMenuListing -> None, 
             DrawHighlighted -> True, FontSlant -> "Italic", Background -> 
             RGBColor[0.912505, 0.891798, 0.507774], 
             TagBoxOptions -> {
              Editable -> False, Selectable -> False, StripWrapperBoxes -> 
               False}], 
            Cell[
             StyleData["PrimaryPlaceholder", "Presentation"]], 
            Cell[
             StyleData["PrimaryPlaceholder", "Condensed"]], 
            Cell[
             StyleData["PrimaryPlaceholder", "Printout"]]}, Closed]]}, 
        Closed]], 
      Cell[
       CellGroupData[{
         Cell["FormatType Styles", "Section"], 
         Cell[
         "The cells below define styles that are mixed in with the styles of \
most cells.  If a cell's FormatType matches the name of one of the styles \
defined below, then that style is applied between the cell's style and its \
own options. This is particularly true of Input and Output.", "Text"], 
         Cell[
          StyleData["CellExpression"], PageWidth -> Infinity, 
          CellMargins -> {{6, Inherited}, {Inherited, Inherited}}, 
          ShowCellLabel -> False, ShowSpecialCharacters -> False, 
          AllowInlineCells -> False, Hyphenation -> False, 
          AutoItalicWords -> {}, StyleMenuListing -> None, FontFamily -> 
          "Courier", FontSize -> 12, Background -> GrayLevel[1]], 
         Cell[
          StyleData["InputForm"], InputAutoReplacements -> {}, 
          AllowInlineCells -> False, Hyphenation -> False, StyleMenuListing -> 
          None, FontFamily -> "Courier"], 
         Cell[
          StyleData["OutputForm"], PageWidth -> Infinity, TextAlignment -> 
          Left, LineSpacing -> {0.6, 1}, StyleMenuListing -> None, FontFamily -> 
          "Courier"], 
         Cell[
          StyleData["StandardForm"], 
          InputAutoReplacements -> {
           "->" -> "\[Rule]", ":>" -> "\[RuleDelayed]", "<=" -> 
            "\[LessEqual]", ">=" -> "\[GreaterEqual]", "!=" -> "\[NotEqual]", 
            "==" -> "\[Equal]", Inherited}, LineSpacing -> {1.25, 0}, 
          StyleMenuListing -> None, FontFamily -> "Courier"], 
         Cell[
          StyleData["TraditionalForm"], 
          InputAutoReplacements -> {
           "->" -> "\[Rule]", ":>" -> "\[RuleDelayed]", "<=" -> 
            "\[LessEqual]", ">=" -> "\[GreaterEqual]", "!=" -> "\[NotEqual]", 
            "==" -> "\[Equal]", Inherited}, LineSpacing -> {1.25, 0}, 
          SingleLetterItalics -> True, TraditionalFunctionNotation -> True, 
          DelimiterMatching -> None, StyleMenuListing -> None], 
         Cell[
         "The style defined below is mixed in to any cell that is in an \
inline cell within another.", "Text"], 
         Cell[
          StyleData["InlineCell"], TextAlignment -> Left, ScriptLevel -> 1, 
          StyleMenuListing -> None], 
         Cell[
          StyleData["InlineCellEditing"], StyleMenuListing -> None, 
          Background -> RGBColor[1, 0.749996, 0.8]]}, Closed]], 
      Cell[
       CellGroupData[{
         Cell["Automatic Styles", "Section"], 
         Cell[
         "The cells below define styles that are used to affect the display \
of certain types of objects in typeset expressions.  For example, \
\"UnmatchedBracket\" style defines how unmatched bracket, curly bracket, and \
parenthesis characters are displayed (typically by coloring them to make them \
stand out).", "Text"], 
         Cell[
          StyleData["UnmatchedBracket"], StyleMenuListing -> None, FontColor -> 
          RGBColor[0.760006, 0.330007, 0.8]]}, Closed]]}, Open]]}, Visible -> 
  False, FrontEndVersion -> 
  "10.0 for Mac OS X x86 (32-bit, 64-bit Kernel) (December 4, 2014)", 
  StyleDefinitions -> "Default.nb"]
]
(* End of Notebook Content *)

(* Internal cache information *)
(*CellTagsOutline
CellTagsIndex->{}
*)
(*CellTagsIndex
CellTagsIndex->{}
*)
(*NotebookFileOutline
Notebook[{
Cell[558, 20, 123, 3, 94, "Input"],
Cell[684, 25, 72, 4, 39, "Author"],
Cell[759, 31, 939, 16, 167, "Abstract"],
Cell[1701, 49, 279, 8, 58, "Input",
 InitializationCell->True],
Cell[CellGroupData[{
Cell[2005, 61, 60, 0, 57, "Section"],
Cell[CellGroupData[{
Cell[2090, 65, 50, 0, 42, "Subsubsection"],
Cell[2143, 67, 729, 20, 70, "Text"],
Cell[2875, 89, 403, 11, 70, "Text"],
Cell[3281, 102, 400, 12, 70, "Input"],
Cell[CellGroupData[{
Cell[3706, 118, 193, 6, 70, "Input"],
Cell[3902, 126, 694, 21, 70, "Output"]
}, Open  ]],
Cell[4611, 150, 343, 11, 70, "Text"],
Cell[CellGroupData[{
Cell[4979, 165, 219, 6, 70, "Input"],
Cell[5201, 173, 445, 15, 70, "Output"]
}, Open  ]],
Cell[5661, 191, 290, 6, 70, "Text"],
Cell[5954, 199, 673, 15, 70, "Text"],
Cell[6630, 216, 1520, 53, 70, "Text"],
Cell[8153, 271, 381, 7, 70, "Text"],
Cell[CellGroupData[{
Cell[8559, 282, 445, 17, 70, "Input"],
Cell[9007, 301, 171, 6, 70, "Output"]
}, Open  ]],
Cell[9193, 310, 539, 12, 70, "Text"],
Cell[CellGroupData[{
Cell[9757, 326, 554, 21, 70, "Input"],
Cell[10314, 349, 1960, 74, 70, "Output"]
}, Open  ]],
Cell[12289, 426, 604, 14, 70, "Text"],
Cell[12896, 442, 1089, 26, 70, "Text"],
Cell[13988, 470, 46, 5, 70, "Text"],
Cell[14037, 477, 473, 10, 70, "Text"]
}, Closed]],
Cell[CellGroupData[{
Cell[14547, 492, 120, 3, 28, "Subsubsection"],
Cell[14670, 497, 185, 4, 70, "Text"],
Cell[14858, 503, 241, 6, 70, "Input"],
Cell[15102, 511, 852, 16, 70, "Text"]
}, Closed]],
Cell[CellGroupData[{
Cell[15991, 532, 51, 0, 28, "Subsubsection"],
Cell[16045, 534, 122, 5, 70, "Text"],
Cell[16170, 541, 222, 6, 70, "Text"],
Cell[CellGroupData[{
Cell[16417, 551, 185, 5, 70, "Input"],
Cell[16605, 558, 31, 0, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[16673, 563, 217, 5, 70, "Input"],
Cell[16893, 570, 28, 0, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[16958, 575, 238, 6, 70, "Input"],
Cell[17199, 583, 53, 0, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[17289, 588, 340, 9, 70, "Input"],
Cell[17632, 599, 76, 2, 70, "Output"]
}, Open  ]],
Cell[17723, 604, 401, 11, 70, "Text"],
Cell[18127, 617, 111, 1, 70, "Text"],
Cell[18241, 620, 218, 6, 70, "Input"],
Cell[CellGroupData[{
Cell[18484, 630, 208, 6, 70, "Input"],
Cell[18695, 638, 128, 3, 70, "Output"]
}, Open  ]],
Cell[18838, 644, 237, 9, 70, "Text"],
Cell[CellGroupData[{
Cell[19100, 657, 164, 4, 70, "Input"],
Cell[19267, 663, 217, 5, 70, "Message"],
Cell[19487, 670, 217, 5, 70, "Message"],
Cell[19707, 677, 217, 5, 70, "Message"],
Cell[19927, 684, 216, 5, 70, "Message"],
Cell[20146, 691, 191, 5, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[20374, 701, 214, 6, 70, "Input"],
Cell[20591, 709, 116, 1, 70, "Print"],
Cell[20710, 712, 878, 26, 70, "Print"],
Cell[21591, 740, 138, 1, 70, "Print"],
Cell[21732, 743, 681, 19, 70, "Print"]
}, Open  ]],
Cell[22428, 765, 926, 27, 70, "Text"],
Cell[CellGroupData[{
Cell[23379, 796, 408, 10, 70, "Input"],
Cell[23790, 808, 80, 2, 70, "Output"]
}, Open  ]],
Cell[23885, 813, 399, 8, 70, "Text"],
Cell[24287, 823, 306, 7, 70, "Input"],
Cell[CellGroupData[{
Cell[24618, 834, 57, 1, 70, "Input"],
Cell[24678, 837, 116, 1, 70, "Print"],
Cell[24797, 840, 878, 26, 70, "Print"]
}, Open  ]],
Cell[CellGroupData[{
Cell[25712, 871, 154, 3, 70, "Input"],
Cell[25869, 876, 754, 22, 70, "Output"]
}, Open  ]],
Cell[26638, 901, 93, 2, 70, "Text"],
Cell[CellGroupData[{
Cell[26756, 907, 281, 7, 70, "Input"],
Cell[27040, 916, 1857, 56, 70, "Output"]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[28946, 978, 172, 5, 45, "Subsubsection"],
Cell[29121, 985, 1128, 28, 70, "Text"],
Cell[30252, 1015, 148, 5, 70, "Text"],
Cell[CellGroupData[{
Cell[30425, 1024, 243, 7, 70, "Input"],
Cell[30671, 1033, 31, 0, 70, "Output"]
}, Open  ]],
Cell[30717, 1036, 199, 8, 70, "Text"],
Cell[CellGroupData[{
Cell[30941, 1048, 236, 7, 70, "Input"],
Cell[31180, 1057, 31, 0, 70, "Output"]
}, Open  ]],
Cell[31226, 1060, 515, 13, 70, "Text"],
Cell[CellGroupData[{
Cell[31766, 1077, 164, 4, 70, "Input"],
Cell[31933, 1083, 144, 4, 70, "Output"]
}, Open  ]],
Cell[32092, 1090, 229, 6, 70, "Text"],
Cell[CellGroupData[{
Cell[32346, 1100, 141, 4, 70, "Input"],
Cell[32490, 1106, 138, 4, 70, "Output"]
}, Open  ]],
Cell[32643, 1113, 62, 0, 70, "Text"],
Cell[CellGroupData[{
Cell[32730, 1117, 156, 4, 70, "Input"],
Cell[32889, 1123, 142, 4, 70, "Output"]
}, Open  ]],
Cell[33046, 1130, 153, 5, 70, "Text"],
Cell[33202, 1137, 630, 18, 70, "Text"],
Cell[33835, 1157, 360, 14, 70, "Text"],
Cell[CellGroupData[{
Cell[34220, 1175, 135, 3, 70, "Input"],
Cell[34358, 1180, 87, 2, 70, "Print"]
}, Open  ]],
Cell[34460, 1185, 174, 3, 70, "Text"],
Cell[CellGroupData[{
Cell[34659, 1192, 378, 13, 70, "Input"],
Cell[35040, 1207, 38, 0, 70, "Output"]
}, Open  ]],
Cell[35093, 1210, 477, 15, 70, "Text"],
Cell[35573, 1227, 339, 7, 70, "Text"]
}, Closed]]
}, Open  ]],
Cell[CellGroupData[{
Cell[35961, 1240, 46, 0, 57, "Section"],
Cell[CellGroupData[{
Cell[36032, 1244, 35, 0, 47, "Subsection"],
Cell[CellGroupData[{
Cell[36092, 1248, 97, 2, 42, "Subsubsection"],
Cell[36192, 1252, 1368, 37, 70, "Text"],
Cell[37563, 1291, 254, 9, 70, "Text"],
Cell[37820, 1302, 263, 7, 70, "Input"],
Cell[CellGroupData[{
Cell[38108, 1313, 306, 8, 70, "Input"],
Cell[38417, 1323, 92, 2, 70, "Output"]
}, Open  ]],
Cell[38524, 1328, 296, 7, 70, "Text"],
Cell[38823, 1337, 61, 0, 70, "Text"],
Cell[38887, 1339, 540, 13, 70, "Input"],
Cell[39430, 1354, 854, 24, 70, "Text"],
Cell[CellGroupData[{
Cell[40309, 1382, 1030, 25, 70, "Input"],
Cell[41342, 1409, 567, 18, 70, "Output"]
}, Open  ]],
Cell[41924, 1430, 131, 3, 70, "Text"],
Cell[CellGroupData[{
Cell[42080, 1437, 619, 15, 70, "Input"],
Cell[42702, 1454, 93, 2, 70, "Output"]
}, Open  ]],
Cell[42810, 1459, 190, 6, 70, "Text"],
Cell[CellGroupData[{
Cell[43025, 1469, 623, 15, 70, "Input"],
Cell[43651, 1486, 131, 4, 70, "Output"]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[43831, 1496, 201, 4, 45, "Subsubsection"],
Cell[CellGroupData[{
Cell[44057, 1504, 606, 16, 70, "Input"],
Cell[44666, 1522, 302, 9, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[45005, 1536, 666, 17, 70, "Input"],
Cell[45674, 1555, 93, 2, 70, "Output"]
}, Open  ]],
Cell[45782, 1560, 439, 10, 70, "Text"],
Cell[46224, 1572, 99, 2, 70, "Input"],
Cell[CellGroupData[{
Cell[46348, 1578, 106, 2, 70, "Input"],
Cell[46457, 1582, 350, 12, 70, "Output"]
}, Open  ]],
Cell[46822, 1597, 304, 11, 70, "Text"],
Cell[CellGroupData[{
Cell[47151, 1612, 146, 3, 70, "Input"],
Cell[47300, 1617, 392, 13, 70, "Output"]
}, Open  ]],
Cell[47707, 1633, 196, 7, 70, "Text"],
Cell[CellGroupData[{
Cell[47928, 1644, 319, 7, 70, "Input"],
Cell[48250, 1653, 267, 8, 70, "Output"]
}, Open  ]],
Cell[48532, 1664, 150, 5, 70, "Text"],
Cell[CellGroupData[{
Cell[48707, 1673, 371, 9, 70, "Input"],
Cell[49081, 1684, 639, 14, 70, "Output"]
}, Open  ]],
Cell[49735, 1701, 220, 5, 70, "Text"],
Cell[CellGroupData[{
Cell[49980, 1710, 64, 1, 70, "Input"],
Cell[50047, 1713, 233, 8, 70, "Output"]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[50329, 1727, 109, 2, 28, "Subsubsection"],
Cell[50441, 1731, 288, 9, 70, "Text"],
Cell[CellGroupData[{
Cell[50754, 1744, 525, 14, 70, "Input"],
Cell[51282, 1760, 126, 5, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[51445, 1770, 448, 13, 70, "Input"],
Cell[51896, 1785, 126, 5, 70, "Output"]
}, Open  ]],
Cell[52037, 1793, 1567, 49, 70, "Text"],
Cell[CellGroupData[{
Cell[53629, 1846, 719, 21, 70, "Input"],
Cell[54351, 1869, 125, 5, 70, "Output"]
}, Open  ]],
Cell[54491, 1877, 280, 9, 70, "Text"],
Cell[54774, 1888, 25, 3, 70, "Text"],
Cell[54802, 1893, 227, 6, 70, "Text"],
Cell[CellGroupData[{
Cell[55054, 1903, 635, 19, 70, "Input"],
Cell[55692, 1924, 73, 2, 70, "Output"]
}, Open  ]],
Cell[55780, 1929, 390, 6, 70, "Text"],
Cell[56173, 1937, 25, 3, 70, "Text"],
Cell[56201, 1942, 2573, 85, 70, "Text"],
Cell[CellGroupData[{
Cell[58799, 2031, 679, 21, 70, "Input"],
Cell[59481, 2054, 54, 1, 70, "Print"]
}, Open  ]],
Cell[CellGroupData[{
Cell[59572, 2060, 170, 5, 70, "Input"],
Cell[59745, 2067, 28, 0, 70, "Output"],
Cell[59776, 2069, 54, 1, 70, "Print"]
}, Open  ]],
Cell[CellGroupData[{
Cell[59867, 2075, 145, 4, 70, "Input"],
Cell[60015, 2081, 28, 0, 70, "Output"],
Cell[60046, 2083, 54, 1, 70, "Print"]
}, Open  ]],
Cell[60115, 2087, 100, 2, 70, "Input"],
Cell[CellGroupData[{
Cell[60240, 2093, 378, 11, 70, "Input"],
Cell[60621, 2106, 28, 0, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[60686, 2111, 49, 1, 70, "Input"],
Cell[60738, 2114, 42, 0, 70, "Print"]
}, Open  ]],
Cell[CellGroupData[{
Cell[60817, 2119, 286, 8, 70, "Input"],
Cell[61106, 2129, 182, 8, 70, "Output"]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[61337, 2143, 106, 2, 28, "Subsubsection"],
Cell[61446, 2147, 1893, 36, 70, "Text"],
Cell[63342, 2185, 218, 6, 70, "Input"],
Cell[63563, 2193, 103, 3, 70, "Text"],
Cell[CellGroupData[{
Cell[63691, 2200, 517, 16, 70, "Input"],
Cell[64211, 2218, 331, 11, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[64579, 2234, 302, 8, 70, "Input"],
Cell[64884, 2244, 91, 2, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[65012, 2251, 293, 7, 70, "Input"],
Cell[65308, 2260, 115, 3, 70, "Output"]
}, Open  ]],
Cell[65438, 2266, 382, 6, 70, "Text"],
Cell[CellGroupData[{
Cell[65845, 2276, 640, 16, 70, "Input"],
Cell[66488, 2294, 614, 19, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[67139, 2318, 64, 1, 70, "Input"],
Cell[67206, 2321, 28, 0, 70, "Output"]
}, Open  ]],
Cell[67249, 2324, 127, 3, 70, "Text"],
Cell[CellGroupData[{
Cell[67401, 2331, 444, 12, 70, "Input"],
Cell[67848, 2345, 202, 5, 70, "Message"],
Cell[68053, 2352, 414, 13, 70, "Output"]
}, Open  ]],
Cell[68482, 2368, 60, 0, 70, "Text"],
Cell[68545, 2370, 2031, 55, 70, "Input"],
Cell[70579, 2427, 110, 3, 70, "Text"],
Cell[CellGroupData[{
Cell[70714, 2434, 296, 8, 70, "Input"],
Cell[71013, 2444, 92, 2, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[71142, 2451, 1006, 39, 70, "Input"],
Cell[72151, 2492, 28, 0, 70, "Output"]
}, Open  ]],
Cell[72194, 2495, 131, 3, 70, "Input"]
}, Closed]],
Cell[CellGroupData[{
Cell[72362, 2503, 59, 0, 28, "Subsubsection"],
Cell[72424, 2505, 245, 4, 70, "Text"],
Cell[72672, 2511, 234, 8, 70, "Text"],
Cell[CellGroupData[{
Cell[72931, 2523, 176, 6, 70, "Input"],
Cell[73110, 2531, 82, 2, 70, "Output"]
}, Open  ]],
Cell[73207, 2536, 33, 0, 70, "Text"],
Cell[CellGroupData[{
Cell[73265, 2540, 314, 9, 70, "Input"],
Cell[73582, 2551, 248, 7, 70, "Output"]
}, Open  ]],
Cell[73845, 2561, 162, 5, 70, "Text"],
Cell[CellGroupData[{
Cell[74032, 2570, 307, 8, 70, "Input"],
Cell[74342, 2580, 240, 8, 70, "Output"]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[74631, 2594, 125, 3, 28, "Subsubsection"],
Cell[74759, 2599, 417, 7, 70, "Text"],
Cell[CellGroupData[{
Cell[75201, 2610, 424, 11, 70, "Input"],
Cell[75628, 2623, 554, 28, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[76219, 2656, 135, 3, 70, "Input"],
Cell[76357, 2661, 478, 24, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[76872, 2690, 178, 4, 70, "Input"],
Cell[77053, 2696, 477, 24, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[77567, 2725, 64, 1, 70, "Input"],
Cell[77634, 2728, 29, 0, 70, "Output"]
}, Open  ]],
Cell[77678, 2731, 354, 6, 70, "Text"],
Cell[78035, 2739, 1145, 31, 70, "Input"],
Cell[CellGroupData[{
Cell[79205, 2774, 429, 11, 70, "Input"],
Cell[79637, 2787, 768, 38, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[80442, 2830, 140, 3, 70, "Input"],
Cell[80585, 2835, 671, 33, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[81293, 2873, 188, 4, 70, "Input"],
Cell[81484, 2879, 670, 33, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[82191, 2917, 215, 5, 70, "Input"],
Cell[82409, 2924, 29, 0, 70, "Output"]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[82487, 2930, 76, 0, 28, "Subsubsection"],
Cell[82566, 2932, 352, 6, 70, "Text"],
Cell[CellGroupData[{
Cell[82943, 2942, 431, 11, 70, "Input"],
Cell[83377, 2955, 274, 8, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[83688, 2968, 101, 2, 70, "Input"],
Cell[83792, 2972, 224, 6, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[84053, 2983, 110, 2, 70, "Input"],
Cell[84166, 2987, 223, 6, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[84426, 2998, 212, 5, 70, "Input"],
Cell[84641, 3005, 29, 0, 70, "Output"]
}, Open  ]],
Cell[84685, 3008, 304, 5, 70, "Text"],
Cell[84992, 3015, 447, 13, 70, "Text"],
Cell[CellGroupData[{
Cell[85464, 3032, 1155, 28, 70, "Input"],
Cell[86622, 3062, 29, 0, 70, "Output"]
}, Open  ]],
Cell[86666, 3065, 25, 3, 70, "Text"],
Cell[86694, 3070, 1164, 30, 70, "Text"],
Cell[87861, 3102, 2055, 53, 70, "Input"],
Cell[CellGroupData[{
Cell[89941, 3159, 899, 23, 70, "Input"],
Cell[90843, 3184, 29, 0, 70, "Output"]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[90921, 3190, 100, 2, 28, "Subsubsection"],
Cell[91024, 3194, 533, 12, 70, "Text"],
Cell[91560, 3208, 45, 0, 70, "Text"],
Cell[91608, 3210, 86, 2, 70, "Input"],
Cell[CellGroupData[{
Cell[91719, 3216, 178, 6, 70, "Input"],
Cell[91900, 3224, 144, 5, 70, "Output"]
}, Open  ]],
Cell[92059, 3232, 173, 3, 70, "Text"],
Cell[92235, 3237, 286, 9, 70, "Input"],
Cell[CellGroupData[{
Cell[92546, 3250, 310, 9, 70, "Input"],
Cell[92859, 3261, 319, 11, 70, "Output"]
}, Open  ]],
Cell[93193, 3275, 172, 5, 70, "Text"],
Cell[CellGroupData[{
Cell[93390, 3284, 585, 15, 70, "Input"],
Cell[93978, 3301, 319, 11, 70, "Output"]
}, Open  ]],
Cell[94312, 3315, 213, 6, 70, "Text"],
Cell[CellGroupData[{
Cell[94550, 3325, 703, 18, 70, "Input"],
Cell[95256, 3345, 490, 14, 70, "Print"],
Cell[95749, 3361, 319, 11, 70, "Output"]
}, Open  ]]
}, Closed]]
}, Open  ]],
Cell[CellGroupData[{
Cell[96129, 3379, 55, 0, 47, "Subsection"],
Cell[CellGroupData[{
Cell[96209, 3383, 158, 3, 70, "Subsubsection"],
Cell[96370, 3388, 713, 20, 70, "Text"],
Cell[CellGroupData[{
Cell[97108, 3412, 278, 8, 70, "Input"],
Cell[97389, 3422, 335, 15, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[97761, 3442, 330, 9, 70, "Input"],
Cell[98094, 3453, 591, 23, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[98722, 3481, 573, 14, 70, "Input"],
Cell[99298, 3497, 319, 14, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[99654, 3516, 103, 2, 70, "Input"],
Cell[99760, 3520, 32, 0, 70, "Output"]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[99841, 3526, 120, 3, 70, "Subsubsection"],
Cell[99964, 3531, 505, 12, 70, "Text"],
Cell[100472, 3545, 368, 10, 70, "Input"],
Cell[100843, 3557, 102, 2, 70, "Text"],
Cell[CellGroupData[{
Cell[100970, 3563, 96, 2, 70, "Input"],
Cell[101069, 3567, 324, 13, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[101430, 3585, 86, 2, 70, "Input"],
Cell[101519, 3589, 325, 13, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[101881, 3607, 120, 3, 70, "Input"],
Cell[102004, 3612, 405, 15, 70, "Output"]
}, Open  ]],
Cell[102424, 3630, 240, 9, 70, "Text"]
}, Closed]],
Cell[CellGroupData[{
Cell[102701, 3644, 82, 1, 70, "Subsubsection"],
Cell[102786, 3647, 418, 10, 70, "Text"],
Cell[CellGroupData[{
Cell[103229, 3661, 315, 9, 70, "Input"],
Cell[103547, 3672, 159, 6, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[103743, 3683, 382, 12, 70, "Input"],
Cell[104128, 3697, 219, 8, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[104384, 3710, 356, 11, 70, "Input"],
Cell[104743, 3723, 182, 7, 70, "Output"]
}, Open  ]],
Cell[104940, 3733, 220, 6, 70, "Text"],
Cell[CellGroupData[{
Cell[105185, 3743, 380, 12, 70, "Input"],
Cell[105568, 3757, 213, 8, 70, "Output"]
}, Open  ]],
Cell[105796, 3768, 95, 2, 70, "Text"],
Cell[CellGroupData[{
Cell[105916, 3774, 380, 12, 70, "Input"],
Cell[106299, 3788, 209, 8, 70, "Output"]
}, Open  ]]
}, Closed]]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[106581, 3804, 49, 0, 70, "Section"],
Cell[CellGroupData[{
Cell[106655, 3808, 114, 3, 70, "Subsection"],
Cell[CellGroupData[{
Cell[106794, 3815, 32, 0, 70, "Subsubsection"],
Cell[106829, 3817, 98, 5, 70, "Text"],
Cell[106930, 3824, 851, 23, 70, "Input"],
Cell[CellGroupData[{
Cell[107806, 3851, 568, 16, 70, "Input"],
Cell[108377, 3869, 401, 13, 70, "Output"]
}, Open  ]],
Cell[108793, 3885, 140, 3, 70, "Text"],
Cell[108936, 3890, 948, 28, 70, "Input"],
Cell[CellGroupData[{
Cell[109909, 3922, 352, 10, 70, "Input"],
Cell[110264, 3934, 147, 4, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[110448, 3943, 54, 1, 70, "Input"],
Cell[110505, 3946, 28, 0, 70, "Output"]
}, Open  ]],
Cell[110548, 3949, 262, 8, 70, "Text"],
Cell[110813, 3959, 547, 16, 70, "Input"],
Cell[CellGroupData[{
Cell[111385, 3979, 352, 10, 70, "Input"],
Cell[111740, 3991, 173, 5, 70, "Message"],
Cell[111916, 3998, 179, 5, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[112132, 4008, 54, 1, 70, "Input"],
Cell[112189, 4011, 173, 5, 70, "Message"],
Cell[112365, 4018, 86, 2, 70, "Output"]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[112500, 4026, 31, 0, 70, "Subsubsection"],
Cell[112534, 4028, 206, 4, 70, "Text"],
Cell[112743, 4034, 216, 6, 70, "Input"],
Cell[112962, 4042, 291, 8, 70, "Input"],
Cell[113256, 4052, 320, 11, 70, "Text"],
Cell[113579, 4065, 224, 6, 70, "Input"],
Cell[113806, 4073, 268, 7, 70, "Text"],
Cell[114077, 4082, 377, 11, 70, "Input"],
Cell[114457, 4095, 452, 13, 70, "Input"],
Cell[114912, 4110, 125, 5, 70, "Text"],
Cell[115040, 4117, 304, 9, 70, "Input"],
Cell[115347, 4128, 74, 0, 70, "Text"],
Cell[115424, 4130, 387, 12, 70, "Program"],
Cell[115814, 4144, 241, 8, 70, "Text"],
Cell[116058, 4154, 368, 8, 70, "Input"],
Cell[116429, 4164, 368, 11, 70, "Text"],
Cell[116800, 4177, 550, 16, 70, "Input"],
Cell[117353, 4195, 307, 11, 70, "Text"],
Cell[117663, 4208, 430, 12, 70, "Input"],
Cell[118096, 4222, 479, 13, 70, "Input"],
Cell[118578, 4237, 196, 8, 70, "Text"]
}, Closed]],
Cell[CellGroupData[{
Cell[118811, 4250, 86, 1, 70, "Subsubsection"],
Cell[118900, 4253, 427, 12, 70, "Text"],
Cell[119330, 4267, 392, 10, 70, "Text"],
Cell[119725, 4279, 410, 12, 70, "Input"],
Cell[120138, 4293, 212, 5, 70, "Text"]
}, Closed]],
Cell[CellGroupData[{
Cell[120387, 4303, 114, 3, 70, "Subsubsection"],
Cell[120504, 4308, 130, 5, 70, "Text"],
Cell[120637, 4315, 349, 12, 70, "Text"],
Cell[120989, 4329, 973, 30, 70, "Text"]
}, Closed]]
}, Open  ]],
Cell[CellGroupData[{
Cell[122011, 4365, 53, 0, 70, "Subsection"],
Cell[CellGroupData[{
Cell[122089, 4369, 274, 9, 70, "Subsubsection"],
Cell[122366, 4380, 1226, 41, 70, "Text"],
Cell[123595, 4423, 79, 2, 70, "Input"],
Cell[CellGroupData[{
Cell[123699, 4429, 60, 1, 70, "Input"],
Cell[123762, 4432, 42, 0, 70, "Output"]
}, Open  ]],
Cell[123819, 4435, 129, 3, 70, "Input"],
Cell[CellGroupData[{
Cell[123973, 4442, 60, 1, 70, "Input"],
Cell[124036, 4445, 218, 5, 70, "Message"],
Cell[124257, 4452, 63, 1, 70, "Output"]
}, Open  ]],
Cell[124335, 4456, 127, 3, 70, "Input"],
Cell[124465, 4461, 723, 22, 70, "Text"],
Cell[125191, 4485, 158, 7, 70, "Text"],
Cell[CellGroupData[{
Cell[125374, 4496, 66, 1, 70, "Input"],
Cell[125443, 4499, 87, 2, 70, "Output"]
}, Open  ]],
Cell[125545, 4504, 166, 8, 70, "Text"],
Cell[CellGroupData[{
Cell[125736, 4516, 257, 7, 70, "Input"],
Cell[125996, 4525, 124, 3, 70, "Output"]
}, Open  ]],
Cell[126135, 4531, 124, 4, 70, "Text"],
Cell[CellGroupData[{
Cell[126284, 4539, 265, 7, 70, "Input"],
Cell[126552, 4548, 246, 7, 70, "Output"]
}, Open  ]],
Cell[126813, 4558, 403, 10, 70, "Text"],
Cell[127219, 4570, 255, 7, 70, "Text"]
}, Closed]],
Cell[CellGroupData[{
Cell[127511, 4582, 288, 9, 70, "Subsubsection"],
Cell[127802, 4593, 509, 18, 70, "Text"],
Cell[128314, 4613, 266, 6, 70, "Input"],
Cell[128583, 4621, 399, 10, 70, "Text"],
Cell[128985, 4633, 486, 16, 70, "Text"],
Cell[129474, 4651, 3137, 136, 70, "Text"],
Cell[132614, 4789, 70, 1, 70, "Text"],
Cell[132687, 4792, 343, 7, 70, "Text"],
Cell[133033, 4801, 212, 10, 70, "Text"],
Cell[CellGroupData[{
Cell[133270, 4815, 517, 14, 70, "Input"],
Cell[133790, 4831, 28, 0, 70, "Output"]
}, Open  ]],
Cell[133833, 4834, 200, 8, 70, "Text"],
Cell[CellGroupData[{
Cell[134058, 4846, 524, 15, 70, "Input"],
Cell[134585, 4863, 27, 0, 70, "Print"],
Cell[134615, 4865, 28, 0, 70, "Output"]
}, Open  ]],
Cell[134658, 4868, 263, 6, 70, "Text"],
Cell[134924, 4876, 166, 3, 70, "Text"],
Cell[CellGroupData[{
Cell[135115, 4883, 374, 10, 70, "Input"],
Cell[135492, 4895, 82, 2, 70, "Output"]
}, Open  ]],
Cell[135589, 4900, 263, 9, 70, "Text"],
Cell[CellGroupData[{
Cell[135877, 4913, 274, 8, 70, "Input"],
Cell[136154, 4923, 28, 0, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[136219, 4928, 293, 8, 70, "Input"],
Cell[136515, 4938, 28, 0, 70, "Output"]
}, Open  ]],
Cell[136558, 4941, 112, 5, 70, "Text"],
Cell[CellGroupData[{
Cell[136695, 4950, 551, 16, 70, "Input"],
Cell[137249, 4968, 294, 10, 70, "Print"]
}, Open  ]],
Cell[137558, 4981, 649, 19, 70, "Text"],
Cell[138210, 5002, 45, 0, 70, "Text"],
Cell[CellGroupData[{
Cell[138280, 5006, 338, 10, 70, "Input"],
Cell[138621, 5018, 167, 6, 70, "Output"]
}, Open  ]],
Cell[138803, 5027, 143, 5, 70, "Text"],
Cell[CellGroupData[{
Cell[138971, 5036, 539, 15, 70, "Input"],
Cell[139513, 5053, 140, 4, 70, "Print"]
}, Open  ]],
Cell[139668, 5060, 310, 9, 70, "Text"],
Cell[139981, 5071, 126, 4, 70, "Text"],
Cell[140110, 5077, 349, 10, 70, "Text"],
Cell[CellGroupData[{
Cell[140484, 5091, 241, 7, 70, "Input"],
Cell[140728, 5100, 94, 3, 70, "Print"]
}, Open  ]],
Cell[140837, 5106, 43, 0, 70, "Text"],
Cell[CellGroupData[{
Cell[140905, 5110, 286, 8, 70, "Input"],
Cell[141194, 5120, 239, 9, 70, "Print"]
}, Open  ]],
Cell[141448, 5132, 397, 13, 70, "Text"],
Cell[141848, 5147, 170, 5, 70, "Text"],
Cell[CellGroupData[{
Cell[142043, 5156, 144, 4, 70, "Input"],
Cell[142190, 5162, 205, 6, 70, "Message"],
Cell[142398, 5170, 85, 2, 70, "Output"]
}, Open  ]],
Cell[142498, 5175, 100, 4, 70, "Text"],
Cell[CellGroupData[{
Cell[142623, 5183, 140, 4, 70, "Input"],
Cell[142766, 5189, 85, 2, 70, "Output"]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[142900, 5197, 75, 0, 70, "Subsubsection"],
Cell[142978, 5199, 1658, 45, 70, "Text"]
}, Closed]],
Cell[CellGroupData[{
Cell[144673, 5249, 79, 0, 70, "Subsubsection"],
Cell[144755, 5251, 792, 23, 70, "Text"],
Cell[145550, 5276, 115, 5, 70, "Text"],
Cell[145668, 5283, 142, 5, 70, "Text"],
Cell[145813, 5290, 420, 12, 70, "Text"],
Cell[146236, 5304, 1116, 26, 70, "Text"],
Cell[147355, 5332, 109, 3, 70, "Text"],
Cell[147467, 5337, 606, 20, 70, "Text"],
Cell[148076, 5359, 618, 23, 70, "Text"],
Cell[148697, 5384, 131, 5, 70, "Text"],
Cell[CellGroupData[{
Cell[148853, 5393, 337, 9, 70, "Input"],
Cell[149193, 5404, 207, 4, 70, "Output"]
}, Open  ]],
Cell[149415, 5411, 686, 24, 70, "Text"],
Cell[150104, 5437, 233, 6, 70, "Text"],
Cell[150340, 5445, 120, 5, 70, "Text"],
Cell[CellGroupData[{
Cell[150485, 5454, 334, 9, 70, "Input"],
Cell[150822, 5465, 288, 5, 70, "Output"]
}, Open  ]],
Cell[151125, 5473, 928, 30, 70, "Text"]
}, Closed]],
Cell[CellGroupData[{
Cell[152090, 5508, 259, 4, 70, "Subsubsection"],
Cell[152352, 5514, 876, 26, 70, "Text"],
Cell[153231, 5542, 331, 9, 70, "Text"]
}, Closed]],
Cell[CellGroupData[{
Cell[153599, 5556, 143, 3, 70, "Subsubsection"],
Cell[153745, 5561, 442, 13, 70, "Text"],
Cell[CellGroupData[{
Cell[154212, 5578, 271, 8, 70, "Input"],
Cell[154486, 5588, 80, 1, 70, "Output"]
}, Open  ]],
Cell[154581, 5592, 254, 8, 70, "Text"],
Cell[154838, 5602, 268, 7, 70, "Text"],
Cell[155109, 5611, 142, 4, 70, "Input"],
Cell[155254, 5617, 119, 3, 70, "Input"],
Cell[155376, 5622, 102, 2, 70, "Input"]
}, Closed]],
Cell[CellGroupData[{
Cell[155515, 5629, 138, 3, 70, "Subsubsection"],
Cell[155656, 5634, 337, 9, 70, "Input"],
Cell[155996, 5645, 128, 3, 70, "Input"],
Cell[CellGroupData[{
Cell[156149, 5652, 54, 1, 70, "Input"],
Cell[156206, 5655, 41, 0, 70, "Print"]
}, Open  ]],
Cell[CellGroupData[{
Cell[156284, 5660, 92, 2, 70, "Input"],
Cell[156379, 5664, 41, 0, 70, "Print"]
}, Open  ]],
Cell[156435, 5667, 252, 9, 70, "Text"],
Cell[156690, 5678, 100, 2, 70, "Text"],
Cell[CellGroupData[{
Cell[156815, 5684, 50, 1, 70, "Input"],
Cell[156868, 5687, 41, 0, 70, "Print"]
}, Open  ]],
Cell[CellGroupData[{
Cell[156946, 5692, 77, 2, 70, "Input"],
Cell[157026, 5696, 41, 0, 70, "Print"]
}, Open  ]],
Cell[CellGroupData[{
Cell[157104, 5701, 49, 1, 70, "Input"],
Cell[157156, 5704, 41, 0, 70, "Print"],
Cell[157200, 5706, 42, 0, 70, "Print"],
Cell[157245, 5708, 843, 24, 70, "Print"]
}, Open  ]],
Cell[CellGroupData[{
Cell[158125, 5737, 359, 8, 70, "Input"],
Cell[158487, 5747, 41, 0, 70, "Print"]
}, Open  ]],
Cell[CellGroupData[{
Cell[158565, 5752, 50, 1, 70, "Input"],
Cell[158618, 5755, 41, 0, 70, "Print"],
Cell[158662, 5757, 42, 0, 70, "Print"],
Cell[158707, 5759, 843, 24, 70, "Print"]
}, Open  ]],
Cell[CellGroupData[{
Cell[159587, 5788, 141, 3, 70, "Input"],
Cell[159731, 5793, 28, 0, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[159796, 5798, 49, 1, 70, "Input"],
Cell[159848, 5801, 41, 0, 70, "Print"],
Cell[159892, 5803, 42, 0, 70, "Print"],
Cell[159937, 5805, 1333, 38, 70, "Print"]
}, Open  ]],
Cell[CellGroupData[{
Cell[161307, 5848, 144, 3, 70, "Input"],
Cell[161454, 5853, 843, 24, 70, "Print"]
}, Open  ]],
Cell[CellGroupData[{
Cell[162334, 5882, 148, 3, 70, "Input"],
Cell[162485, 5887, 1099, 30, 70, "Print"]
}, Open  ]],
Cell[163599, 5920, 48, 0, 70, "Text"]
}, Closed]],
Cell[CellGroupData[{
Cell[163684, 5925, 98, 2, 70, "Subsubsection"],
Cell[163785, 5929, 90, 2, 70, "Text"],
Cell[163878, 5933, 75, 0, 70, "Text"],
Cell[163956, 5935, 1273, 47, 70, "Text"],
Cell[165232, 5984, 149, 4, 70, "Input"],
Cell[165384, 5990, 102, 2, 70, "Text"],
Cell[165489, 5994, 233, 6, 70, "Input"],
Cell[165725, 6002, 1066, 46, 70, "Text"],
Cell[166794, 6050, 793, 28, 70, "Text"],
Cell[CellGroupData[{
Cell[167612, 6082, 408, 8, 70, "Input"],
Cell[168023, 6092, 41, 0, 70, "Print"]
}, Open  ]],
Cell[168079, 6095, 1039, 26, 70, "Text"],
Cell[169121, 6123, 532, 16, 70, "Text"],
Cell[169656, 6141, 27, 5, 70, "Text"],
Cell[169686, 6148, 368, 7, 70, "Text"],
Cell[170057, 6157, 300, 7, 70, "Input"],
Cell[170360, 6166, 630, 15, 70, "Text"],
Cell[170993, 6183, 1058, 23, 70, "Text"],
Cell[172054, 6208, 106, 2, 70, "Text"],
Cell[172163, 6212, 1526, 42, 70, "Input"],
Cell[CellGroupData[{
Cell[173714, 6258, 35, 0, 70, "Input"],
Cell[173752, 6260, 213, 5, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[174002, 6270, 550, 13, 70, "Input"],
Cell[174555, 6285, 2349, 34, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[176941, 6324, 471, 12, 70, "Input"],
Cell[177415, 6338, 387, 7, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[177839, 6350, 430, 12, 70, "Input"],
Cell[178272, 6364, 524, 9, 70, "Output"]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[178845, 6379, 224, 5, 70, "Subsubsection"],
Cell[179072, 6386, 119, 3, 70, "Text"],
Cell[179194, 6391, 543, 15, 70, "Input"],
Cell[179740, 6408, 823, 23, 70, "Text"],
Cell[180566, 6433, 189, 4, 70, "Text"],
Cell[180758, 6439, 503, 13, 70, "Input"],
Cell[181264, 6454, 56, 0, 70, "Text"],
Cell[CellGroupData[{
Cell[181345, 6458, 164, 5, 70, "Input"],
Cell[181512, 6465, 103, 2, 70, "Output"]
}, Open  ]],
Cell[181630, 6470, 46, 0, 70, "Text"],
Cell[CellGroupData[{
Cell[181701, 6474, 247, 6, 70, "Input"],
Cell[181951, 6482, 27, 0, 70, "Print"],
Cell[181981, 6484, 120, 3, 70, "Output"]
}, Open  ]],
Cell[182116, 6490, 117, 3, 70, "Text"],
Cell[182236, 6495, 499, 13, 70, "Input"],
Cell[CellGroupData[{
Cell[182760, 6512, 247, 6, 70, "Input"],
Cell[183010, 6520, 177, 4, 70, "Output"]
}, Open  ]],
Cell[183202, 6527, 95, 2, 70, "Text"],
Cell[CellGroupData[{
Cell[183322, 6533, 190, 5, 70, "Input"],
Cell[183515, 6540, 29, 0, 70, "Output"]
}, Open  ]],
Cell[183559, 6543, 339, 14, 70, "Text"],
Cell[183901, 6559, 219, 9, 70, "Text"],
Cell[184123, 6570, 692, 17, 70, "Input"],
Cell[CellGroupData[{
Cell[184840, 6591, 190, 5, 70, "Input"],
Cell[185033, 6598, 75, 2, 70, "Output"]
}, Open  ]],
Cell[185123, 6603, 342, 11, 70, "Text"],
Cell[185468, 6616, 279, 5, 70, "Text"],
Cell[185750, 6623, 278, 7, 70, "Text"],
Cell[186031, 6632, 522, 10, 70, "Text"]
}, Closed]]
}, Open  ]],
Cell[CellGroupData[{
Cell[186602, 6648, 74, 0, 70, "Subsection"],
Cell[CellGroupData[{
Cell[186701, 6652, 114, 5, 70, "Subsubsection"],
Cell[186818, 6659, 54, 0, 70, "Text"],
Cell[186875, 6661, 344, 14, 70, "Text"],
Cell[187222, 6677, 24, 0, 70, "Text"],
Cell[187249, 6679, 35, 0, 70, "Input"],
Cell[187287, 6681, 90, 2, 70, "Input"],
Cell[187380, 6685, 96, 2, 70, "Input"],
Cell[187479, 6689, 101, 2, 70, "Input"],
Cell[187583, 6693, 170, 5, 70, "Input"],
Cell[187756, 6700, 327, 15, 70, "Text"],
Cell[188086, 6717, 25, 0, 70, "Text"],
Cell[188114, 6719, 156, 5, 70, "Input"],
Cell[188273, 6726, 153, 5, 70, "Input"],
Cell[188429, 6733, 1232, 36, 70, "Text"],
Cell[189664, 6771, 349, 9, 70, "Text"],
Cell[190016, 6782, 631, 15, 70, "Input"],
Cell[190650, 6799, 86, 3, 70, "Input"],
Cell[190739, 6804, 1410, 47, 70, "Text"],
Cell[192152, 6853, 216, 5, 70, "Text"],
Cell[192371, 6860, 570, 15, 70, "Input"],
Cell[192944, 6877, 516, 14, 70, "Input"],
Cell[193463, 6893, 662, 18, 70, "Input"],
Cell[194128, 6913, 313, 11, 70, "Text"],
Cell[194444, 6926, 60, 1, 70, "Input"],
Cell[194507, 6929, 181, 6, 70, "Text"],
Cell[194691, 6937, 1001, 26, 70, "Text"],
Cell[195695, 6965, 64, 0, 70, "Text"],
Cell[195762, 6967, 356, 13, 70, "Input"],
Cell[196121, 6982, 445, 24, 70, "Text"],
Cell[196569, 7008, 697, 22, 70, "Text"],
Cell[197269, 7032, 238, 6, 70, "Input"],
Cell[197510, 7040, 162, 4, 70, "Input"],
Cell[197675, 7046, 235, 6, 70, "Input"],
Cell[197913, 7054, 252, 7, 70, "Text"],
Cell[198168, 7063, 620, 17, 70, "Input"],
Cell[198791, 7082, 453, 12, 70, "Input"],
Cell[CellGroupData[{
Cell[199269, 7098, 110, 2, 70, "Input"],
Cell[199382, 7102, 31, 0, 70, "Output"]
}, Open  ]],
Cell[199428, 7105, 89, 2, 70, "Text"],
Cell[CellGroupData[{
Cell[199542, 7111, 333, 9, 70, "Input"],
Cell[199878, 7122, 2585, 54, 70, "Output"]
}, Open  ]],
Cell[202478, 7179, 231, 6, 70, "Text"],
Cell[CellGroupData[{
Cell[202734, 7189, 186, 4, 70, "Input"],
Cell[202923, 7195, 1274, 35, 70, "Output"]
}, Open  ]],
Cell[204212, 7233, 25, 3, 70, "Text"],
Cell[204240, 7238, 318, 10, 70, "Text"],
Cell[204561, 7250, 747, 26, 70, "Input"],
Cell[205311, 7278, 749, 17, 70, "Text"],
Cell[CellGroupData[{
Cell[206085, 7299, 67, 1, 70, "Input"],
Cell[206155, 7302, 28, 0, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[206220, 7307, 175, 5, 70, "Input"],
Cell[206398, 7314, 224, 8, 70, "Output"]
}, Open  ]],
Cell[206637, 7325, 836, 21, 70, "Text"],
Cell[CellGroupData[{
Cell[207498, 7350, 92, 2, 70, "Input"],
Cell[207593, 7354, 28, 0, 70, "Output"]
}, Open  ]],
Cell[207636, 7357, 72, 1, 70, "Input"],
Cell[CellGroupData[{
Cell[207733, 7362, 27, 0, 70, "Input"],
Cell[207763, 7364, 113, 4, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[207913, 7373, 175, 5, 70, "Input"],
Cell[208091, 7380, 325, 12, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[208453, 7397, 273, 8, 70, "Input"],
Cell[208729, 7407, 31, 0, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[208797, 7412, 96, 2, 70, "Input"],
Cell[208896, 7416, 30, 0, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[208963, 7421, 178, 4, 70, "Input"],
Cell[209144, 7427, 47, 0, 70, "Print"],
Cell[209194, 7429, 789, 24, 70, "Print"]
}, Open  ]],
Cell[CellGroupData[{
Cell[210020, 7458, 174, 4, 70, "Input"],
Cell[210197, 7464, 42, 0, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[210276, 7469, 101, 2, 70, "Input"],
Cell[210380, 7473, 323, 10, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[210740, 7488, 77, 1, 70, "Input"],
Cell[210820, 7491, 45, 1, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[210902, 7497, 73, 1, 70, "Input"],
Cell[210978, 7500, 117, 3, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[211132, 7508, 222, 7, 70, "Input"],
Cell[211357, 7517, 45, 1, 70, "Output"]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[211451, 7524, 73, 0, 70, "Subsubsection"],
Cell[211527, 7526, 290, 6, 70, "Text"],
Cell[211820, 7534, 209, 4, 70, "Text"],
Cell[212032, 7540, 87, 2, 70, "Input"],
Cell[CellGroupData[{
Cell[212144, 7546, 779, 23, 70, "Input"],
Cell[212926, 7571, 985, 31, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[213948, 7607, 212, 5, 70, "Input"],
Cell[214163, 7614, 1025, 31, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[215225, 7650, 200, 5, 70, "Input"],
Cell[215428, 7657, 729, 20, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[216194, 7682, 290, 7, 70, "Input"],
Cell[216487, 7691, 347, 9, 70, "Output"]
}, Open  ]],
Cell[216849, 7703, 360, 12, 70, "Text"]
}, Closed]],
Cell[CellGroupData[{
Cell[217246, 7720, 82, 1, 70, "Subsubsection"],
Cell[217331, 7723, 58, 0, 70, "Text"],
Cell[217392, 7725, 895, 27, 70, "Input"],
Cell[218290, 7754, 257, 6, 70, "Text"],
Cell[218550, 7762, 761, 20, 70, "Input"],
Cell[219314, 7784, 292, 9, 70, "Text"],
Cell[219609, 7795, 184, 5, 70, "Input"],
Cell[219796, 7802, 26, 4, 70, "Text"],
Cell[219825, 7808, 122, 3, 70, "Text"],
Cell[219950, 7813, 158, 3, 70, "Text"],
Cell[220111, 7818, 296, 6, 70, "Text"]
}, Closed]],
Cell[CellGroupData[{
Cell[220444, 7829, 87, 1, 70, "Subsubsection"],
Cell[220534, 7832, 297, 9, 70, "Text"],
Cell[220834, 7843, 301, 8, 70, "Input"],
Cell[CellGroupData[{
Cell[221160, 7855, 187, 5, 70, "Input"],
Cell[221350, 7862, 416, 14, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[221803, 7881, 206, 5, 70, "Input"],
Cell[222012, 7888, 850, 27, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[222899, 7920, 97, 2, 70, "Input"],
Cell[222999, 7924, 2254, 75, 70, "Output"]
}, Open  ]],
Cell[225268, 8002, 600, 16, 70, "Text"]
}, Closed]],
Cell[CellGroupData[{
Cell[225905, 8023, 102, 2, 70, "Subsubsection"],
Cell[226010, 8027, 91, 2, 70, "Text"],
Cell[226104, 8031, 450, 12, 70, "Input"],
Cell[CellGroupData[{
Cell[226579, 8047, 220, 6, 70, "Input"],
Cell[226802, 8055, 144, 4, 70, "Print"],
Cell[226949, 8061, 146, 4, 70, "Print"],
Cell[227098, 8067, 206, 6, 70, "Output"]
}, Open  ]],
Cell[227319, 8076, 268, 5, 70, "Text"],
Cell[227590, 8083, 536, 14, 70, "Input"],
Cell[CellGroupData[{
Cell[228151, 8101, 220, 6, 70, "Input"],
Cell[228374, 8109, 172, 5, 70, "Print"],
Cell[228549, 8116, 170, 5, 70, "Print"],
Cell[228722, 8123, 206, 6, 70, "Output"]
}, Open  ]],
Cell[228943, 8132, 647, 23, 70, "Text"]
}, Closed]],
Cell[CellGroupData[{
Cell[229627, 8160, 210, 4, 70, "Subsubsection"],
Cell[229840, 8166, 597, 21, 70, "Text"],
Cell[230440, 8189, 43, 0, 70, "Text"],
Cell[230486, 8191, 121, 4, 70, "Input"],
Cell[230610, 8197, 95, 2, 70, "Input"],
Cell[230708, 8201, 243, 7, 70, "Input"],
Cell[230954, 8210, 464, 15, 70, "Text"],
Cell[231421, 8227, 202, 5, 70, "Input"],
Cell[231626, 8234, 629, 25, 70, "Text"],
Cell[232258, 8261, 362, 10, 70, "Input"],
Cell[232623, 8273, 103, 3, 70, "Text"],
Cell[232729, 8278, 295, 9, 70, "Input"],
Cell[233027, 8289, 141, 3, 70, "Input"],
Cell[233171, 8294, 304, 8, 70, "Input"],
Cell[233478, 8304, 418, 12, 70, "Input"]
}, Closed]],
Cell[CellGroupData[{
Cell[233933, 8321, 104, 2, 70, "Subsubsection"],
Cell[234040, 8325, 310, 7, 70, "Text"]
}, Closed]],
Cell[CellGroupData[{
Cell[234387, 8337, 126, 3, 70, "Subsubsection"],
Cell[234516, 8342, 576, 13, 70, "Text"]
}, Closed]],
Cell[CellGroupData[{
Cell[235129, 8360, 255, 4, 70, "Subsubsection"],
Cell[235387, 8366, 451, 9, 70, "Text"],
Cell[235841, 8377, 823, 23, 70, "Input"],
Cell[236667, 8402, 65, 0, 70, "Text"],
Cell[236735, 8404, 337, 8, 70, "Input"],
Cell[CellGroupData[{
Cell[237097, 8416, 67, 1, 70, "Input"],
Cell[237167, 8419, 368, 12, 70, "Output"]
}, Open  ]],
Cell[237550, 8434, 198, 6, 70, "Text"],
Cell[CellGroupData[{
Cell[237773, 8444, 125, 3, 70, "Input"],
Cell[237901, 8449, 28, 0, 70, "Output"]
}, Open  ]],
Cell[237944, 8452, 51, 0, 70, "Text"],
Cell[CellGroupData[{
Cell[238020, 8456, 62, 1, 70, "Input"],
Cell[238085, 8459, 29, 0, 70, "Output"]
}, Open  ]]
}, Closed]]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[238187, 8467, 32, 0, 70, "Section"],
Cell[238222, 8469, 117, 3, 70, "Text"],
Cell[CellGroupData[{
Cell[238364, 8476, 127, 3, 70, "Subsubsection"],
Cell[238494, 8481, 88, 2, 70, "Text"],
Cell[238585, 8485, 217, 5, 70, "Input"]
}, Closed]],
Cell[CellGroupData[{
Cell[238839, 8495, 122, 3, 70, "Subsubsection"],
Cell[238964, 8500, 573, 20, 70, "Text"],
Cell[CellGroupData[{
Cell[239562, 8524, 355, 9, 70, "Input"],
Cell[239920, 8535, 42, 0, 70, "Output"]
}, Open  ]],
Cell[239977, 8538, 350, 12, 70, "Text"],
Cell[CellGroupData[{
Cell[240352, 8554, 250, 7, 70, "Input"],
Cell[240605, 8563, 231, 7, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[240873, 8575, 288, 8, 70, "Input"],
Cell[241164, 8585, 264, 8, 70, "Output"]
}, Open  ]],
Cell[241443, 8596, 235, 6, 70, "Text"],
Cell[241681, 8604, 224, 5, 70, "Input"],
Cell[CellGroupData[{
Cell[241930, 8613, 65, 1, 70, "Input"],
Cell[241998, 8616, 57, 0, 70, "Print"],
Cell[242058, 8618, 1330, 37, 70, "Print"]
}, Open  ]],
Cell[243403, 8658, 491, 17, 70, "Text"],
Cell[CellGroupData[{
Cell[243919, 8679, 234, 6, 70, "Input"],
Cell[244156, 8687, 215, 6, 70, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[244408, 8698, 306, 8, 70, "Input"],
Cell[244717, 8708, 432, 18, 70, "Output"]
}, Open  ]],
Cell[245164, 8729, 477, 15, 70, "Text"],
Cell[245644, 8746, 334, 8, 70, "Input"],
Cell[245981, 8756, 363, 9, 70, "Input"],
Cell[246347, 8767, 504, 13, 70, "Text"]
}, Closed]],
Cell[CellGroupData[{
Cell[246888, 8785, 65, 0, 70, "Subsubsection"],
Cell[246956, 8787, 360, 11, 70, "Text"],
Cell[247319, 8800, 92, 2, 70, "Text"]
}, Closed]],
Cell[CellGroupData[{
Cell[247448, 8807, 100, 2, 70, "Subsubsection"],
Cell[247551, 8811, 144, 3, 70, "Text"],
Cell[247698, 8816, 776, 21, 70, "Input"],
Cell[248477, 8839, 162, 3, 70, "Text"]
}, Closed]]
}, Open  ]]
}
]
*)

(* End of internal cache information *)
