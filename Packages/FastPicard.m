(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)

(* :Title:
      FastPicard.m-- a package for evaluating exact symbolic Picard iterates \
for linear systems of differential equations with periodic coefficients*)

(* :Context:FastPicard`*)

(* :Author:
      Armando G.M.Neves 
    aneves@mat.ufmg.br 
    UFMG-Depto.de Matematica 
    Belo Horizonte-MG 
    BRAZIL
  *)

(* :Summary:
      It is possible to calculate exactly and symbolically high-
        order Picard iterates for linear systems of differential equations \
with periodic coefficients WITHOUT using the built-
        in integration function of Mathematica,which is too slow.*)

(* :Copyright:© 2001 by Armando G.M.Neves*)
(* :Package Version:1.0*)
(* :Mathematica Version:4.1*)
(* :History:*)
(* :Keywords:Picard iterates,
  linear differential equations with periodic coefficients,
  Mathieu equation*)

(* :Sources:Armando G.M.Neves,
  Approximating Solutions of Linear Ordinary Differential Equations with \
Periodic Coefficients by Exact Picard Iterates,
  submitted to The Mathematica Journal*)
(* :Warnings:*)
(* :Limitations:
      The package implements a new function for fast symbolic integration,
  which is not meant to be as general as the buit-
      in function Integrate.As long as systems of differential equations of \
the form x'(t)=
    A(t) x(t) whose matrices A(t) are finite linear combinations of constants,
  sines and cossines are considered,
  all integrals occurring in the calculation of Picard iterates can be \
calculated,but that is generally not true for other kinds of systems.*)

(* :Discussion:See the paper mentioned above in Sources*)
(* :Requirements:None*)(* :
      Examples:To calculate the 3rd Picard iterate approximating the solution \
of the Mathieu equation x''(t)+(a+b cos t)x(t)=
    0 with initial conditions x(2)=1, x'(2)=-2,
  type 
    FastPicard[{{0,1},{-a-b Cos[#],0}}&,2,{1,-2},3][t]
  *)
(*set up the package context,including public imports*)
BeginPackage["FastPicard`"]

(*usage messages for the exported functions and the context itself*)

NewIntegrate::usage="NewIntegrate is a function for fast calculating indefinite 
or definite integrals of any function appearing as we perform Picard iterates
for systems of linear differential equations with periodic coefficients. Its
syntax is exactly the same of the built-in function Integrate."

FastPicard::usage="FastPicard[matrix,(tzero),xzero,n] calculates the nth
  Picard iterate approximating the solution of the system of differential \
equations
  x'(t)= matrix(t) x(t) with initial condition x(tzero)=xzero. matrix is a \
matrix whose elements
  are finite linear combinations of constants, sines and cosines. The default \
value for tzero is zero.  "

FundamentalMatrix::usage="FundamentalMatrix[matrix,(tzero),n] calculates a \
matrix
  whose jth column is the nth Picard iterate for x'(t)= matrix(t) x(t) with \
initial condition
  x(tzero)=ej, where ej is a vector with all components equal to zero, except \
the jth component,
  which is equal to 1. The default value for tzero is zero."

FloquetMatrix::usage="FloquetMatrix[matrix, (per), n] is equal to 
  FundamentalMatrix[matrix,0,n][per]. When matrix is periodic with period
  equal to per this result is an approximation using n Picard iterates to
  the Floquet transition matrix. The default value for per is 2 Pi."


Begin["`Private`"]    (*begin the private context (implementation part)*)

NewIntegrate[x_Plus, var_Symbol]:= Map[NewIntegrate[#,var]&, x]

NewIntegrate[c_ x_, var_Symbol]:= c NewIntegrate[x, var]/; FreeQ[c,var]

NewIntegrate[c_, var_Symbol]:= c var/; FreeQ[c,var]

NewIntegrate[var_^n_. ,  var_Symbol]/; n!=-1 :=  var^(n + 1)/(n + 1)

NewIntegrate[Cos[m_.  var_Symbol], var_Symbol] :=  1/m Sin[m var]

NewIntegrate[Sin[m_.  var_Symbol], var_Symbol] := 
    1/m  - 1/m Cos[m var]

NewIntegrate[var_^n_.  Cos[m_.  var_Symbol], var_Symbol] := 
NewIntegrate[var^n Cos[m var],  var] = 
1/m var^n Sin[m var] -  n/m NewIntegrate[var^(n - 1) Sin[m var],  var]

NewIntegrate[var_^n_.  Sin[m_.  var_Symbol], var_Symbol] := 
NewIntegrate[var^n Sin[m var],  var] = 
-1/m var^n Cos[m var] + n/m NewIntegrate[var^(n - 1) Cos[m var], var]

NewIntegrate[function_, {var_, a_ , b_}]:= 
  Module[{int},
    int= NewIntegrate[function, var];
    (int/.var->b)- (int/.var->a)
    ]

prodtosumrules[var_Symbol] = {
Sin[m_.  var] Sin[n_.  var] \[Rule] 1/2(Cos[(m - n) var] - 
              Cos[(m + n) var]),  
Sin[m_.  var] Cos[n_. var] -> 1/2 (Sin[(m - n) var] + 
              Sin[(m + n) var]), 
Cos[m_.  var] Cos[n_.  var] \[Rule] 1/2 (Cos[(m - n) var] + 
              Cos[(m + n) var]), 
Sin[m_.  var]^2 -> 1/2 (1 - Cos[2 m var]), 
Cos[m_.  var]^2 -> 1/2 (1 + Cos[2 m var]) }



auxgather[colnonpoly_Plus, time_]:= Collect[#,time]&/@colnonpoly

auxgather[colnonpoly_, time_]:= Expand[colnonpoly]

gather[x_,time_]:= Module[{xexpanded=Expand[x],poly,nonpoly},
    poly= xexpanded/.{Sin[_. time]\[Rule]0,Cos[_. time]\[Rule]0};
    nonpoly= xexpanded-poly;
    Collect[poly,time]+
      auxgather[Collect[nonpoly,{Cos[_. time],Sin[_. time]}],time]
    ]

onepicard[matrix_,tzero_, xzero_,p_]:= 
  Module[{t,s}, 
    If[tzero\[Equal]0,
      Function[t,
        xzero+Map[NewIntegrate[#,t]&,
            gather[#,t]&/@(Expand[matrix[t].p[t]]/.prodtosumrules[t] )]] ,
      Function[t,
        xzero+Map[NewIntegrate[#,{s,tzero,t}]&,
            gather[#,s]&/@(Expand[matrix[s].p[s]]/.prodtosumrules[s] )]]
      	]
    	]

FastPicard[matrix_, tzero_:0, xzero_, n_Integer]:= 
  Nest[onepicard[matrix, tzero, xzero,#]&,xzero&,n]

FundamentalMatrix[matrix_, tzero_:0, n_Integer]:= 
  Function[t,
    Transpose[
      FastPicard[matrix, tzero, #, n][t]&/@IdentityMatrix[Length[matrix[t]]]]]

FloquetMatrix[matrix_, per_:2Pi, n_Integer]:= 
  FundamentalMatrix[matrix,0,n][t]/.t\[Rule]2Pi

End[]         (*end the private context*)

Protect[FastPicard,FundamentalMatrix,FloquetMatrix]

(*protect exported symbols*)

EndPackage[]  (*end the package context*)
