(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)















BeginPackage["MathSVM`",{"Graphics`ImplicitPlot`",
"Graphics`Graphics`","LinearAlgebra`MatrixManipulation`"}];



\!\(\(SVMClassify::usage = "\<Classify[K,X,\[Alpha],y,x] predicts a response y for a new case x using the trained svm model {kernel K, data X,multipliers \[Alpha],labels y}.\>";\)\[IndentingNewLine]
  \(KernelMatrix::usage = "\<KernelMatrix[K,X] computes the (full) matrix with elements K[x\[LeftDoubleBracket]i\[RightDoubleBracket],x\[LeftDoubleBracket]j\[RightDoubleBracket]].\>";\)\[IndentingNewLine]
  \(IdentityKernel::usage = "\<IdentityKernel[x,y] is the function x.y.\>";\)\[IndentingNewLine]
  \(RBFKernel::usage = "\<RBFKernel[x,y] is the function Exp[-\[Gamma](x-y).(x-y)].\>";\)\[IndentingNewLine]
  \(PolynomialKernel::usage = \*"\"\<PolynomialKernel[x,y,d], where d is an integer, is the function (x.y+1\!\(\()\^d\)\).\>\"";\)\[IndentingNewLine]
  \(SeparableSVM::usage = "\<SeparableSVM[X,y,\[Tau]] trains a separable SVM on data X, labels y, and solution tolerance \[Tau] (see QPSolve). Returns the multiplier vector \[Alpha]. Option KernelFunction determines the kernel to use; default is IdentityKernel (i.e., no kernel).\>";\)\[IndentingNewLine]
  \(NonseparableSVM::usage = "\<NonSeparableSVM[X,y,C,\[Tau]] trains an non-separable SVM on data X, labels y, penalty term C and solution tolerance \[Tau] (see QPSolve). Returns the multiplier vector \[Alpha]. Option KernelFunction determines the kernel to use; default is IdentityKernel (i.e., no kernel).\>";\)\[IndentingNewLine]
  \(RegressionSVM::usage = "\<RegressionSVM[X,y,C,\[Epsilon],\[Tau]] trains a regression SVM with \[Epsilon]-insensitive loss function on regression variables X, response variable y, error tolerace C and solution tolerance \[Tau] (see QPSolve). Returns the multiplier vector \[Alpha]. Option KernelFunction determines the kernel to use; default is IdentityKernel (i.e., no kernel). Note that this creates a dual problem of size 2*(#samples).\>";\)\[IndentingNewLine]
  \(RegressionBias::usage = "\<RegressionBias[\[Alpha],X] returns the bias term for regression problems (this differs form the classification formulations).\>";\)\[IndentingNewLine]
  \(RegressionFunction::usage = "\<RegressionFunction[\[Alpha],X,x] returns the regression function f(x) defined by \[Alpha] and X. Option KernelFunction determines the kernel to use; default is IdentityKernel (i.e., no kernel).\>";\)\[IndentingNewLine]
  \(RegressionSupportVectors::usage = "\<RegressionSupportVectors[\[Alpha]] returns the support vectors for a regression model defined by \[Alpha].\>";\)\[IndentingNewLine]
  \(SupportVectors::usage = "\<SupportVectors[\[Alpha],y] returns {I+,I-} where I+/- are the index vector for support vectors in class +/-.\>";\)\[IndentingNewLine]
  \(WeightVector::usage = "\<WeightVector[\[Alpha],X,y] returns the weight (normal) vector for the separating plane. This is only well-defined when \[Alpha] is the result of an SVM trained with IdentityKernel.\>";\)\[IndentingNewLine]
  \(Bias::usage = "\<Bias[\[Alpha],X,y] gives the bias term for the trained svm model {kernel K, data X,multipliers \[Alpha],labels y}. Option KernelFunction determines the kernel to use; default is IdentityKernel (i.e., no kernel).\>";\)\[IndentingNewLine]
  \(KernelDistance::usage = \*"\"\<KernelDistance[x,y,K] gives the euclidean (\!\(L\_2\)) distance between x and y in the feature space induces by the kernel K.\>\"";\)\[IndentingNewLine]
  \(SVMPlot::usage = \*"\"\<SVMPlot[\[Alpha],X,y] produces a typical SVM-plot of the SVM solution \[Alpha], together with data points X (in \!\(R\^2\)!) and labels y. Option KernelFunction determines the kernel to use for drawing decision boundaries.\>\"";\)\[IndentingNewLine]
  \(SVMDataPlot::usage = "\<SVMDataPlot[X,y] just plots the data points in X with classes {+1,-1} highlighted.\>";\)\[IndentingNewLine]
  \(RegressionSVMPlot::usage = "\<RegressionSVMPlot[\[Alpha],X,y,\[Epsilon]] draws data points {X,y}, the regression function determined by {\[Alpha],X} and a 'corridor' of with \[Epsilon].\>";\)\[IndentingNewLine]
  \(QPSolve::usage = "\<QPSolve[Q,p,a,b,c,y,\[Tau]] solves the quadratic programming problem min \[Alpha].Q.\[Alpha]+p.\[Alpha], subject to a\[LessEqual]\[Alpha]\[LessEqual]b and y.\[Alpha]=c. QPSolve uses the GSMO algorithm described by Keerthi et al. \[Tau] is a solution tolerance parameter (0.01 or so is usually good enough for SVMs). Q must be a positive semidefinite matrix to guarantee convergence.\>";\)\)



FormulationOnly::usage="This option causes SVM training functions to merely formulate the QP, without solving it.";\

KernelFunction::usage="KernelFunction->K[x,y] is used in many SVM-related functions to define the kernel function.";\

DebugSolver;

Begin["MathSVM`Private`"];





KernelMatrix[K_,X_]:=Outer[K,X,X,1]



IdentityKernel[x_,y_]=x.y







RBFKernel[x_,y_,\[Gamma]_]=Exp[-\[Gamma](x-y).(x-y)]





\!\(PolynomialKernel[x_, y_, d_Integer] = \((x . y + 1)\)\^d\)







SVMClassify[K_,X_,\[Alpha]_,y_,b_,x_]:=
  Sign[Total[y*\[Alpha]*Map[K[#,x]&,X]]+b]

SVMClassify[K_,X_,\[Alpha]_,y_,x_]:=
  Sign[Total[y*\[Alpha]*Map[K[#,x]&,X]]+Bias[\[Alpha],X,y,K]]





Options[SeparableSVM]={FormulationOnly\[Rule]False,
    KernelFunction\[Rule]IdentityKernel}

SeparableSVM[X_,y_,\[Tau]_,opts___]:=
  Module[{l,qp,K},
    l=Length[X];
    K=KernelFunction/.{opts}/.Options[SeparableSVM];
    qp=
      {KernelMatrix[K,X]*Outer[Times,y,y],
        Table[-1,{l}],
        Table[0,{l}],
        Table[\[Infinity],{l}],
        0,
        y,
        \[Tau]};
    If[FormulationOnly/.{opts}/.Options[SeparableSVM],
      qp,
      Apply[QPSolve,qp]]]







Options[NonseparableSVM]={FormulationOnly\[Rule]False,
    KernelFunction\[Rule]IdentityKernel}

NonseparableSVM[X_,y_,C_,\[Tau]_,opts___]:=
  Module[{l,qp,K},
    l=Length[X];
    K=KernelFunction/.{opts}/.Options[NonseparableSVM];
    qp=
      {KernelMatrix[K,X]*Outer[Times,y,y],
        Table[-1,{l}],
        Table[0,{l}],
        Table[C,{l}],
        0,
        y,
        \[Tau]};
    If[FormulationOnly/.{opts}/.Options[NonseparableSVM],
      qp,
      Apply[QPSolve,qp]]]











Options[RegressionSVM]={FormulationOnly\[Rule]False,
    KernelFunction\[Rule]IdentityKernel}

RegressionSVM[X_,z_,C_,\[Epsilon]_,\[Tau]_,opts___]:=
  Module[{l,Q,\[Alpha]},
    l=Length[X];
    K=KernelFunction/.{opts}/.Options[RegressionSVM];
    qp=
      {KernelMatrix[K,Join[X,-X]],
        Table[\[Epsilon],{2l}]+Join[z,-z],
        Join[Table[0,{2l}]],
        Join[Table[C,{2l}]],
        0,
        Join[Table[1,{l}],Table[-1,{l}]],
        \[Tau]};
    If[FormulationOnly/.{opts}/.Options[RegressionSVM],
      qp,
      Apply[QPSolve,qp]]]

RegressionSVM[X_?VectorQ,z_,C_,\[Epsilon]_,\[Tau]_,opts___]:=
  RegressionSVM[Partition[X,1],z,C,\[Epsilon],\[Tau],opts]



RegressionBias[\[Alpha]_,X_?MatrixQ,z_,\[Epsilon]_,opts___]:=
  Module[{l=Length[X],K},
    K=KernelFunction/.{opts}/.Options[RegressionSVM];
    sv=SupportVectors[\[Alpha]]\[LeftDoubleBracket]1\[RightDoubleBracket];
    \[Epsilon]+z\[LeftDoubleBracket]sv\[RightDoubleBracket]-
      Sum[(\[Alpha]\[LeftDoubleBracket]
                i+l\[RightDoubleBracket]-\[Alpha]\[LeftDoubleBracket]
                i\[RightDoubleBracket])K[
            X\[LeftDoubleBracket]i\[RightDoubleBracket],
            X\[LeftDoubleBracket]sv\[RightDoubleBracket]],{i,l}]]

RegressionBias[\[Alpha]_,X_?VectorQ,z_,\[Epsilon]_,opts___]:=
  RegressionBias[\[Alpha],Partition[X,1],z,\[Epsilon],opts]

RegressionFunction[\[Alpha]_,X_?MatrixQ,z_,\[Epsilon]_,x_?VectorQ,opts___]:=
  Module[{l=Length[X],K,b},
    b=RegressionBias[\[Alpha],X,z,\[Epsilon],opts];
    K=KernelFunction/.{opts}/.Options[RegressionSVM];
    Sum[(\[Alpha]\[LeftDoubleBracket]
                i+l\[RightDoubleBracket]-\[Alpha]\[LeftDoubleBracket]
                i\[RightDoubleBracket])K[
            X\[LeftDoubleBracket]i\[RightDoubleBracket],x],{i,l}]+b]

RegressionFunction[\[Alpha]_,X_?VectorQ,z_,\[Epsilon]_,x_,opts___]:=
  RegressionFunction[\[Alpha],Partition[X,1],z,\[Epsilon],{x},opts]



RegressionSupportVectors[\[Alpha]_List]:=
  Module[{l=Length[\[Alpha]]/2},
    SupportVectors[\[Alpha],Join[Table[1,{l}],Table[-1,{l}]]]-{0,l}]







SupportVectors[\[Alpha]_List,
    y_List]:={Position[\[Alpha]*y,_?Positive]//Flatten,
    Position[\[Alpha]*y,_?Negative]//Flatten}



SupportVectors[\[Alpha]_List]:=
  Flatten[Position[\[Alpha],a_/;a\[NotEqual]0]]



WeightVector[\[Alpha]_List,X_?MatrixQ,y_List]:=
  Sum[y\[LeftDoubleBracket]i\[RightDoubleBracket]*\[Alpha]\[LeftDoubleBracket]
        i\[RightDoubleBracket]*X\[LeftDoubleBracket]i\[RightDoubleBracket],{i,
      Length[X]}]



Options[Bias]={KernelFunction\[Rule]IdentityKernel}

Bias[\[Alpha]_,X_,y_,opts___]:=
  Module[{sv,K},
    K=KernelFunction/.{opts}/.Options[Bias];
    sv=SupportVectors[\[Alpha],y];
    -(Total[\[Alpha]*y*
                Map[K[X\[LeftDoubleBracket]
                        sv\[LeftDoubleBracket]1,
                          1\[RightDoubleBracket]\[RightDoubleBracket],#]&,X]]+
            Total[\[Alpha]*y*
                Map[K[X\[LeftDoubleBracket]
                        sv\[LeftDoubleBracket]2,
                          1\[RightDoubleBracket]\[RightDoubleBracket],#]&,
                  X]])/2]





\!\(KernelDistance[x_, y_, K_] := \@\(K[x, x] + K[y, y] - 2  K[x, y]\)\)







Options[SVMPlot]={KernelFunction\[Rule]IdentityKernel}

SVMPlot[\[Alpha]_,X_?MatrixQ,y_,opts___]:=
  Module[{x1range,x2range,sv,df,x1,x2,K},
    K=KernelFunction/.{opts}/.Options[SVMPlot];
    x1range={x1,Min[X\[LeftDoubleBracket]All,1\[RightDoubleBracket]],
        Max[X\[LeftDoubleBracket]All,1\[RightDoubleBracket]]};
    x2range={x2,Min[X\[LeftDoubleBracket]All,2\[RightDoubleBracket]],
        Max[X\[LeftDoubleBracket]All,2\[RightDoubleBracket]]};
    sv=SupportVectors[\[Alpha],y];
    df=Total[\[Alpha]*y*Map[K[{x1,x2},#]&,X]]+Bias[\[Alpha],X,y,opts];
    DisplayTogether[
      ListPlot[X\[LeftDoubleBracket]Flatten[sv]\[RightDoubleBracket],
        PlotStyle\[Rule]{Hue[0.6],PointSize[0.015]}],
      ListPlot[Extract[X,Position[y,1]]],
      ListPlot[Extract[X,Position[y,-1]],PlotStyle\[Rule]{GrayLevel[0.6]}],
      ImplicitPlot[df\[Equal]0,x1range,x2range],
      ImplicitPlot[df\[Equal]1,x1range,x2range,
        PlotStyle\[Rule]Dashing[{.01,.01}]],
      ImplicitPlot[df\[Equal]-1,x1range,x2range,
        PlotStyle\[Rule]Dashing[{.01,.01}]],
      RemainingOptions[{KernelFunction},opts]]]

SVMDataPlot[X_?MatrixQ,y_,opts___]:=
  DisplayTogether[
    ListPlot[Extract[X,Position[y,1]]],
    ListPlot[Extract[X,Position[y,-1]],PlotStyle\[Rule]{GrayLevel[0.6]}],opts]



Options[RegressionSVMPlot]={KernelFunction\[Rule]IdentityKernel}

RegressionSVMPlot[\[Alpha]_,X_?VectorQ,z_,\[Epsilon]_,opts___]:=
  Module[{K,rf,sv},
    K=KernelFunction/.{opts}/.Options[RegressionSVMPlot];
    rf=RegressionFunction[\[Alpha],X,z,\[Epsilon],x,opts];
    sv=RegressionSupportVectors[\[Alpha]];
    DisplayTogether[
      Plot[rf,{x,Min[X],Max[X]}],
      Plot[rf+\[Epsilon],{x,Min[X],Max[X]},
        PlotStyle\[Rule]Dashing[{.01,.01}]],
      Plot[rf-\[Epsilon],{x,Min[X],Max[X]},
        PlotStyle\[Rule]Dashing[{.01,.01}]],
      ListPlot[
        Thread[{X\[LeftDoubleBracket]Flatten[sv]\[RightDoubleBracket],
            z\[LeftDoubleBracket]Flatten[sv]\[RightDoubleBracket]}],
        PlotStyle\[Rule]{Hue[0.6],PointSize[0.015]}],
      ListPlot[Thread[{X,z}]],
      PlotRange\[Rule]All]]











Options[QPSolve]={DebugSolver\[Rule]False}

QPSolve[Q_,p_,a_,b_,c_,y_,\[Tau]_,opts___]:=
  Module[{\[Alpha],l,Isets,Iup,Ilow,F,B,oldB,M,k,debug},
    debug=DebugSolver/.{opts}/.Options[QPSolve];
    l=Length[Q];
    \[Alpha]=FeasiblePoint[a,b,y,c];
    If[\[Alpha]\[Equal]Null,Return[Null]];k=0;
    While[True,
      Isets=GetIndexSets[\[Alpha],a,b,y];
      Iup=UpperBoundarySet[Isets];
      Ilow=LowerBoundarySet[Isets];
      F=(Q.\[Alpha]+p)/y;
      If[QPOptimalQ[Iup,Ilow,F,\[Tau]],Break[]];
      B=GetViolatingPair[Isets\[LeftDoubleBracket]1\[RightDoubleBracket],Iup,
          Ilow,F,\[Tau]];
      If[B\[Equal]Null,Return["Error: no violating pair"]];
      If[B\[Equal]oldB,
        Print["Error: stuck on violating pair ",B];
        Print[
          "Subproblem = ",{Q\[LeftDoubleBracket]B,B\[RightDoubleBracket],
            p\[LeftDoubleBracket]B\[RightDoubleBracket]+
              Q\[LeftDoubleBracket]B,
                  M\[RightDoubleBracket].\[Alpha]\[LeftDoubleBracket]
                  M\[RightDoubleBracket],
            a\[LeftDoubleBracket]B\[RightDoubleBracket],
            b\[LeftDoubleBracket]B\[RightDoubleBracket],
            y\[LeftDoubleBracket]
              B\[RightDoubleBracket],\[Alpha]\[LeftDoubleBracket]
              B\[RightDoubleBracket],
            y\[LeftDoubleBracket]
                B\[RightDoubleBracket].\[Alpha]\[LeftDoubleBracket]
                B\[RightDoubleBracket]}];
        Print["F = ",F\[LeftDoubleBracket]B\[RightDoubleBracket]];
        Print["Isets = ", Isets];
        Return[\[Alpha]];];
      M=Complement[Range[1,l],B];
      If[debug,
        Print["--------------NEW PAIR:------------"];
        Print["viol. pair = ",B];
        Print[
          "\[Alpha] = ",\[Alpha]\[LeftDoubleBracket]B\[RightDoubleBracket]];
        Print["grad = ",F\[LeftDoubleBracket]B\[RightDoubleBracket]];
        Print["current tau = ",Abs[
            F\[LeftDoubleBracket]
                B\[LeftDoubleBracket]1\[RightDoubleBracket]\
\[RightDoubleBracket]-
              F\[LeftDoubleBracket]
                B\[LeftDoubleBracket]2\[RightDoubleBracket]\
\[RightDoubleBracket]]]];
      \[Alpha]\[LeftDoubleBracket]B\[RightDoubleBracket]=
        QPSolve[Q\[LeftDoubleBracket]B,B\[RightDoubleBracket],
          p\[LeftDoubleBracket]B\[RightDoubleBracket]+
            Q\[LeftDoubleBracket]B,
                M\[RightDoubleBracket].\[Alpha]\[LeftDoubleBracket]M\
\[RightDoubleBracket],a\[LeftDoubleBracket]B\[RightDoubleBracket],
          b\[LeftDoubleBracket]B\[RightDoubleBracket],
          y\[LeftDoubleBracket]B\[RightDoubleBracket],\[Alpha]\
\[LeftDoubleBracket]B\[RightDoubleBracket]];
      If[debug,
        Print["--------------NEW SOLUTION:------------"];
        Print[
          "\[Alpha] = ",\[Alpha]\[LeftDoubleBracket]B\[RightDoubleBracket]]];
      oldB=B];
    \[Alpha]]





FeasiblePoint[a_,b_,y_,c_]:=
  Module[{\[Alpha],l=Length[y]},
    \[Alpha]=Table[0,{l}];
    Do[
      \[Alpha]\[LeftDoubleBracket]
          i\[RightDoubleBracket]=(c-Drop[y,{i}].Drop[\[Alpha],{i}])/
          y\[LeftDoubleBracket]i\[RightDoubleBracket];
      \[Alpha]\[LeftDoubleBracket]i\[RightDoubleBracket]=
        Min[Max[\[Alpha]\[LeftDoubleBracket]i\[RightDoubleBracket],
            a\[LeftDoubleBracket]i\[RightDoubleBracket]],
          b\[LeftDoubleBracket]i\[RightDoubleBracket]];
      If[y.\[Alpha]\[Equal]c,Break],
      {i,l}];
    If[y.\[Alpha]\[Equal]c,\[Alpha],Null]]





\!\(QPSolve[Q_ /; Length[Q] \[Equal] 2, p_, a_, b_, y_, \[Alpha]_] := \[IndentingNewLine]Module[{t, \[Alpha]new, c, tn, td}, \[IndentingNewLine]c = \[Alpha] . y; \[IndentingNewLine]tn = \(-\((\((Q\[LeftDoubleBracket]1\[RightDoubleBracket] . \[Alpha] + p\[LeftDoubleBracket]1\[RightDoubleBracket])\)/y\[LeftDoubleBracket]1\[RightDoubleBracket] - \((Q\[LeftDoubleBracket]2\[RightDoubleBracket] . \[Alpha] + p\[LeftDoubleBracket]2\[RightDoubleBracket])\)/y\[LeftDoubleBracket]2\[RightDoubleBracket])\)\); \[IndentingNewLine]td = Q\[LeftDoubleBracket]1, 1\[RightDoubleBracket]/y\[LeftDoubleBracket]1\[RightDoubleBracket]\^2 + Q\[LeftDoubleBracket]2, 2\[RightDoubleBracket]/y\[LeftDoubleBracket]2\[RightDoubleBracket]\^2 - \((Q\[LeftDoubleBracket]1, 2\[RightDoubleBracket] + Q\[LeftDoubleBracket]2, 1\[RightDoubleBracket])\)/\((y\[LeftDoubleBracket]1\[RightDoubleBracket] y\[LeftDoubleBracket]2\[RightDoubleBracket])\); \[IndentingNewLine]t = If[td \[NotEqual] 0, tn/td, Sign[tn]*\[Infinity]]; \[IndentingNewLine]\[Alpha]new = \[Alpha] + {t/y\[LeftDoubleBracket]1\[RightDoubleBracket], \(-t\)/y\[LeftDoubleBracket]2\[RightDoubleBracket]}; \[IndentingNewLine]If[\[Alpha]new\[LeftDoubleBracket]1\[RightDoubleBracket] < a\[LeftDoubleBracket]1\[RightDoubleBracket], \[Alpha]new = {a\[LeftDoubleBracket]1\[RightDoubleBracket], \((c - a\[LeftDoubleBracket]1\[RightDoubleBracket] y\[LeftDoubleBracket]1\[RightDoubleBracket])\)/y\[LeftDoubleBracket]2\[RightDoubleBracket]}]; \[IndentingNewLine]If[\[Alpha]new\[LeftDoubleBracket]1\[RightDoubleBracket] > b\[LeftDoubleBracket]1\[RightDoubleBracket], \[Alpha]new = {b\[LeftDoubleBracket]1\[RightDoubleBracket], \((c - b\[LeftDoubleBracket]1\[RightDoubleBracket] y\[LeftDoubleBracket]1\[RightDoubleBracket])\)/y\[LeftDoubleBracket]2\[RightDoubleBracket]}]; \[IndentingNewLine]If[\[Alpha]new\[LeftDoubleBracket]2\[RightDoubleBracket] < a\[LeftDoubleBracket]2\[RightDoubleBracket], \[Alpha]new = {\((c - a\[LeftDoubleBracket]2\[RightDoubleBracket] y\[LeftDoubleBracket]2\[RightDoubleBracket])\)/y\[LeftDoubleBracket]1\[RightDoubleBracket], a\[LeftDoubleBracket]2\[RightDoubleBracket]}]; \[IndentingNewLine]If[\[Alpha]new\[LeftDoubleBracket]2\[RightDoubleBracket] > b\[LeftDoubleBracket]2\[RightDoubleBracket], \[Alpha]new = {\((c - b\[LeftDoubleBracket]2\[RightDoubleBracket] y\[LeftDoubleBracket]2\[RightDoubleBracket])\)/y\[LeftDoubleBracket]1\[RightDoubleBracket], b\[LeftDoubleBracket]2\[RightDoubleBracket]}]; \[IndentingNewLine]\[Alpha]new]\)





MyKronDelta[a_?VectorQ,b_?VectorQ]:=
  Map[KroneckerDelta[#\[LeftDoubleBracket]1\[RightDoubleBracket],#\
\[LeftDoubleBracket]2\[RightDoubleBracket]]&,Thread[{a,b}]]

GetIndexSets[\[Alpha]_List,a_List,b_List,y_List]:=
  Map[Flatten,
    {Position[(1-UnitStep[a-\[Alpha]])(1-UnitStep[-(b-\[Alpha])]),1],
      Position[MyKronDelta[\[Alpha],a]*UnitStep[y],1],
      Position[MyKronDelta[\[Alpha],b]*UnitStep[-y],1],
      Position[MyKronDelta[\[Alpha],b]*UnitStep[y],1],
      Position[MyKronDelta[\[Alpha],a]*UnitStep[-y],1]}]



UpperBoundarySet[Isets_]:=
  Isets[[1]] \[Union] Isets[[2]] \[Union] Isets[[3]]



LowerBoundarySet[Isets_]:=
  Isets[[1]] \[Union] Isets[[4]] \[Union] Isets[[5]]





ViolatingPairQ[Iup_,Ilow_,i_,j_,F_List,\[Tau]_]:=
  (MemberQ[Iup,i]\[And]
        MemberQ[Ilow,
          j]\[And](F\[LeftDoubleBracket]j\[RightDoubleBracket]-
              F\[LeftDoubleBracket]
                i\[RightDoubleBracket]>\[Tau]))\[Or](MemberQ[Ilow,i]\[And]
        MemberQ[Iup,
          j]\[And](F\[LeftDoubleBracket]i\[RightDoubleBracket]-
              F\[LeftDoubleBracket]j\[RightDoubleBracket]>\[Tau]))



GetViolatingPair[I0_,Iup_,Ilow_,F_List,\[Tau]_]:=
  Module[{o,i,j,l},
    If[Max[F\[LeftDoubleBracket]I0\[RightDoubleBracket]]-
          Min[F\[LeftDoubleBracket]I0\[RightDoubleBracket]]>\[Tau],
      o=Ordering[F\[LeftDoubleBracket]I0\[RightDoubleBracket]];
      {I0\[LeftDoubleBracket]First[o]\[RightDoubleBracket],
        I0\[LeftDoubleBracket]Last[o]\[RightDoubleBracket]},
      (* else no violating pair on I0, scan entire {1...l} *)
      i=1;l=Length[F];
      While[i\[LessEqual]l,
        j=1;
        While[j\[LessEqual]l,
          If[ViolatingPairQ[Iup,Ilow,i,j,F,\[Tau]],
            Return[{i,j}]];
          j++];
        i++];
      Null]]





QPOptimalQ[Iup_,Ilow_,F_List,\[Tau]_]:=
  Max[F\[LeftDoubleBracket]Ilow\[RightDoubleBracket]]-
      Min[F\[LeftDoubleBracket]Iup\[RightDoubleBracket]]\[LessEqual]\[Tau]





RemainingOptions[r_List,opts___]:=
  Sequence[DeleteCases[{opts},Apply[Alternatives,Map[Rule[#,_]&,r]]]]



End[];

EndPackage[];
